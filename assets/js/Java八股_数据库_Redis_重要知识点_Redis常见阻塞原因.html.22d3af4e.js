"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[3446],{6262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,s]of a)i[e]=s;return i}},9333:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>r,data:()=>t});var s=i(641);const n=[(0,s.Fv)('<h1 id="redis-常见阻塞原因" tabindex="-1"><a class="header-anchor" href="#redis-常见阻塞原因"><span>Redis 常见阻塞原因</span></a></h1><p>Redis 是一个高性能的内存数据库，但在某些情况下，可能会出现性能瓶颈或阻塞现象，导致 Redis 无法响应请求，影响系统的整体性能。以下是 Redis 中常见的阻塞原因及其分析。</p><hr><h3 id="_1-o-n-命令" tabindex="-1"><a class="header-anchor" href="#_1-o-n-命令"><span>1. O(n) 命令</span></a></h3><p>一些 Redis 命令的时间复杂度为 O(n)，即其执行时间与数据量成正比。对于大数据集，这些命令的执行可能会导致 Redis 被阻塞。常见的 O(n) 命令包括：</p><ul><li><strong><code>SORT</code></strong>：排序命令，如果排序的数据量很大，可能会导致 Redis 执行排序时阻塞。</li><li><strong><code>LRANGE</code></strong>：返回列表中某一范围内的元素，如果列表很长，执行此命令时 Redis 可能会卡住，直到所有数据返回。</li></ul><h4 id="解决办法" tabindex="-1"><a class="header-anchor" href="#解决办法"><span>解决办法：</span></a></h4><ul><li>避免在高并发环境下使用 O(n) 命令。</li><li>如果需要对大数据集进行操作，可以考虑将数据分片，或者使用 Redis 的异步操作进行数据处理。</li></ul><hr><h3 id="_2-save-创建-rdb-快照" tabindex="-1"><a class="header-anchor" href="#_2-save-创建-rdb-快照"><span>2. SAVE 创建 RDB 快照</span></a></h3><p>当执行 <strong><code>SAVE</code></strong> 命令时，Redis 会将当前数据库的状态保存为一个 RDB 快照文件。在这个过程中，Redis 会阻塞所有客户端请求，直到快照完成。这是因为 Redis 在保存数据时会创建一个子进程来执行快照操作，主进程会被阻塞。</p><h4 id="解决办法-1" tabindex="-1"><a class="header-anchor" href="#解决办法-1"><span>解决办法：</span></a></h4><ul><li>使用 <strong><code>BGSAVE</code></strong> 命令代替 <strong><code>SAVE</code></strong>，因为 <strong><code>BGSAVE</code></strong> 会在后台创建快照，不会阻塞主进程。</li><li>减少 RDB 快照的频率，尤其是在高负载情况下。</li></ul><hr><h3 id="_3-aof-append-only-file-相关阻塞" tabindex="-1"><a class="header-anchor" href="#_3-aof-append-only-file-相关阻塞"><span>3. AOF（Append-Only File）相关阻塞</span></a></h3><p>AOF 是 Redis 提供的持久化机制之一，记录每一个写操作命令，以便在重启时恢复数据。AOF 可能会引起以下几种阻塞：</p><h4 id="_3-1-aof-日志记录阻塞" tabindex="-1"><a class="header-anchor" href="#_3-1-aof-日志记录阻塞"><span>3.1 AOF 日志记录阻塞</span></a></h4><p>每当 Redis 执行写操作时，会将操作记录到 AOF 文件中。对于高频写操作的场景，AOF 日志记录可能会阻塞 Redis，尤其是当磁盘 I/O 操作繁忙时。</p><h4 id="_3-2-aof-刷盘阻塞" tabindex="-1"><a class="header-anchor" href="#_3-2-aof-刷盘阻塞"><span>3.2 AOF 刷盘阻塞</span></a></h4><p>AOF 持久化的另一部分操作是将数据刷写到磁盘。默认情况下，Redis 会每次执行写操作后将 AOF 数据刷写到磁盘，阻塞主线程直到刷盘完成。大规模写操作会导致 Redis 阻塞，特别是使用 <strong><code>appendfsync always</code></strong> 配置时，Redis 在每次写操作后都会等待刷盘完成。</p><h4 id="_3-3-aof-重写阻塞" tabindex="-1"><a class="header-anchor" href="#_3-3-aof-重写阻塞"><span>3.3 AOF 重写阻塞</span></a></h4><p>当 AOF 文件变得非常大时，Redis 会触发 AOF 重写操作。AOF 重写的过程会创建一个新的 AOF 文件，旧文件会被逐步替换。虽然 AOF 重写是在后台进行的，但如果系统的磁盘 I/O 性能较差，重写过程可能会引发阻塞，影响 Redis 的响应能力。</p><h4 id="解决办法-2" tabindex="-1"><a class="header-anchor" href="#解决办法-2"><span>解决办法：</span></a></h4><ul><li>配置 <strong><code>appendfsync everysec</code></strong>，而不是每次写操作都执行刷盘，以减少刷盘次数。</li><li>使用 <strong><code>BGREWRITEAOF</code></strong> 命令定期进行 AOF 重写，避免文件过大。</li><li>配置异步日志记录，减少阻塞。</li></ul><hr><h3 id="_4-大-key" tabindex="-1"><a class="header-anchor" href="#_4-大-key"><span>4. 大 Key</span></a></h3><p>在 Redis 中，<strong>大 Key</strong>（即占用大量内存的键）是一个常见的性能瓶颈。如果执行操作的键非常大，可能会导致 Redis 发生阻塞，具体包括：</p><h4 id="_4-1-查找大-key" tabindex="-1"><a class="header-anchor" href="#_4-1-查找大-key"><span>4.1 查找大 Key</span></a></h4><p>如果查询的 Key 关联的数据量巨大，Redis 在处理这些操作时会阻塞，导致延迟增加。举例来说，查询一个巨大的哈希表、列表或集合可能会导致长时间的阻塞。</p><h4 id="_4-2-删除大-key" tabindex="-1"><a class="header-anchor" href="#_4-2-删除大-key"><span>4.2 删除大 Key</span></a></h4><p>删除一个非常大的 Key 也会导致 Redis 阻塞，尤其是当删除的 Key 中包含大量的数据项时。例如，删除一个大列表、大集合或大哈希表时，Redis 需要扫描并删除所有元素，期间会导致阻塞。</p><h4 id="_4-3-清空数据库" tabindex="-1"><a class="header-anchor" href="#_4-3-清空数据库"><span>4.3 清空数据库</span></a></h4><p>清空整个 Redis 数据库（使用 <strong><code>FLUSHDB</code></strong> 或 <strong><code>FLUSHALL</code></strong> 命令）时，Redis 会删除所有 Key，并在此过程中阻塞所有客户端请求。</p><h4 id="解决办法-3" tabindex="-1"><a class="header-anchor" href="#解决办法-3"><span>解决办法：</span></a></h4><ul><li>尽量避免存储过大的数据结构，分片存储数据。</li><li>使用 Redis 集群分担数据负载，避免单个节点存储过大的数据。</li><li>对大 Key 使用延迟删除或异步操作。</li></ul><hr><h3 id="_5-集群扩容" tabindex="-1"><a class="header-anchor" href="#_5-集群扩容"><span>5. 集群扩容</span></a></h3><p>Redis 集群在进行扩容时，需要重新分配槽并迁移数据。在扩容过程中，可能会导致 Redis 的高延迟，甚至出现阻塞现象。这是因为在数据迁移期间，Redis 需要同步大量的数据。</p><h4 id="解决办法-4" tabindex="-1"><a class="header-anchor" href="#解决办法-4"><span>解决办法：</span></a></h4><ul><li>选择在低流量时段进行扩容，避免对现有请求的影响。</li><li>使用 <strong><code>resharding</code></strong> 操作，逐步迁移数据，减少集群的压力。</li></ul><hr><h3 id="_6-swap-内存交换" tabindex="-1"><a class="header-anchor" href="#_6-swap-内存交换"><span>6. Swap（内存交换）</span></a></h3><p>如果 Redis 占用了系统的所有物理内存，操作系统可能会使用 <strong>Swap</strong> 来交换内存数据。当 Redis 数据从物理内存交换到硬盘时，整个过程的延迟会显著增加，从而导致 Redis 阻塞。</p><h4 id="解决办法-5" tabindex="-1"><a class="header-anchor" href="#解决办法-5"><span>解决办法：</span></a></h4><ul><li>确保 Redis 实例运行在足够的内存上，避免触发 Swap。</li><li>配置操作系统和 Redis 的内存限制，防止 Redis 使用系统交换空间。</li></ul><hr><h3 id="_7-cpu-竞争" tabindex="-1"><a class="header-anchor" href="#_7-cpu-竞争"><span>7. CPU 竞争</span></a></h3><p>在多核 CPU 的环境下，Redis 的多线程模型较为简单，主要依赖单线程来处理客户端请求。如果系统的 CPU 资源被其他进程大量占用，Redis 可能会出现 CPU 竞争，从而影响其响应时间，甚至发生阻塞。</p><h4 id="解决办法-6" tabindex="-1"><a class="header-anchor" href="#解决办法-6"><span>解决办法：</span></a></h4><ul><li>配置 Redis 使用多线程（在 Redis 6 及以上版本中可配置部分操作的多线程）。</li><li>优化其他进程的 CPU 使用，避免 Redis 被过多占用 CPU 资源。</li></ul><hr><h3 id="_8-网络问题" tabindex="-1"><a class="header-anchor" href="#_8-网络问题"><span>8. 网络问题</span></a></h3><p>网络延迟或带宽问题也可能导致 Redis 阻塞。例如，如果客户端与 Redis 实例之间的网络连接出现问题，客户端可能会一直等待请求响应，导致阻塞现象。</p><h4 id="解决办法-7" tabindex="-1"><a class="header-anchor" href="#解决办法-7"><span>解决办法：</span></a></h4><ul><li>监控 Redis 和客户端之间的网络连接，确保网络带宽和延迟满足需求。</li><li>对网络进行优化，减少丢包和延迟。</li></ul><hr>',56)],d={},r=(0,i(6262).A)(d,[["render",function(e,a){return(0,s.uX)(),(0,s.CE)("div",null,n)}]]),t=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/Redis%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0.html","title":"Redis 常见阻塞原因","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-12-01T00:00:00.000Z","category":["后端"],"tag":["Redis","数据库"],"description":"Redis 常见阻塞原因 Redis 是一个高性能的内存数据库，但在某些情况下，可能会出现性能瓶颈或阻塞现象，导致 Redis 无法响应请求，影响系统的整体性能。以下是 Redis 中常见的阻塞原因及其分析。 1. O(n) 命令 一些 Redis 命令的时间复杂度为 O(n)，即其执行时间与数据量成正比。对于大数据集，这些命令的执行可能会导致 Red...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/Redis%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"Redis 常见阻塞原因"}],["meta",{"property":"og:description","content":"Redis 常见阻塞原因 Redis 是一个高性能的内存数据库，但在某些情况下，可能会出现性能瓶颈或阻塞现象，导致 Redis 无法响应请求，影响系统的整体性能。以下是 Redis 中常见的阻塞原因及其分析。 1. O(n) 命令 一些 Redis 命令的时间复杂度为 O(n)，即其执行时间与数据量成正比。对于大数据集，这些命令的执行可能会导致 Red..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-12-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis 常见阻塞原因\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":3,"title":"1. O(n) 命令","slug":"_1-o-n-命令","link":"#_1-o-n-命令","children":[]},{"level":3,"title":"2. SAVE 创建 RDB 快照","slug":"_2-save-创建-rdb-快照","link":"#_2-save-创建-rdb-快照","children":[]},{"level":3,"title":"3. AOF（Append-Only File）相关阻塞","slug":"_3-aof-append-only-file-相关阻塞","link":"#_3-aof-append-only-file-相关阻塞","children":[]},{"level":3,"title":"4. 大 Key","slug":"_4-大-key","link":"#_4-大-key","children":[]},{"level":3,"title":"5. 集群扩容","slug":"_5-集群扩容","link":"#_5-集群扩容","children":[]},{"level":3,"title":"6. Swap（内存交换）","slug":"_6-swap-内存交换","link":"#_6-swap-内存交换","children":[]},{"level":3,"title":"7. CPU 竞争","slug":"_7-cpu-竞争","link":"#_7-cpu-竞争","children":[]},{"level":3,"title":"8. 网络问题","slug":"_8-网络问题","link":"#_8-网络问题","children":[]}],"git":{"createdTime":1733145681000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":5.2,"words":1559},"filePathRelative":"Java八股/数据库/Redis/重要知识点/Redis常见阻塞原因.md","localizedDate":"2024年12月1日","excerpt":"\\n<p>Redis 是一个高性能的内存数据库，但在某些情况下，可能会出现性能瓶颈或阻塞现象，导致 Redis 无法响应请求，影响系统的整体性能。以下是 Redis 中常见的阻塞原因及其分析。</p>\\n<hr>\\n<h3>1. O(n) 命令</h3>\\n<p>一些 Redis 命令的时间复杂度为 O(n)，即其执行时间与数据量成正比。对于大数据集，这些命令的执行可能会导致 Redis 被阻塞。常见的 O(n) 命令包括：</p>\\n<ul>\\n<li><strong><code>SORT</code></strong>：排序命令，如果排序的数据量很大，可能会导致 Redis 执行排序时阻塞。</li>\\n<li><strong><code>LRANGE</code></strong>：返回列表中某一范围内的元素，如果列表很长，执行此命令时 Redis 可能会卡住，直到所有数据返回。</li>\\n</ul>","autoDesc":true}')}}]);