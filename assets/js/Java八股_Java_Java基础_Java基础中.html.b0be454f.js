"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[1894],{66262:(e,n)=>{n.A=(e,n)=>{const r=e.__vccOpts||e;for(const[e,a]of n)r[e]=a;return r}},55051:(e,n,r)=>{r.r(n),r.d(n,{comp:()=>i,data:()=>o});var a=r(20641);const t=[(0,a.Fv)('<h1 id="java基础面试题中" tabindex="-1"><a class="header-anchor" href="#java基础面试题中"><span>Java基础面试题中</span></a></h1><hr><h1 id="java-面向对象基础" tabindex="-1"><a class="header-anchor" href="#java-面向对象基础"><span>Java 面向对象基础</span></a></h1><h2 id="_1-面向对象和面向过程的区别" tabindex="-1"><a class="header-anchor" href="#_1-面向对象和面向过程的区别"><span>1. 面向对象和面向过程的区别</span></a></h2><ul><li><strong>面向过程</strong>：注重流程，程序设计就是按步骤实现功能。每一步骤处理不同的任务，适合小型、功能简单的程序。</li><li><strong>面向对象</strong>：注重对象，将现实中的事物抽象为对象，通过对象来管理数据和功能。适合大型、复杂系统，因为面向对象有较好的扩展性和重用性。</li></ul><p><strong>例子</strong>：如果做一个家庭管理系统，面向过程可能是写一系列功能的代码，比如增加家庭成员、计算家庭总开销等。而面向对象会将家庭成员、支出等作为对象，每个对象有自己的属性和方法，更易维护和扩展。</p><h2 id="_2-创建一个对象用什么运算符" tabindex="-1"><a class="header-anchor" href="#_2-创建一个对象用什么运算符"><span>2. 创建一个对象用什么运算符？</span></a></h2><ul><li><strong>new 运算符</strong>：在 Java 中创建一个对象使用 <code>new</code> 运算符，它分配内存并调用构造方法来初始化对象。</li></ul><p><strong>例子</strong>：<code>Person person = new Person();</code> 在这里，<code>new</code> 用来创建一个 <code>Person</code> 对象。</p><h2 id="_3-对象实体与对象引用有何不同" tabindex="-1"><a class="header-anchor" href="#_3-对象实体与对象引用有何不同"><span>3. 对象实体与对象引用有何不同？</span></a></h2><ul><li><strong>对象实体</strong>：是实际的数据和方法的存储空间，即对象本身，保存在内存中。</li><li><strong>对象引用</strong>：是指向对象的一个变量，保存对象的地址。</li></ul><p><strong>例子</strong>：<code>Person person1 = new Person();</code> 创建了一个 <code>Person</code> 对象，并赋值给引用 <code>person1</code>。这里 <code>person1</code> 只是一个引用，它指向实际的 <code>Person</code> 实体。</p><h2 id="_4-对象的相等和引用相等的区别" tabindex="-1"><a class="header-anchor" href="#_4-对象的相等和引用相等的区别"><span>4. 对象的相等和引用相等的区别</span></a></h2><ul><li><strong>对象相等</strong>：用 <code>.equals()</code> 方法来比较两个对象的内容是否相等。</li><li><strong>引用相等</strong>：用 <code>==</code> 比较，判断两个引用是否指向同一个对象。</li></ul><p><strong>例子</strong>：<code>Person person1 = new Person(); Person person2 = person1;</code> 此时 <code>person1 == person2</code> 是 <code>true</code>，但如果两个对象内容相同而引用不同，<code>==</code> 可能为 <code>false</code>，<code>equals()</code> 可以判断它们的内容相等。</p><h2 id="_5-如果一个类没有声明构造方法-该程序能正确执行吗" tabindex="-1"><a class="header-anchor" href="#_5-如果一个类没有声明构造方法-该程序能正确执行吗"><span>5. 如果一个类没有声明构造方法，该程序能正确执行吗？</span></a></h2><ul><li>是的。如果没有声明构造方法，Java 会自动提供一个无参的<strong>默认构造方法</strong>，所以程序可以正常执行。</li></ul><h2 id="_6-构造方法有哪些特点-是否可被-override" tabindex="-1"><a class="header-anchor" href="#_6-构造方法有哪些特点-是否可被-override"><span>6. 构造方法有哪些特点？是否可被 <code>override</code>？</span></a></h2><ul><li><strong>特点</strong>：构造方法和类同名，没有返回值，用于创建和初始化对象。</li><li><strong>不可 <code>override</code></strong>：因为构造方法不能被继承，但可以<strong>重载</strong>（参数不同）。</li></ul><h2 id="_7-面向对象三大特征" tabindex="-1"><a class="header-anchor" href="#_7-面向对象三大特征"><span>7. 面向对象三大特征</span></a></h2><ul><li><strong>封装</strong>：将数据和方法封装在类中，控制对数据的访问，保证数据的安全性。</li><li><strong>继承</strong>：一个类可以继承另一个类的属性和方法，实现代码重用。</li><li><strong>多态</strong>：同一个方法在不同对象上表现出不同行为，可以通过重写和接口实现。</li></ul><p><strong>例子</strong>：家族中的长辈和后代可以看作一个继承关系，后代继承长辈的特征（属性和行为），并且在不同家庭成员上有多态表现。</p><h2 id="_8-接口和抽象类有什么共同点和区别" tabindex="-1"><a class="header-anchor" href="#_8-接口和抽象类有什么共同点和区别"><span>8. 接口和抽象类有什么共同点和区别？</span></a></h2><ul><li><strong>共同点</strong>：两者都可以声明抽象方法，不直接实现。</li><li><strong>区别</strong>： <ul><li>抽象类可以有构造方法和已实现的方法，接口只能有抽象方法（Java 8 开始允许默认方法）。</li><li>类可以实现多个接口，但只能继承一个抽象类。</li></ul></li></ul><p><strong>例子</strong>：接口就像是行为协议，比如“驾驶”行为，任何会驾驶的类都可以实现该接口；而抽象类更像是一种类型或基类，比如“车辆”。</p><h2 id="_9-深拷贝和浅拷贝区别了解吗-什么是引用拷贝" tabindex="-1"><a class="header-anchor" href="#_9-深拷贝和浅拷贝区别了解吗-什么是引用拷贝"><span>9. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></h2><ul><li><strong>浅拷贝</strong>：只复制对象的引用，修改副本会影响原对象。</li><li><strong>深拷贝</strong>：复制整个对象及其引用对象的内容，修改副本不影响原对象。</li><li><strong>引用拷贝</strong>：和浅拷贝类似，指的是只拷贝引用而非实际对象。</li></ul><p><strong>例子</strong>：如果是浅拷贝，两本书的书签指向同一页；而深拷贝相当于每本书各自独立，不会相互影响。</p><h2 id="_10-object-类的常见方法有哪些" tabindex="-1"><a class="header-anchor" href="#_10-object-类的常见方法有哪些"><span>10. <code>Object</code> 类的常见方法有哪些？</span></a></h2><ul><li><code>toString()</code>：返回对象的字符串表示。</li><li><code>equals(Object obj)</code>：判断两个对象内容是否相等。</li><li><code>hashCode()</code>：返回对象的哈希值。</li><li><code>clone()</code>：用于创建对象的副本。</li></ul><h2 id="_11-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#_11-和-equals-的区别"><span>11. <code>==</code> 和 <code>equals()</code> 的区别</span></a></h2><ul><li><strong><code>==</code></strong>：用于比较引用是否相等，即是否是同一个对象。</li><li><strong><code>equals()</code></strong>：用于比较对象的内容是否相等。</li></ul><h2 id="_12-hashcode-有什么用-为什么要有-hashcode" tabindex="-1"><a class="header-anchor" href="#_12-hashcode-有什么用-为什么要有-hashcode"><span>12. <code>hashCode()</code> 有什么用？为什么要有 <code>hashCode()</code>？</span></a></h2><ul><li><strong>作用</strong>：<code>hashCode()</code> 返回一个整数哈希值，用于对象在哈希表中的存储。</li><li><strong>重要性</strong>：保证相等的对象有相同的哈希值，以便正确存储在哈希结构中（如 <code>HashMap</code>）。</li></ul><h2 id="_13-为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_13-为什么重写-equals-时必须重写-hashcode-方法"><span>13. 为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？</span></a></h2><ul><li>如果两个对象通过 <code>equals()</code> 比较相等，它们的 <code>hashCode()</code> 也必须相等，保证在哈希表中正确工作。</li></ul><hr><h1 id="string-相关面试题" tabindex="-1"><a class="header-anchor" href="#string-相关面试题"><span>String 相关面试题</span></a></h1><h2 id="_1-string、stringbuffer、stringbuilder-的区别" tabindex="-1"><a class="header-anchor" href="#_1-string、stringbuffer、stringbuilder-的区别"><span>1. <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的区别？</span></a></h2><ul><li><strong>String</strong>：不可变，一旦创建就无法更改内容。适合小量字符串拼接。</li><li><strong>StringBuffer</strong>：可变，线程安全，适合多线程场景下的字符串修改。</li><li><strong>StringBuilder</strong>：可变，非线程安全，适合单线程场景的字符串修改，效率比 <code>StringBuffer</code> 高。</li></ul><h2 id="_2-string-为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#_2-string-为什么是不可变的"><span>2. <code>String</code> 为什么是不可变的？</span></a></h2><ul><li><strong>原因</strong>：为了安全和效率，<code>String</code> 不可变，可以在多个地方安全复用，不必担心其内容被修改。</li></ul><h2 id="_3-字符串拼接用-还是-stringbuilder" tabindex="-1"><a class="header-anchor" href="#_3-字符串拼接用-还是-stringbuilder"><span>3. 字符串拼接用“+” 还是 <code>StringBuilder</code>？</span></a></h2><ul><li>使用 <code>StringBuilder</code> 效率更高，因为每次拼接 <code>+</code> 都会生成新对象，<code>StringBuilder</code> 可以在原对象上操作。</li></ul><h2 id="_4-string-equals-和-object-equals-有何区别" tabindex="-1"><a class="header-anchor" href="#_4-string-equals-和-object-equals-有何区别"><span>4. <code>String#equals()</code> 和 <code>Object#equals()</code> 有何区别？</span></a></h2><ul><li><code>String#equals()</code> 比较的是字符串内容，而 <code>Object#equals()</code> 默认比较的是引用地址。</li></ul><h2 id="_5-字符串常量池的作用了解吗" tabindex="-1"><a class="header-anchor" href="#_5-字符串常量池的作用了解吗"><span>5. 字符串常量池的作用了解吗？</span></a></h2><ul><li><strong>作用</strong>：节省内存，存储所有相同的字符串字面量，避免重复创建。</li></ul><h2 id="_6-string-s1-new-string-abc-这句话创建了几个字符串对象" tabindex="-1"><a class="header-anchor" href="#_6-string-s1-new-string-abc-这句话创建了几个字符串对象"><span>6. <code>String s1 = new String(&quot;abc&quot;);</code> 这句话创建了几个字符串对象？</span></a></h2><ul><li>这段代码创建了 <strong>两个</strong> 字符串对象：一个在字符串池中（&quot;abc&quot;），一个在堆内存中（<code>new String(&quot;abc&quot;)</code>）。</li></ul><h2 id="_7-string-intern-方法有什么作用" tabindex="-1"><a class="header-anchor" href="#_7-string-intern-方法有什么作用"><span>7. <code>String#intern</code> 方法有什么作用？</span></a></h2><ul><li>将字符串放入常量池中，如果池中已存在相同字符串则返回池中的引用。</li></ul><h2 id="_8-string-类型的变量和常量做-运算时发生了什么" tabindex="-1"><a class="header-anchor" href="#_8-string-类型的变量和常量做-运算时发生了什么"><span>8. <code>String</code> 类型的变量和常量做“+”运算时发生了什么？</span></a></h2><ul><li>编译器会将常量拼接优化为一个字符串，而变量拼接则在运行时使用 <code>StringBuilder</code> 完成拼接。</li></ul><hr>',55)],l={},i=(0,r(66262).A)(l,[["render",function(e,n){return(0,a.uX)(),(0,a.CE)("div",null,t)}]]),o=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E4%B8%AD.html","title":"Java基础面试题中","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-10T00:00:00.000Z","category":["后端"],"tag":["Java","后端开发技巧"],"description":"Java基础面试题中 Java 面向对象基础 1. 面向对象和面向过程的区别 面向过程：注重流程，程序设计就是按步骤实现功能。每一步骤处理不同的任务，适合小型、功能简单的程序。 面向对象：注重对象，将现实中的事物抽象为对象，通过对象来管理数据和功能。适合大型、复杂系统，因为面向对象有较好的扩展性和重用性。 例子：如果做一个家庭管理系统，面向过程可能是写...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/Java/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80%E4%B8%AD.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"Java基础面试题中"}],["meta",{"property":"og:description","content":"Java基础面试题中 Java 面向对象基础 1. 面向对象和面向过程的区别 面向过程：注重流程，程序设计就是按步骤实现功能。每一步骤处理不同的任务，适合小型、功能简单的程序。 面向对象：注重对象，将现实中的事物抽象为对象，通过对象来管理数据和功能。适合大型、复杂系统，因为面向对象有较好的扩展性和重用性。 例子：如果做一个家庭管理系统，面向过程可能是写..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"后端开发技巧"}],["meta",{"property":"article:published_time","content":"2024-11-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础面试题中\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"1. 面向对象和面向过程的区别","slug":"_1-面向对象和面向过程的区别","link":"#_1-面向对象和面向过程的区别","children":[]},{"level":2,"title":"2. 创建一个对象用什么运算符？","slug":"_2-创建一个对象用什么运算符","link":"#_2-创建一个对象用什么运算符","children":[]},{"level":2,"title":"3. 对象实体与对象引用有何不同？","slug":"_3-对象实体与对象引用有何不同","link":"#_3-对象实体与对象引用有何不同","children":[]},{"level":2,"title":"4. 对象的相等和引用相等的区别","slug":"_4-对象的相等和引用相等的区别","link":"#_4-对象的相等和引用相等的区别","children":[]},{"level":2,"title":"5. 如果一个类没有声明构造方法，该程序能正确执行吗？","slug":"_5-如果一个类没有声明构造方法-该程序能正确执行吗","link":"#_5-如果一个类没有声明构造方法-该程序能正确执行吗","children":[]},{"level":2,"title":"6. 构造方法有哪些特点？是否可被 override？","slug":"_6-构造方法有哪些特点-是否可被-override","link":"#_6-构造方法有哪些特点-是否可被-override","children":[]},{"level":2,"title":"7. 面向对象三大特征","slug":"_7-面向对象三大特征","link":"#_7-面向对象三大特征","children":[]},{"level":2,"title":"8. 接口和抽象类有什么共同点和区别？","slug":"_8-接口和抽象类有什么共同点和区别","link":"#_8-接口和抽象类有什么共同点和区别","children":[]},{"level":2,"title":"9. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？","slug":"_9-深拷贝和浅拷贝区别了解吗-什么是引用拷贝","link":"#_9-深拷贝和浅拷贝区别了解吗-什么是引用拷贝","children":[]},{"level":2,"title":"10. Object 类的常见方法有哪些？","slug":"_10-object-类的常见方法有哪些","link":"#_10-object-类的常见方法有哪些","children":[]},{"level":2,"title":"11. == 和 equals() 的区别","slug":"_11-和-equals-的区别","link":"#_11-和-equals-的区别","children":[]},{"level":2,"title":"12. hashCode() 有什么用？为什么要有 hashCode()？","slug":"_12-hashcode-有什么用-为什么要有-hashcode","link":"#_12-hashcode-有什么用-为什么要有-hashcode","children":[]},{"level":2,"title":"13. 为什么重写 equals() 时必须重写 hashCode() 方法？","slug":"_13-为什么重写-equals-时必须重写-hashcode-方法","link":"#_13-为什么重写-equals-时必须重写-hashcode-方法","children":[]},{"level":2,"title":"1. String、StringBuffer、StringBuilder 的区别？","slug":"_1-string、stringbuffer、stringbuilder-的区别","link":"#_1-string、stringbuffer、stringbuilder-的区别","children":[]},{"level":2,"title":"2. String 为什么是不可变的？","slug":"_2-string-为什么是不可变的","link":"#_2-string-为什么是不可变的","children":[]},{"level":2,"title":"3. 字符串拼接用“+” 还是 StringBuilder？","slug":"_3-字符串拼接用-还是-stringbuilder","link":"#_3-字符串拼接用-还是-stringbuilder","children":[]},{"level":2,"title":"4. String#equals() 和 Object#equals() 有何区别？","slug":"_4-string-equals-和-object-equals-有何区别","link":"#_4-string-equals-和-object-equals-有何区别","children":[]},{"level":2,"title":"5. 字符串常量池的作用了解吗？","slug":"_5-字符串常量池的作用了解吗","link":"#_5-字符串常量池的作用了解吗","children":[]},{"level":2,"title":"6. String s1 = new String(\\"abc\\"); 这句话创建了几个字符串对象？","slug":"_6-string-s1-new-string-abc-这句话创建了几个字符串对象","link":"#_6-string-s1-new-string-abc-这句话创建了几个字符串对象","children":[]},{"level":2,"title":"7. String#intern 方法有什么作用？","slug":"_7-string-intern-方法有什么作用","link":"#_7-string-intern-方法有什么作用","children":[]},{"level":2,"title":"8. String 类型的变量和常量做“+”运算时发生了什么？","slug":"_8-string-类型的变量和常量做-运算时发生了什么","link":"#_8-string-类型的变量和常量做-运算时发生了什么","children":[]}],"git":{"createdTime":1732275083000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":5.48,"words":1644},"filePathRelative":"Java八股/Java/Java基础/Java基础中.md","localizedDate":"2024年11月10日","excerpt":"\\n<hr>\\n<h1>Java 面向对象基础</h1>\\n<h2>1. 面向对象和面向过程的区别</h2>\\n<ul>\\n<li><strong>面向过程</strong>：注重流程，程序设计就是按步骤实现功能。每一步骤处理不同的任务，适合小型、功能简单的程序。</li>\\n<li><strong>面向对象</strong>：注重对象，将现实中的事物抽象为对象，通过对象来管理数据和功能。适合大型、复杂系统，因为面向对象有较好的扩展性和重用性。</li>\\n</ul>\\n<p><strong>例子</strong>：如果做一个家庭管理系统，面向过程可能是写一系列功能的代码，比如增加家庭成员、计算家庭总开销等。而面向对象会将家庭成员、支出等作为对象，每个对象有自己的属性和方法，更易维护和扩展。</p>","autoDesc":true}')}}]);