"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[4261],{6262:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}},9600:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>s,data:()=>r});var i=t(641);const l=[(0,i.Fv)('<h1 id="🚀-从零开始教你设计一个消息队列系统-mq-通俗易懂、细节到位" tabindex="-1"><a class="header-anchor" href="#🚀-从零开始教你设计一个消息队列系统-mq-通俗易懂、细节到位"><span>🚀 从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位</span></a></h1><hr><h2 id="📌-什么是消息队列-一句话说清楚" tabindex="-1"><a class="header-anchor" href="#📌-什么是消息队列-一句话说清楚"><span>📌 什么是消息队列？一句话说清楚</span></a></h2><blockquote><p>消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。</p></blockquote><p>它负责把“消息”从发送方（生产者）<strong>传递</strong>到接收方（消费者）—— 而且还能：</p><ul><li>保证不会丢件（消息不丢失）✅</li><li>顺序到达（支持顺序消费）✅</li><li>如果收件人晚点来也没关系（异步解耦）✅</li></ul><h3 id="🧠-举个例子" tabindex="-1"><a class="header-anchor" href="#🧠-举个例子"><span>🧠 举个例子：</span></a></h3><p>淘宝订单支付成功后，会发生很多事：</p><ul><li>给你发短信</li><li>给仓库发发货请求</li><li>给商家发账单</li></ul><p>但你点完“支付”并不需要等这些操作都做完才能返回页面，这就靠了消息队列：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>支付系统 ——&gt; 发一条“支付成功”的消息 ——&gt; 各方系统慢慢接收处理</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="🎯-面试题-你来设计一个-mq-系统-该怎么说" tabindex="-1"><a class="header-anchor" href="#🎯-面试题-你来设计一个-mq-系统-该怎么说"><span>🎯 面试题：你来设计一个 MQ 系统，该怎么说？</span></a></h2><h3 id="一定要从这4个维度入手" tabindex="-1"><a class="header-anchor" href="#一定要从这4个维度入手"><span>一定要从这4个维度入手：</span></a></h3><table><thead><tr><th>设计模块</th><th>职责</th><th>你要考虑的点</th></tr></thead><tbody><tr><td>Producer</td><td>生产消息</td><td>发送是否成功？是否重复？</td></tr><tr><td>Broker</td><td>消息中转站</td><td>怎么存？能不能丢？顺序？</td></tr><tr><td>Consumer</td><td>消费者</td><td>怎么消费？是否重复？</td></tr><tr><td>Registry</td><td>注册中心</td><td>谁在哪？怎么发现彼此？</td></tr></tbody></table><hr><h2 id="📦-系统流程全图" tabindex="-1"><a class="header-anchor" href="#📦-系统流程全图"><span>📦 系统流程全图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[Producer] →→→ [Broker] →→→ [Consumer]</span></span>\n<span class="line"><span>                     ↑</span></span>\n<span class="line"><span>                [Registry]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="🧩-我们逐个拆开讲" tabindex="-1"><a class="header-anchor" href="#🧩-我们逐个拆开讲"><span>🧩 我们逐个拆开讲：</span></a></h2><hr><h2 id="🧑‍🍳-producer-怎么把消息送出去" tabindex="-1"><a class="header-anchor" href="#🧑‍🍳-producer-怎么把消息送出去"><span>🧑‍🍳 Producer：怎么把消息送出去？</span></a></h2><blockquote><p>它是消息的生产者，像做菜的一方。</p></blockquote><h3 id="📌-要实现的功能" tabindex="-1"><a class="header-anchor" href="#📌-要实现的功能"><span>📌 要实现的功能：</span></a></h3><ul><li>能把一条消息发送到 Broker</li><li>要知道消息有没有成功送达（ack）</li><li>要支持“重发但不重复”</li></ul><h3 id="✅-设计要点" tabindex="-1"><a class="header-anchor" href="#✅-设计要点"><span>✅ 设计要点：</span></a></h3><ul><li>使用 TCP（Netty） 建立连接</li><li>发完后等待 broker 返回 ACK</li><li>如果超时，自动重试（保证“最终送达”）</li></ul><hr><h2 id="🏢-broker-消息的中转站-核心" tabindex="-1"><a class="header-anchor" href="#🏢-broker-消息的中转站-核心"><span>🏢 Broker：消息的中转站（核心）</span></a></h2><blockquote><p>消息队列的“心脏”，设计重点全在这！</p></blockquote><h3 id="它要做-5-件事" tabindex="-1"><a class="header-anchor" href="#它要做-5-件事"><span>它要做 5 件事：</span></a></h3><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>接收消息</td><td>接收来自 Producer 的消息</td></tr><tr><td>缓存消息</td><td>先写入内存队列，快速暂存</td></tr><tr><td>持久化存储</td><td>写入磁盘，确保断电不丢</td></tr><tr><td>分发消息</td><td>把消息发送给消费者</td></tr><tr><td>管理消费进度</td><td>记录哪个消息被谁读了</td></tr></tbody></table><hr><h2 id="💾-消息存储设计-broker-里" tabindex="-1"><a class="header-anchor" href="#💾-消息存储设计-broker-里"><span>💾 消息存储设计（Broker 里）</span></a></h2><p>可以模仿 Kafka 的设计：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/store/</span></span>\n<span class="line"><span>  ├── topicA/</span></span>\n<span class="line"><span>  │     ├── log-0001.data</span></span>\n<span class="line"><span>  │     └── log-0002.data</span></span>\n<span class="line"><span>  └── topicB/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>所有消息顺序写入 <code>.data</code> 文件（类似日志）</li><li>每个 Topic 分区存储</li><li>内存队列做缓存（ConcurrentLinkedQueue）</li><li>定期 flush 到磁盘</li></ul><h3 id="为什么写磁盘也很快" tabindex="-1"><a class="header-anchor" href="#为什么写磁盘也很快"><span>为什么写磁盘也很快？</span></a></h3><blockquote><p>因为是<strong>顺序写</strong>，不像数据库那样随机插入！</p></blockquote><hr><h2 id="📤-consumer-谁来读消息-怎么控制" tabindex="-1"><a class="header-anchor" href="#📤-consumer-谁来读消息-怎么控制"><span>📤 Consumer：谁来读消息？怎么控制？</span></a></h2><blockquote><p>消息的“收件人”</p></blockquote><h3 id="📌-消费有两种方式" tabindex="-1"><a class="header-anchor" href="#📌-消费有两种方式"><span>📌 消费有两种方式：</span></a></h3><ul><li><strong>主动拉（pull）</strong>：消费者定时去拉</li><li><strong>被动推（push）</strong>：Broker 推给你</li></ul><h3 id="📌-消费状态要记录" tabindex="-1"><a class="header-anchor" href="#📌-消费状态要记录"><span>📌 消费状态要记录：</span></a></h3><ul><li>每个 Consumer Group 有一个 offset</li><li>每个 topic/partition 有唯一消费进度</li></ul><hr><h2 id="🧭-registry-大家在哪-怎么通信" tabindex="-1"><a class="header-anchor" href="#🧭-registry-大家在哪-怎么通信"><span>🧭 Registry：大家在哪？怎么通信？</span></a></h2><p>一个 MQ 系统不能硬编码 IP，需要<strong>服务发现机制</strong>：</p><table><thead><tr><th>服务</th><th>作用</th></tr></thead><tbody><tr><td>注册中心</td><td>每个 Producer / Broker / Consumer 启动时注册</td></tr><tr><td>心跳机制</td><td>保持“在线状态”</td></tr><tr><td>服务发现</td><td>Producer 可以拉到 Broker 列表</td></tr><tr><td>可选组件</td><td>Nacos / Zookeeper / Eureka / etcd</td></tr></tbody></table><hr><h2 id="🔐-协议设计-怎么打包发消息" tabindex="-1"><a class="header-anchor" href="#🔐-协议设计-怎么打包发消息"><span>🔐 协议设计（怎么打包发消息？）</span></a></h2><p>我们自定义一个简单协议结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| 魔数 | 版本 | 消息类型 | 数据长度 | 数据体 |</span></span>\n<span class="line"><span>  4B    1B      1B         4B       N 字节</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>类型：1=发送消息，2=拉取消息，3=ACK，4=心跳</li><li>数据体一般是 JSON 或 Protobuf 编码</li></ul><hr><h2 id="🧪-你必须考虑的系统问题" tabindex="-1"><a class="header-anchor" href="#🧪-你必须考虑的系统问题"><span>🧪 你必须考虑的系统问题：</span></a></h2><h3 id="✅-消息不能丢" tabindex="-1"><a class="header-anchor" href="#✅-消息不能丢"><span>✅ 消息不能丢</span></a></h3><ul><li>内存队列 + 日志文件双重写入</li><li>写成功后才 ack 给 producer</li></ul><h3 id="✅-消息不能重复消费" tabindex="-1"><a class="header-anchor" href="#✅-消息不能重复消费"><span>✅ 消息不能重复消费</span></a></h3><ul><li>使用唯一消息 ID 去重</li><li>offset 要持久化（存 Redis 或本地）</li></ul><h3 id="✅-支持顺序" tabindex="-1"><a class="header-anchor" href="#✅-支持顺序"><span>✅ 支持顺序</span></a></h3><ul><li>同一个 Topic 分多个 Partition</li><li>每个 Partition 保证消息有序</li></ul><h3 id="✅-多线程并发消费" tabindex="-1"><a class="header-anchor" href="#✅-多线程并发消费"><span>✅ 多线程并发消费</span></a></h3><ul><li>每个 Partition 一个消费线程，互不干扰</li></ul><hr><h2 id="💡-面试中这么答才有说服力" tabindex="-1"><a class="header-anchor" href="#💡-面试中这么答才有说服力"><span>💡 面试中这么答才有说服力：</span></a></h2><blockquote><p>我会把 MQ 拆成 Producer、Broker、Consumer、Registry 四个模块。Broker 是核心，负责缓存、存储、转发、ack、offset 管理等。网络通信基于 Netty，自定义协议传输。每条消息写入时写入内存队列和磁盘日志，保证高性能和可靠性。消费端拉取时使用 offset 管理，防止重复消费，同时支持按 Partition 顺序消费。服务发现通过注册中心实现系统扩展性和高可用。</p></blockquote><hr><h2 id="🧱-最小项目结构-你可以手撸个-demo" tabindex="-1"><a class="header-anchor" href="#🧱-最小项目结构-你可以手撸个-demo"><span>🧱 最小项目结构（你可以手撸个 demo）</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>my-mq/</span></span>\n<span class="line"><span>├── net/           ← Netty 网络通信</span></span>\n<span class="line"><span>├── store/         ← 消息落盘</span></span>\n<span class="line"><span>├── queue/         ← 内存队列</span></span>\n<span class="line"><span>├── broker/        ← 消息转发逻辑</span></span>\n<span class="line"><span>├── consumer/      ← 消费者客户端</span></span>\n<span class="line"><span>├── producer/      ← 生产者客户端</span></span>\n<span class="line"><span>└── registry/      ← 注册中心模拟</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="✅-总结" tabindex="-1"><a class="header-anchor" href="#✅-总结"><span>✅ 总结</span></a></h2><table><thead><tr><th>目标</th><th>设计要点</th></tr></thead><tbody><tr><td>不丢消息</td><td>写日志 + Ack 确认机制</td></tr><tr><td>不重复消费</td><td>offset + 去重 ID</td></tr><tr><td>支持高并发写入</td><td>内存队列 + 异步写磁盘</td></tr><tr><td>高可用</td><td>多 Broker + 注册中心发现</td></tr></tbody></table><hr>',75)],n={},s=(0,t(6262).A)(n,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,l)}]]),r=JSON.parse('{"path":"/tech/%E5%9C%BA%E6%99%AF/mq.html","title":"🚀 从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","category":["后端"],"tag":["Java","面试","场景"],"description":"🚀 从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位 📌 什么是消息队列？一句话说清楚 消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。 它负责把“消息”从发送方（生产者）传递到接收方（消费者）—— 而且还能： 保证不会丢件（消息不丢失）✅ 顺序到达（支持顺序消费）✅ 如果收件人晚点来也没关系（异步解耦）✅ ...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/tech/%E5%9C%BA%E6%99%AF/mq.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"🚀 从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位"}],["meta",{"property":"og:description","content":"🚀 从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位 📌 什么是消息队列？一句话说清楚 消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。 它负责把“消息”从发送方（生产者）传递到接收方（消费者）—— 而且还能： 保证不会丢件（消息不丢失）✅ 顺序到达（支持顺序消费）✅ 如果收件人晚点来也没关系（异步解耦）✅ ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-12T13:10:31.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"场景"}],["meta",{"property":"article:modified_time","content":"2025-07-12T13:10:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"🚀 从零开始教你设计一个消息队列系统（MQ）：通俗易懂、细节到位\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-12T13:10:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"📌 什么是消息队列？一句话说清楚","slug":"📌-什么是消息队列-一句话说清楚","link":"#📌-什么是消息队列-一句话说清楚","children":[{"level":3,"title":"🧠 举个例子：","slug":"🧠-举个例子","link":"#🧠-举个例子","children":[]}]},{"level":2,"title":"🎯 面试题：你来设计一个 MQ 系统，该怎么说？","slug":"🎯-面试题-你来设计一个-mq-系统-该怎么说","link":"#🎯-面试题-你来设计一个-mq-系统-该怎么说","children":[{"level":3,"title":"一定要从这4个维度入手：","slug":"一定要从这4个维度入手","link":"#一定要从这4个维度入手","children":[]}]},{"level":2,"title":"📦 系统流程全图","slug":"📦-系统流程全图","link":"#📦-系统流程全图","children":[]},{"level":2,"title":"🧩 我们逐个拆开讲：","slug":"🧩-我们逐个拆开讲","link":"#🧩-我们逐个拆开讲","children":[]},{"level":2,"title":"🧑‍🍳 Producer：怎么把消息送出去？","slug":"🧑‍🍳-producer-怎么把消息送出去","link":"#🧑‍🍳-producer-怎么把消息送出去","children":[{"level":3,"title":"📌 要实现的功能：","slug":"📌-要实现的功能","link":"#📌-要实现的功能","children":[]},{"level":3,"title":"✅ 设计要点：","slug":"✅-设计要点","link":"#✅-设计要点","children":[]}]},{"level":2,"title":"🏢 Broker：消息的中转站（核心）","slug":"🏢-broker-消息的中转站-核心","link":"#🏢-broker-消息的中转站-核心","children":[{"level":3,"title":"它要做 5 件事：","slug":"它要做-5-件事","link":"#它要做-5-件事","children":[]}]},{"level":2,"title":"💾 消息存储设计（Broker 里）","slug":"💾-消息存储设计-broker-里","link":"#💾-消息存储设计-broker-里","children":[{"level":3,"title":"为什么写磁盘也很快？","slug":"为什么写磁盘也很快","link":"#为什么写磁盘也很快","children":[]}]},{"level":2,"title":"📤 Consumer：谁来读消息？怎么控制？","slug":"📤-consumer-谁来读消息-怎么控制","link":"#📤-consumer-谁来读消息-怎么控制","children":[{"level":3,"title":"📌 消费有两种方式：","slug":"📌-消费有两种方式","link":"#📌-消费有两种方式","children":[]},{"level":3,"title":"📌 消费状态要记录：","slug":"📌-消费状态要记录","link":"#📌-消费状态要记录","children":[]}]},{"level":2,"title":"🧭 Registry：大家在哪？怎么通信？","slug":"🧭-registry-大家在哪-怎么通信","link":"#🧭-registry-大家在哪-怎么通信","children":[]},{"level":2,"title":"🔐 协议设计（怎么打包发消息？）","slug":"🔐-协议设计-怎么打包发消息","link":"#🔐-协议设计-怎么打包发消息","children":[]},{"level":2,"title":"🧪 你必须考虑的系统问题：","slug":"🧪-你必须考虑的系统问题","link":"#🧪-你必须考虑的系统问题","children":[{"level":3,"title":"✅ 消息不能丢","slug":"✅-消息不能丢","link":"#✅-消息不能丢","children":[]},{"level":3,"title":"✅ 消息不能重复消费","slug":"✅-消息不能重复消费","link":"#✅-消息不能重复消费","children":[]},{"level":3,"title":"✅ 支持顺序","slug":"✅-支持顺序","link":"#✅-支持顺序","children":[]},{"level":3,"title":"✅ 多线程并发消费","slug":"✅-多线程并发消费","link":"#✅-多线程并发消费","children":[]}]},{"level":2,"title":"💡 面试中这么答才有说服力：","slug":"💡-面试中这么答才有说服力","link":"#💡-面试中这么答才有说服力","children":[]},{"level":2,"title":"🧱 最小项目结构（你可以手撸个 demo）","slug":"🧱-最小项目结构-你可以手撸个-demo","link":"#🧱-最小项目结构-你可以手撸个-demo","children":[]},{"level":2,"title":"✅ 总结","slug":"✅-总结","link":"#✅-总结","children":[]}],"git":{"createdTime":1752325831000,"updatedTime":1752325831000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":4.01,"words":1203},"filePathRelative":"tech/场景/mq.md","localizedDate":"2025年7月12日","excerpt":"\\n<hr>\\n<h2>📌 什么是消息队列？一句话说清楚</h2>\\n<blockquote>\\n<p>消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。</p>\\n</blockquote>\\n<p>它负责把“消息”从发送方（生产者）<strong>传递</strong>到接收方（消费者）——\\n而且还能：</p>\\n<ul>\\n<li>保证不会丢件（消息不丢失）✅</li>\\n<li>顺序到达（支持顺序消费）✅</li>\\n<li>如果收件人晚点来也没关系（异步解耦）✅</li>\\n</ul>\\n<h3>🧠 举个例子：</h3>\\n<p>淘宝订单支付成功后，会发生很多事：</p>\\n<ul>\\n<li>给你发短信</li>\\n<li>给仓库发发货请求</li>\\n<li>给商家发账单</li>\\n</ul>","autoDesc":true}')}}]);