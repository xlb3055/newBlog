"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[2216],{66262:(t,l)=>{l.A=(t,l)=>{const e=t.__vccOpts||t;for(const[t,a]of l)e[t]=a;return e}},16295:(t,l,e)=>{e.r(l),e.d(l,{comp:()=>n,data:()=>d});var a=e(20641);const i=[(0,a.Fv)('<h1 id="消息队列到底该用推-push-还是拉-pull-一文吃透两种模式" tabindex="-1"><a class="header-anchor" href="#消息队列到底该用推-push-还是拉-pull-一文吃透两种模式"><span>消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！</span></a></h1><hr><h2 id="为什么这个问题很重要" tabindex="-1"><a class="header-anchor" href="#为什么这个问题很重要"><span>为什么这个问题很重要？</span></a></h2><p>面试官问这个问题，其实是想考我们两个核心能力：</p><ol><li><strong>对消息消费流程是否熟悉？</strong></li><li><strong>能否根据业务需求选择合适的方式？</strong></li></ol><p>但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。</p><p>本篇我们从 0 到 1，搞清楚以下问题：</p><ul><li>推模式 vs 拉模式到底差在哪？</li><li>各有什么优缺点？</li><li>哪些场景适合推？哪些适合拉？</li><li>Kafka、RabbitMQ 等主流 MQ 怎么选的？</li><li>实战中如何设计出一个可控的消费流程？</li></ul><hr><h2 id="类比理解-吃饭模式帮我们快速理解" tabindex="-1"><a class="header-anchor" href="#类比理解-吃饭模式帮我们快速理解"><span>类比理解：吃饭模式帮我们快速理解</span></a></h2><ul><li><strong>推模式（Push）</strong>：餐厅服务员把菜端到我们桌子上</li><li><strong>拉模式（Pull）</strong>：我们自己去自助餐取菜</li></ul><table><thead><tr><th>模式</th><th>谁主动？</th><th>控制节奏</th><th>容易超载？</th><th>实时性</th></tr></thead><tbody><tr><td>推（Push）</td><td>Broker</td><td>消费者无法控制</td><td>是</td><td>高</td></tr><tr><td>拉（Pull）</td><td>Consumer</td><td>自己控制</td><td>否</td><td>低（可调）</td></tr></tbody></table><hr><h2 id="什么是推模式-push-model" tabindex="-1"><a class="header-anchor" href="#什么是推模式-push-model"><span>什么是推模式（Push Model）？</span></a></h2><p>推模式中：</p><ul><li>Producer 把消息发给 Broker</li><li>Broker 立即主动将消息投递给 Consumer</li><li>Consumer 必须实现一个“接收回调接口”</li></ul><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点：</span></a></h3><ul><li><strong>实时性强</strong>：消息一到即发，适合秒级通知</li><li><strong>代码简单</strong>：消费者只需要订阅一次，不需要轮询</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h3><ul><li><strong>容易压垮消费者</strong>：Broker 不知道消费能力，一股脑推送</li><li><strong>难以限流</strong>：无法很好做 backpressure（回压）</li><li><strong>网络拥堵时会有丢失风险</strong></li></ul><h3 id="实际案例" tabindex="-1"><a class="header-anchor" href="#实际案例"><span>实际案例：</span></a></h3><ul><li>RabbitMQ 默认使用推模式，通过回调函数 <code>handleMessage()</code> 处理推过来的消息</li></ul><hr><h2 id="什么是拉模式-pull-model" tabindex="-1"><a class="header-anchor" href="#什么是拉模式-pull-model"><span>什么是拉模式（Pull Model）？</span></a></h2><p>拉模式中：</p><ul><li>Consumer 定期向 Broker 发起“拉取请求”</li><li>可以指定“拉多少条”“多久拉一次”</li></ul><h3 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1"><span>优点：</span></a></h3><ul><li><strong>可控节奏</strong>：消费者主动控制拉取频率，不会被压爆</li><li><strong>适合批量消费</strong>：每次拉 N 条统一处理，性能好</li><li><strong>更容易实现限流、失败重试</strong></li></ul><h3 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1"><span>缺点：</span></a></h3><ul><li><strong>可能有延迟</strong>：比如我们 1s 拉一次，那最多可能延迟 1 秒才收到消息</li><li><strong>实现复杂度稍高</strong>：需要维护拉取状态、偏移量等信息</li></ul><h3 id="实际案例-1" tabindex="-1"><a class="header-anchor" href="#实际案例-1"><span>实际案例：</span></a></h3><ul><li>Kafka、RocketMQ 都使用拉模式</li></ul><hr><h2 id="哪些场景选哪种模式" tabindex="-1"><a class="header-anchor" href="#哪些场景选哪种模式"><span>哪些场景选哪种模式？</span></a></h2><table><thead><tr><th>场景</th><th>推荐模式</th><th>理由</th></tr></thead><tbody><tr><td>秒级通知（发短信、推送）</td><td>推</td><td>实时性强</td></tr><tr><td>流量控制 / 复杂业务逻辑处理</td><td>拉</td><td>可控、稳定、易限流</td></tr><tr><td>批量处理 / 日志分析</td><td>拉</td><td>一次拉一批，高吞吐</td></tr><tr><td>用户事件监听（RabbitMQ）</td><td>推</td><td>回调机制简单，易上手</td></tr><tr><td>容灾处理 / 死信队列</td><td>拉</td><td>可自己管理消费偏移，更灵活</td></tr></tbody></table><hr><h2 id="主流-mq-的实际做法" tabindex="-1"><a class="header-anchor" href="#主流-mq-的实际做法"><span>主流 MQ 的实际做法</span></a></h2><table><thead><tr><th>MQ产品</th><th>消费方式</th><th>说明</th></tr></thead><tbody><tr><td>Kafka</td><td>拉</td><td><code>consumer.poll()</code> 主动拉取</td></tr><tr><td>RocketMQ</td><td>拉</td><td>客户端模拟 push，实为 poll 拉</td></tr><tr><td>RabbitMQ</td><td>推</td><td>消息直接推送到 Consumer 端回调</td></tr><tr><td>Redis Stream</td><td>拉 + 阻塞</td><td><code>XREAD BLOCK</code> 模拟监听效果</td></tr></tbody></table><hr><h2 id="实战设计-如何选型-如何限流" tabindex="-1"><a class="header-anchor" href="#实战设计-如何选型-如何限流"><span>实战设计：如何选型 + 如何限流？</span></a></h2><h3 id="如果我们要写一个-支付成功后发短信-模块" tabindex="-1"><a class="header-anchor" href="#如果我们要写一个-支付成功后发短信-模块"><span>如果我们要写一个“支付成功后发短信”模块：</span></a></h3><p><strong>推模式更合适</strong>：</p><ul><li>用户点击支付，立即需要短信提醒</li><li>用推模式回调接口处理即可，简洁高效</li></ul><h3 id="如果我们要写一个-退款批量审核-模块" tabindex="-1"><a class="header-anchor" href="#如果我们要写一个-退款批量审核-模块"><span>如果我们要写一个“退款批量审核”模块：</span></a></h3><p><strong>拉模式更合适</strong>：</p><ul><li>每小时审核一次退款订单</li><li>拉取 1000 条消息，批量入库</li></ul><hr><h2 id="推模式有哪些隐患-怎么优化" tabindex="-1"><a class="header-anchor" href="#推模式有哪些隐患-怎么优化"><span>推模式有哪些隐患？怎么优化？</span></a></h2><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>消费太慢，消息堆积</td><td>加入消费速率监控 + 死信队列</td></tr><tr><td>消息投递失败</td><td>增加 ACK &amp; 重试机制</td></tr><tr><td>消息堆积 OOM</td><td>增加临时缓冲区 + 分区处理 + 限流模块</td></tr></tbody></table><hr><h2 id="面试时怎么答更稳" tabindex="-1"><a class="header-anchor" href="#面试时怎么答更稳"><span>面试时怎么答更稳</span></a></h2><blockquote><p>消息队列可以使用推（Push）或拉（Pull）两种模式。 推适合实时性强的场景，比如支付通知，但对消费者压力大。拉适合批处理和控制节奏，比如日志处理。Kafka、RocketMQ 用拉模式方便控制节奏和偏移，RabbitMQ 推模式实现简单、适合监听型消费。 如果我们设计一个系统，我们更倾向使用“拉 + 限流 + ACK”这种更稳定的方式。</p></blockquote><hr><h2 id="总结一句话" tabindex="-1"><a class="header-anchor" href="#总结一句话"><span>总结一句话</span></a></h2><blockquote><p><strong>推模式更快，但难控；拉模式更稳，但复杂。</strong></p></blockquote><p>选择哪种模式不是绝对，要看我们业务“更在意实时性”还是“更在意稳定性”。</p><hr><h2 id="工程里的关键补充点" tabindex="-1"><a class="header-anchor" href="#工程里的关键补充点"><span>工程里的关键补充点</span></a></h2><h3 id="推模式的防护手段" tabindex="-1"><a class="header-anchor" href="#推模式的防护手段"><span>推模式的防护手段</span></a></h3><ul><li>消费者要支持限流与并发度控制</li><li>Broker 需要有重试与死信队列</li><li>回调处理要可重入，避免重复投递造成副作用</li></ul><h3 id="拉模式的调度策略" tabindex="-1"><a class="header-anchor" href="#拉模式的调度策略"><span>拉模式的调度策略</span></a></h3><ul><li>拉取批次大小与频率要根据业务耗时动态调整</li><li>允许阻塞拉取，降低空轮询消耗</li><li>拉不到消息时的退避策略要有上限</li></ul><h3 id="一致性与幂等" tabindex="-1"><a class="header-anchor" href="#一致性与幂等"><span>一致性与幂等</span></a></h3><ul><li>业务侧要有幂等键，避免重复消费带来的重复写</li><li>offset 提交要与业务处理成功绑定</li></ul><h3 id="监控与容量" tabindex="-1"><a class="header-anchor" href="#监控与容量"><span>监控与容量</span></a></h3><ul><li>监控堆积、消费延迟、失败率</li><li>峰值到来前要评估消费者扩容速度</li></ul><hr>',67)],r={},n=(0,e(66262).A)(r,[["render",function(t,l){return(0,a.uX)(),(0,a.CE)("div",null,i)}]]),d=JSON.parse('{"path":"/tech/%E5%9C%BA%E6%99%AF/mq%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F.html","title":"消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-12T00:00:00.000Z","category":["后端"],"tag":["Java","面试","场景"],"description":"消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！ 为什么这个问题很重要？ 面试官问这个问题，其实是想考我们两个核心能力： 对消息消费流程是否熟悉？ 能否根据业务需求选择合适的方式？ 但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。 本篇我们从 0 到 1，搞清楚以下问题...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/tech/%E5%9C%BA%E6%99%AF/mq%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！"}],["meta",{"property":"og:description","content":"消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！ 为什么这个问题很重要？ 面试官问这个问题，其实是想考我们两个核心能力： 对消息消费流程是否熟悉？ 能否根据业务需求选择合适的方式？ 但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。 本篇我们从 0 到 1，搞清楚以下问题..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-21T09:06:17.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"场景"}],["meta",{"property":"article:published_time","content":"2025-07-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-21T09:06:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-12T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-21T09:06:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"为什么这个问题很重要？","slug":"为什么这个问题很重要","link":"#为什么这个问题很重要","children":[]},{"level":2,"title":"类比理解：吃饭模式帮我们快速理解","slug":"类比理解-吃饭模式帮我们快速理解","link":"#类比理解-吃饭模式帮我们快速理解","children":[]},{"level":2,"title":"什么是推模式（Push Model）？","slug":"什么是推模式-push-model","link":"#什么是推模式-push-model","children":[{"level":3,"title":"优点：","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点：","slug":"缺点","link":"#缺点","children":[]},{"level":3,"title":"实际案例：","slug":"实际案例","link":"#实际案例","children":[]}]},{"level":2,"title":"什么是拉模式（Pull Model）？","slug":"什么是拉模式-pull-model","link":"#什么是拉模式-pull-model","children":[{"level":3,"title":"优点：","slug":"优点-1","link":"#优点-1","children":[]},{"level":3,"title":"缺点：","slug":"缺点-1","link":"#缺点-1","children":[]},{"level":3,"title":"实际案例：","slug":"实际案例-1","link":"#实际案例-1","children":[]}]},{"level":2,"title":"哪些场景选哪种模式？","slug":"哪些场景选哪种模式","link":"#哪些场景选哪种模式","children":[]},{"level":2,"title":"主流 MQ 的实际做法","slug":"主流-mq-的实际做法","link":"#主流-mq-的实际做法","children":[]},{"level":2,"title":"实战设计：如何选型 + 如何限流？","slug":"实战设计-如何选型-如何限流","link":"#实战设计-如何选型-如何限流","children":[{"level":3,"title":"如果我们要写一个“支付成功后发短信”模块：","slug":"如果我们要写一个-支付成功后发短信-模块","link":"#如果我们要写一个-支付成功后发短信-模块","children":[]},{"level":3,"title":"如果我们要写一个“退款批量审核”模块：","slug":"如果我们要写一个-退款批量审核-模块","link":"#如果我们要写一个-退款批量审核-模块","children":[]}]},{"level":2,"title":"推模式有哪些隐患？怎么优化？","slug":"推模式有哪些隐患-怎么优化","link":"#推模式有哪些隐患-怎么优化","children":[]},{"level":2,"title":"面试时怎么答更稳","slug":"面试时怎么答更稳","link":"#面试时怎么答更稳","children":[]},{"level":2,"title":"总结一句话","slug":"总结一句话","link":"#总结一句话","children":[]},{"level":2,"title":"工程里的关键补充点","slug":"工程里的关键补充点","link":"#工程里的关键补充点","children":[{"level":3,"title":"推模式的防护手段","slug":"推模式的防护手段","link":"#推模式的防护手段","children":[]},{"level":3,"title":"拉模式的调度策略","slug":"拉模式的调度策略","link":"#拉模式的调度策略","children":[]},{"level":3,"title":"一致性与幂等","slug":"一致性与幂等","link":"#一致性与幂等","children":[]},{"level":3,"title":"监控与容量","slug":"监控与容量","link":"#监控与容量","children":[]}]}],"git":{"createdTime":1752325831000,"updatedTime":1768986377000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":3}]},"readingTime":{"minutes":4.36,"words":1308},"filePathRelative":"tech/场景/mq消费方式.md","localizedDate":"2025年7月12日","excerpt":"\\n<hr>\\n<h2>为什么这个问题很重要？</h2>\\n<p>面试官问这个问题，其实是想考我们两个核心能力：</p>\\n<ol>\\n<li><strong>对消息消费流程是否熟悉？</strong></li>\\n<li><strong>能否根据业务需求选择合适的方式？</strong></li>\\n</ol>\\n<p>但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。</p>\\n<p>本篇我们从 0 到 1，搞清楚以下问题：</p>\\n<ul>\\n<li>推模式 vs 拉模式到底差在哪？</li>\\n<li>各有什么优缺点？</li>\\n<li>哪些场景适合推？哪些适合拉？</li>\\n<li>Kafka、RabbitMQ 等主流 MQ 怎么选的？</li>\\n<li>实战中如何设计出一个可控的消费流程？</li>\\n</ul>","autoDesc":true}')}}]);