"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[7972],{66262:(e,a)=>{a.A=(e,a)=>{const t=e.__vccOpts||e;for(const[e,l]of a)t[e]=l;return t}},15959:(e,a,t)=>{t.r(a),t.d(a,{comp:()=>i,data:()=>r});var l=t(20641);const n=[(0,l.Fv)('<h1 id="java并发面试题上" tabindex="-1"><a class="header-anchor" href="#java并发面试题上"><span>Java并发面试题上</span></a></h1><h3 id="_1-什么是线程和进程" tabindex="-1"><a class="header-anchor" href="#_1-什么是线程和进程"><span>1. 什么是线程和进程？</span></a></h3><ul><li><strong>进程</strong> 是程序的执行实例，具有独立的地址空间和资源。每个进程之间相互隔离，操作系统为每个进程分配独立的内存和资源。</li><li><strong>线程</strong> 是进程中的最小执行单位，多个线程共享进程的内存和资源，因此它们比进程更轻量。线程在同一进程中执行并共享数据。</li></ul><p><strong>区别</strong>:</p><ul><li>进程有独立的内存空间，而线程共享进程的内存。</li><li>线程创建和销毁的开销比进程小。</li><li>线程间的通信比进程间通信更高效。</li></ul><h3 id="_2-java-线程与操作系统线程的区别" tabindex="-1"><a class="header-anchor" href="#_2-java-线程与操作系统线程的区别"><span>2. Java 线程与操作系统线程的区别？</span></a></h3><p>Java 线程是操作系统线程的一个抽象，在 Java 中创建的线程实际是操作系统的线程的封装。Java 提供了线程管理的 API，如 <code>Thread</code> 和 <code>Runnable</code>，而底层的线程调度和管理由操作系统内核处理。</p><h3 id="_3-线程的生命周期和状态" tabindex="-1"><a class="header-anchor" href="#_3-线程的生命周期和状态"><span>3. 线程的生命周期和状态？</span></a></h3><p>线程的生命周期包括：</p><ul><li><strong>新建（New）</strong>：线程对象被创建，但未开始执行。</li><li><strong>就绪（Runnable）</strong>：线程准备好执行，等待 CPU 调度。</li><li><strong>运行（Running）</strong>：线程分配 CPU 时间片并开始执行。</li><li><strong>阻塞（Blocked）</strong>：线程因为等待资源（如文件操作、锁等）而阻塞。</li><li><strong>等待（Waiting）</strong>：线程主动等待某些条件（如 <code>wait()</code>）。</li><li><strong>超时等待（Timed Waiting）</strong>：线程等待指定时间。</li><li><strong>终止（Terminated）</strong>：线程执行结束或因异常终止。</li></ul><h3 id="_4-线程上下文切换是什么" tabindex="-1"><a class="header-anchor" href="#_4-线程上下文切换是什么"><span>4. 线程上下文切换是什么？</span></a></h3><p><strong>上下文切换</strong>是操作系统在不同线程之间切换时保存当前线程的状态，并恢复下一个线程状态的过程。涉及保存寄存器、程序计数器等信息，切换后，CPU 将继续执行新线程的任务。</p><h3 id="_5-thread-sleep-和-object-wait-方法对比" tabindex="-1"><a class="header-anchor" href="#_5-thread-sleep-和-object-wait-方法对比"><span>5. Thread#sleep() 和 Object#wait() 方法对比？</span></a></h3><ul><li><strong>Thread.sleep(long millis)</strong>：使当前线程进入休眠状态，暂停指定时间，期间不释放锁。</li><li><strong>Object.wait()</strong>：让当前线程等待，并释放持有的锁，直到被其他线程通过 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒。</li></ul><p><code>wait()</code> 不是定义在 <code>Thread</code> 类中，而是定义在 <code>Object</code> 类中，因为它是所有对象的公共方法（所有对象都可以作为锁使用）。</p><h3 id="_6-可以直接调用-thread-类的-run-方法吗" tabindex="-1"><a class="header-anchor" href="#_6-可以直接调用-thread-类的-run-方法吗"><span>6. 可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法吗？</span></a></h3><p>可以，但不建议。调用 <code>run()</code> 方法并不会启动新线程，而是直接在当前线程中执行 <code>run()</code> 方法。若想启动新线程，应该使用 <code>start()</code> 方法，它会触发线程的生命周期，并由操作系统调度。</p><h3 id="_7-多线程并发与并行的区别" tabindex="-1"><a class="header-anchor" href="#_7-多线程并发与并行的区别"><span>7. 多线程并发与并行的区别？</span></a></h3><ul><li><strong>并发（Concurrency）</strong>：多个线程交替执行，操作系统在单核 CPU 上通过上下文切换实现并发执行。</li><li><strong>并行（Parallelism）</strong>：多个线程同时执行，在多核 CPU 上，多个线程可以真正并行运行。</li></ul><h3 id="_8-如何创建线程" tabindex="-1"><a class="header-anchor" href="#_8-如何创建线程"><span>8. 如何创建线程？</span></a></h3><p>在 Java 中，线程可以通过两种方式创建：</p><ol><li><strong>继承 <code>Thread</code> 类</strong>：创建一个子类，重写 <code>run()</code> 方法，并调用 <code>start()</code> 启动线程。</li><li><strong>实现 <code>Runnable</code> 接口</strong>：实现 <code>Runnable</code> 接口的 <code>run()</code> 方法，创建 <code>Thread</code> 对象并调用 <code>start()</code>。</li></ol><h3 id="_9-为什么要使用多线程" tabindex="-1"><a class="header-anchor" href="#_9-为什么要使用多线程"><span>9. 为什么要使用多线程？</span></a></h3><ul><li>提高程序效率，尤其是 I/O 密集型或计算密集型任务可以并行处理。</li><li>提供更好的响应性，UI 线程可以处理用户输入，后台线程处理任务。</li><li>利用多核 CPU 实现并行处理。</li></ul><h3 id="_10-死锁是什么-如何避免" tabindex="-1"><a class="header-anchor" href="#_10-死锁是什么-如何避免"><span>10. 死锁是什么，如何避免？</span></a></h3><p><strong>死锁</strong>是两个或多个线程互相等待对方释放资源，导致程序无法继续执行。常见的死锁条件包括：</p><ul><li>互斥：至少一个资源必须处于互斥状态。</li><li>占有并等待：一个线程已经持有一个资源并等待其他资源。</li><li>不可抢占：线程持有的资源不能被强制释放。</li><li>循环等待：多个线程形成环形等待。</li></ul><p><strong>避免死锁</strong>：</p><ul><li>尽量避免嵌套锁，按统一的顺序请求锁。</li><li>使用超时机制（如 <code>tryLock</code>）避免无限等待。</li><li>使用 <code>Lock</code> 接口（如 <code>ReentrantLock</code>）而非 <code>synchronized</code>，因其可以设置公平锁和尝试锁。</li></ul><h3 id="_11-java线程池的作用" tabindex="-1"><a class="header-anchor" href="#_11-java线程池的作用"><span>11. Java线程池的作用？</span></a></h3><p>线程池是管理和复用线程的机制，它避免了频繁创建和销毁线程的开销。Java 提供了 <code>Executor</code> 框架来实现线程池，如 <code>Executors.newFixedThreadPool()</code>。</p><h3 id="_12-java-线程安全的实现方式" tabindex="-1"><a class="header-anchor" href="#_12-java-线程安全的实现方式"><span>12. Java 线程安全的实现方式？</span></a></h3><ul><li>使用 <code>synchronized</code> 关键字：对临界区代码块进行同步，保证同一时刻只有一个线程执行。</li><li>使用 <code>Lock</code> 接口：显式地获取和释放锁，比 <code>synchronized</code> 提供了更细粒度的控制。</li><li>使用 <code>Concurrent</code> 包中的类：如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等，提供高效的线程安全操作。</li></ul>',33)],o={},i=(0,t(66262).A)(o,[["render",function(e,a){return(0,l.uX)(),(0,l.CE)("div",null,n)}]]),r=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/Java/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A.html","title":"Java并发面试题上","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-14T00:00:00.000Z","category":["后端"],"tag":["Java","并发","后端开发技巧"],"description":"Java并发面试题上 1. 什么是线程和进程？ 进程 是程序的执行实例，具有独立的地址空间和资源。每个进程之间相互隔离，操作系统为每个进程分配独立的内存和资源。 线程 是进程中的最小执行单位，多个线程共享进程的内存和资源，因此它们比进程更轻量。线程在同一进程中执行并共享数据。 区别: 进程有独立的内存空间，而线程共享进程的内存。 线程创建和销毁的开销比...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/Java/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"Java并发面试题上"}],["meta",{"property":"og:description","content":"Java并发面试题上 1. 什么是线程和进程？ 进程 是程序的执行实例，具有独立的地址空间和资源。每个进程之间相互隔离，操作系统为每个进程分配独立的内存和资源。 线程 是进程中的最小执行单位，多个线程共享进程的内存和资源，因此它们比进程更轻量。线程在同一进程中执行并共享数据。 区别: 进程有独立的内存空间，而线程共享进程的内存。 线程创建和销毁的开销比..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"后端开发技巧"}],["meta",{"property":"article:published_time","content":"2024-11-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java并发面试题上\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-14T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":3,"title":"1. 什么是线程和进程？","slug":"_1-什么是线程和进程","link":"#_1-什么是线程和进程","children":[]},{"level":3,"title":"2. Java 线程与操作系统线程的区别？","slug":"_2-java-线程与操作系统线程的区别","link":"#_2-java-线程与操作系统线程的区别","children":[]},{"level":3,"title":"3. 线程的生命周期和状态？","slug":"_3-线程的生命周期和状态","link":"#_3-线程的生命周期和状态","children":[]},{"level":3,"title":"4. 线程上下文切换是什么？","slug":"_4-线程上下文切换是什么","link":"#_4-线程上下文切换是什么","children":[]},{"level":3,"title":"5. Thread#sleep() 和 Object#wait() 方法对比？","slug":"_5-thread-sleep-和-object-wait-方法对比","link":"#_5-thread-sleep-和-object-wait-方法对比","children":[]},{"level":3,"title":"6. 可以直接调用 Thread 类的 run() 方法吗？","slug":"_6-可以直接调用-thread-类的-run-方法吗","link":"#_6-可以直接调用-thread-类的-run-方法吗","children":[]},{"level":3,"title":"7. 多线程并发与并行的区别？","slug":"_7-多线程并发与并行的区别","link":"#_7-多线程并发与并行的区别","children":[]},{"level":3,"title":"8. 如何创建线程？","slug":"_8-如何创建线程","link":"#_8-如何创建线程","children":[]},{"level":3,"title":"9. 为什么要使用多线程？","slug":"_9-为什么要使用多线程","link":"#_9-为什么要使用多线程","children":[]},{"level":3,"title":"10. 死锁是什么，如何避免？","slug":"_10-死锁是什么-如何避免","link":"#_10-死锁是什么-如何避免","children":[]},{"level":3,"title":"11. Java线程池的作用？","slug":"_11-java线程池的作用","link":"#_11-java线程池的作用","children":[]},{"level":3,"title":"12. Java 线程安全的实现方式？","slug":"_12-java-线程安全的实现方式","link":"#_12-java-线程安全的实现方式","children":[]}],"git":{"createdTime":1732275083000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":4.06,"words":1217},"filePathRelative":"Java八股/Java/Java并发/Java并发面试题上.md","localizedDate":"2024年11月14日","excerpt":"\\n<h3>1. 什么是线程和进程？</h3>\\n<ul>\\n<li><strong>进程</strong> 是程序的执行实例，具有独立的地址空间和资源。每个进程之间相互隔离，操作系统为每个进程分配独立的内存和资源。</li>\\n<li><strong>线程</strong> 是进程中的最小执行单位，多个线程共享进程的内存和资源，因此它们比进程更轻量。线程在同一进程中执行并共享数据。</li>\\n</ul>\\n<p><strong>区别</strong>:</p>\\n<ul>\\n<li>进程有独立的内存空间，而线程共享进程的内存。</li>\\n<li>线程创建和销毁的开销比进程小。</li>\\n<li>线程间的通信比进程间通信更高效。</li>\\n</ul>","autoDesc":true}')}}]);