"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[1261],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},1702:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>t,data:()=>h});var n=a(641);const e=[(0,n.Fv)('<h1 id="java并发面试题中" tabindex="-1"><a class="header-anchor" href="#java并发面试题中"><span>Java并发面试题中</span></a></h1><hr><h3 id="_1-jmm-java-内存模型" tabindex="-1"><a class="header-anchor" href="#_1-jmm-java-内存模型"><span>1. <strong>JMM (Java 内存模型)</strong></span></a></h3><h4 id="_1-1-jmm-的作用" tabindex="-1"><a class="header-anchor" href="#_1-1-jmm-的作用"><span>1.1 JMM 的作用</span></a></h4><p>JMM 是 Java 虚拟机定义的一套内存模型规范，用于屏蔽不同硬件和操作系统的内存访问差异，保证 Java 并发程序的可见性、原子性和有序性。</p><h4 id="_1-2-关键概念" tabindex="-1"><a class="header-anchor" href="#_1-2-关键概念"><span>1.2 关键概念</span></a></h4><ul><li><strong>主内存</strong>：所有线程共享的内存，所有变量都存储在主内存中。</li><li><strong>工作内存</strong>：每个线程有独立的工作内存，用于存储主内存中变量的副本。</li></ul><h4 id="_1-3-jmm-的三个核心特性" tabindex="-1"><a class="header-anchor" href="#_1-3-jmm-的三个核心特性"><span>1.3 JMM 的三个核心特性</span></a></h4><ul><li><strong>原子性</strong>：操作不可被中断，如 <code>volatile</code> 修饰的读取操作和 <code>synchronized</code> 块的操作具有原子性。</li><li><strong>可见性</strong>：一个线程修改了共享变量，其他线程可以立即看到，<code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 关键字可以保证可见性。</li><li><strong>有序性</strong>：Java 提供了“程序顺序规则”，即单线程中代码的执行顺序看起来是顺序的，<code>volatile</code> 和 <code>synchronized</code> 可以防止指令重排序。</li></ul><hr><h3 id="_2-volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_2-volatile-关键字"><span>2. <strong>volatile 关键字</strong></span></a></h3><h4 id="_2-1-volatile-的作用" tabindex="-1"><a class="header-anchor" href="#_2-1-volatile-的作用"><span>2.1 volatile 的作用</span></a></h4><ul><li><strong>可见性</strong>：一个线程对 <code>volatile</code> 变量的修改，其他线程立即可见。</li><li><strong>禁止指令重排序</strong>：使用 <code>volatile</code> 会在底层加入内存屏障，避免指令重排序。</li></ul><h4 id="_2-2-volatile-的局限" tabindex="-1"><a class="header-anchor" href="#_2-2-volatile-的局限"><span>2.2 volatile 的局限</span></a></h4><ul><li><strong>不保证原子性</strong>：<code>volatile</code> 无法保证复合操作（如 <code>x++</code>）的原子性，需要使用 <code>synchronized</code> 或原子类。</li></ul><h4 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码"><span>示例代码：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updateFlag</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    flag </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 修改后其他线程立即可见</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> checkFlag</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (flag) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // busy-waiting</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_3-乐观锁和悲观锁"><span>3. <strong>乐观锁和悲观锁</strong></span></a></h3><h4 id="_3-1-悲观锁" tabindex="-1"><a class="header-anchor" href="#_3-1-悲观锁"><span>3.1 悲观锁</span></a></h4><p>假设操作会产生冲突，采取加锁的方式防止冲突。典型实现是 <code>synchronized</code> 和 <code>ReentrantLock</code>。</p><h4 id="_3-2-乐观锁" tabindex="-1"><a class="header-anchor" href="#_3-2-乐观锁"><span>3.2 乐观锁</span></a></h4><p>假设冲突较少，通过 CAS（Compare-And-Swap）机制检测冲突，仅在冲突时重试。</p><h4 id="_3-3-乐观锁的实现" tabindex="-1"><a class="header-anchor" href="#_3-3-乐观锁的实现"><span>3.3 乐观锁的实现</span></a></h4><p>Java 中 <code>Atomic</code> 类通过 CAS 实现乐观锁，底层依赖于硬件支持的原子指令。</p><h4 id="cas-存在的问题" tabindex="-1"><a class="header-anchor" href="#cas-存在的问题"><span>CAS 存在的问题</span></a></h4><ol><li>ABA 问题：值变更后又变回原值会被误判为未修改。 <ul><li>解决：使用 <code>AtomicStampedReference</code>。</li></ul></li><li>自旋开销：CAS 操作在竞争激烈时可能导致较高的 CPU 开销。</li><li>无法保证代码块的原子性。</li></ol><hr><h3 id="_4-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_4-synchronized-关键字"><span>4. <strong>synchronized 关键字</strong></span></a></h3><h4 id="_4-1-synchronized-的作用" tabindex="-1"><a class="header-anchor" href="#_4-1-synchronized-的作用"><span>4.1 synchronized 的作用</span></a></h4><ol><li><strong>保证原子性</strong>：对代码块加锁，确保同一时刻只有一个线程执行。</li><li><strong>保证可见性</strong>：线程释放锁前，修改的变量会被刷新到主内存。</li><li><strong>保证有序性</strong>：禁止指令重排序。</li></ol><h4 id="_4-2-使用方法" tabindex="-1"><a class="header-anchor" href="#_4-2-使用方法"><span>4.2 使用方法</span></a></h4><ul><li>修饰代码块：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">synchronized</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 临界区</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>修饰方法：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> method</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 临界区</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>修饰静态方法：<div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> synchronized</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> staticMethod</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 临界区</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="_4-3-构造方法是否可用-synchronized-修饰" tabindex="-1"><a class="header-anchor" href="#_4-3-构造方法是否可用-synchronized-修饰"><span>4.3 构造方法是否可用 synchronized 修饰？</span></a></h4><p>构造方法不能直接使用 <code>synchronized</code> 修饰，但可以通过同步代码块实现。</p><h4 id="_4-4-synchronized-底层原理" tabindex="-1"><a class="header-anchor" href="#_4-4-synchronized-底层原理"><span>4.4 synchronized 底层原理</span></a></h4><ul><li>使用对象头中的 <strong>Mark Word</strong> 实现锁状态标记。</li><li>锁的状态： <ol><li><strong>无锁</strong>：默认状态。</li><li><strong>偏向锁</strong>：无竞争时，线程持有偏向锁。</li><li><strong>轻量级锁</strong>：竞争开始时，线程尝试 CAS 获取锁。</li><li><strong>重量级锁</strong>：竞争激烈时，升级为重量级锁（操作系统层面的互斥锁）。</li></ol></li></ul><h4 id="_4-5-jdk1-6-之后的优化" tabindex="-1"><a class="header-anchor" href="#_4-5-jdk1-6-之后的优化"><span>4.5 JDK1.6 之后的优化</span></a></h4><ol><li><strong>偏向锁</strong>：无竞争时，减少锁操作开销。</li><li><strong>轻量级锁</strong>：通过自旋避免线程切换。</li><li><strong>锁消除</strong>：JIT 编译器会优化掉不必要的锁。</li><li><strong>锁粗化</strong>：合并多次连续的加锁操作。</li></ol><hr><h3 id="_5-reentrantlock" tabindex="-1"><a class="header-anchor" href="#_5-reentrantlock"><span>5. <strong>ReentrantLock</strong></span></a></h3><h4 id="_5-1-reentrantlock-的作用" tabindex="-1"><a class="header-anchor" href="#_5-1-reentrantlock-的作用"><span>5.1 ReentrantLock 的作用</span></a></h4><ol><li>提供更灵活的加锁机制（如公平锁、非公平锁）。</li><li>支持可中断锁。</li></ol><h4 id="_5-2-公平锁和非公平锁" tabindex="-1"><a class="header-anchor" href="#_5-2-公平锁和非公平锁"><span>5.2 公平锁和非公平锁</span></a></h4><ul><li><strong>公平锁</strong>：线程按照请求锁的顺序获取锁。</li><li><strong>非公平锁</strong>：线程可直接插队，可能导致优先获取锁。</li></ul><h4 id="_5-3-synchronized-和-reentrantlock-的区别" tabindex="-1"><a class="header-anchor" href="#_5-3-synchronized-和-reentrantlock-的区别"><span>5.3 synchronized 和 ReentrantLock 的区别</span></a></h4><ul><li><strong>功能</strong>： <ul><li><code>synchronized</code> 是 JVM 提供的关键字，支持锁升级。</li><li><code>ReentrantLock</code> 是 Java 类库中的实现，提供更多高级特性。</li></ul></li><li><strong>性能</strong>： <ul><li>低竞争下，<code>synchronized</code> 更快。</li><li>高竞争下，<code>ReentrantLock</code> 提供的功能更灵活。</li></ul></li><li><strong>功能特性</strong>： <ul><li><code>ReentrantLock</code> 支持公平锁、非公平锁、可中断锁等特性。</li></ul></li></ul><hr><h3 id="_6-reentrantreadwritelock" tabindex="-1"><a class="header-anchor" href="#_6-reentrantreadwritelock"><span>6. <strong>ReentrantReadWriteLock</strong></span></a></h3><h4 id="_6-1-reentrantreadwritelock-的作用" tabindex="-1"><a class="header-anchor" href="#_6-1-reentrantreadwritelock-的作用"><span>6.1 ReentrantReadWriteLock 的作用</span></a></h4><p>提供读写分离锁：</p><ul><li><strong>读锁（共享锁）</strong>：多个线程可以同时持有读锁。</li><li><strong>写锁（独占锁）</strong>：同一时刻只有一个线程能持有写锁。</li></ul><h4 id="_6-2-场景" tabindex="-1"><a class="header-anchor" href="#_6-2-场景"><span>6.2 场景</span></a></h4><p>适用于读多写少的场景。</p><h4 id="_6-3-线程持有读锁还能获取写锁吗" tabindex="-1"><a class="header-anchor" href="#_6-3-线程持有读锁还能获取写锁吗"><span>6.3 线程持有读锁还能获取写锁吗？</span></a></h4><p>不能。持有读锁时，写锁会被阻塞。</p><h4 id="_6-4-为什么读锁不能升级为写锁" tabindex="-1"><a class="header-anchor" href="#_6-4-为什么读锁不能升级为写锁"><span>6.4 为什么读锁不能升级为写锁？</span></a></h4><p>如果允许升级，可能会导致死锁。例如，一个线程持有读锁，等待写锁时，其他线程也无法释放读锁。</p><hr><h3 id="_7-stampedlock" tabindex="-1"><a class="header-anchor" href="#_7-stampedlock"><span>7. <strong>StampedLock</strong></span></a></h3><h4 id="_7-1-stampedlock-是什么" tabindex="-1"><a class="header-anchor" href="#_7-1-stampedlock-是什么"><span>7.1 StampedLock 是什么？</span></a></h4><p><code>StampedLock</code> 是 Java 8 引入的一种锁实现，提供比 <code>ReentrantReadWriteLock</code> 更高的性能。</p><h4 id="_7-2-性能优势" tabindex="-1"><a class="header-anchor" href="#_7-2-性能优势"><span>7.2 性能优势</span></a></h4><p>通过 <strong>乐观读锁</strong> 提升读取性能：</p><ul><li>如果没有写操作，乐观读锁允许线程直接访问数据。</li><li>如果检测到写操作，升级为悲观读锁。</li></ul><h4 id="示例代码-1" tabindex="-1"><a class="header-anchor" href="#示例代码-1"><span>示例代码：</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">StampedLock</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> lock </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> StampedLock</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> stamp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">tryOptimisticRead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">validate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(stamp)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 乐观读成功</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">} </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    stamp </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readLock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 进行悲观读</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">finally</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        lock</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">unlockRead</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(stamp);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_8-atomic-原子类" tabindex="-1"><a class="header-anchor" href="#_8-atomic-原子类"><span>8. <strong>Atomic 原子类</strong></span></a></h3><h4 id="_8-1-atomic-原子类的作用" tabindex="-1"><a class="header-anchor" href="#_8-1-atomic-原子类的作用"><span>8.1 Atomic 原子类的作用</span></a></h4><p>提供了一组基于 CAS 实现的线程安全操作类，主要包括：</p><ul><li><code>AtomicInteger</code></li><li><code>AtomicLong</code></li><li><code>AtomicReference</code></li></ul><h4 id="_8-2-常见方法" tabindex="-1"><a class="header-anchor" href="#_8-2-常见方法"><span>8.2 常见方法</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">AtomicInteger</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> atomicInteger </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> AtomicInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">atomicInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">incrementAndGet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 原子递增</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">atomicInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">compareAndSet</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // CAS 操作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_8-3-优缺点" tabindex="-1"><a class="header-anchor" href="#_8-3-优缺点"><span>8.3 优缺点</span></a></h4><ul><li>优点：比锁更高效，适用于高并发场景。</li><li>缺点：适用于简单的操作，复杂逻辑需要结合其他工具。</li></ul><hr><h3 id="常见面试题" tabindex="-1"><a class="header-anchor" href="#常见面试题"><span>常见面试题</span></a></h3><h4 id="_1-synchronized-和-volatile-的区别" tabindex="-1"><a class="header-anchor" href="#_1-synchronized-和-volatile-的区别"><span>1. synchronized 和 volatile 的区别？</span></a></h4><table><thead><tr><th>特性</th><th>synchronized</th><th>volatile</th></tr></thead><tbody><tr><td>线程安全</td><td>是</td><td>否</td></tr><tr><td>原子性</td><td>是</td><td>否</td></tr><tr><td>可见性</td><td>是</td><td>是</td></tr><tr><td>适用场景</td><td>复杂逻辑的临界区保护</td><td>标识位、状态更新</td></tr></tbody></table><h4 id="_2-cas-的问题有哪些" tabindex="-1"><a class="header-anchor" href="#_2-cas-的问题有哪些"><span>2. CAS 的问题有哪些？</span></a></h4><ol><li>ABA 问题。</li><li>高自旋开销。</li><li>无法解决复杂的操作。</li></ol><h4 id="_3-reentrantlock-和-synchronized-的区别" tabindex="-1"><a class="header-anchor" href="#_3-reentrantlock-和-synchronized-的区别"><span>3. ReentrantLock 和 synchronized 的区别？</span></a></h4><ul><li>灵活性：<code>ReentrantLock</code> 提供更多功能，如公平锁。</li><li>性能：在竞争不激烈的场景下，<code>synchronized</code> 性能更高。</li></ul><h4 id="_4-reentrantreadwritelock-适合什么场景" tabindex="-1"><a class="header-anchor" href="#_4-reentrantreadwritelock-适合什么场景"><span>4. ReentrantReadWriteLock 适合什么场景？</span></a></h4><ul><li>读多写少的场景，例如缓存访问。</li></ul><hr>',87)],l={},t=(0,a(6262).A)(l,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,e)}]]),h=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/Java/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%AD.html","title":"Java并发面试题中","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-12-06T00:00:00.000Z","category":["后端"],"tag":["Java","并发","后端开发技巧"],"description":"Java并发面试题中 1. JMM (Java 内存模型) 1.1 JMM 的作用 JMM 是 Java 虚拟机定义的一套内存模型规范，用于屏蔽不同硬件和操作系统的内存访问差异，保证 Java 并发程序的可见性、原子性和有序性。 1.2 关键概念 主内存：所有线程共享的内存，所有变量都存储在主内存中。 工作内存：每个线程有独立的工作内存，用于存储主内存...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/Java/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%AD.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"Java并发面试题中"}],["meta",{"property":"og:description","content":"Java并发面试题中 1. JMM (Java 内存模型) 1.1 JMM 的作用 JMM 是 Java 虚拟机定义的一套内存模型规范，用于屏蔽不同硬件和操作系统的内存访问差异，保证 Java 并发程序的可见性、原子性和有序性。 1.2 关键概念 主内存：所有线程共享的内存，所有变量都存储在主内存中。 工作内存：每个线程有独立的工作内存，用于存储主内存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:tag","content":"后端开发技巧"}],["meta",{"property":"article:published_time","content":"2024-12-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java并发面试题中\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-06T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":3,"title":"1. JMM (Java 内存模型)","slug":"_1-jmm-java-内存模型","link":"#_1-jmm-java-内存模型","children":[]},{"level":3,"title":"2. volatile 关键字","slug":"_2-volatile-关键字","link":"#_2-volatile-关键字","children":[]},{"level":3,"title":"3. 乐观锁和悲观锁","slug":"_3-乐观锁和悲观锁","link":"#_3-乐观锁和悲观锁","children":[]},{"level":3,"title":"4. synchronized 关键字","slug":"_4-synchronized-关键字","link":"#_4-synchronized-关键字","children":[]},{"level":3,"title":"5. ReentrantLock","slug":"_5-reentrantlock","link":"#_5-reentrantlock","children":[]},{"level":3,"title":"6. ReentrantReadWriteLock","slug":"_6-reentrantreadwritelock","link":"#_6-reentrantreadwritelock","children":[]},{"level":3,"title":"7. StampedLock","slug":"_7-stampedlock","link":"#_7-stampedlock","children":[]},{"level":3,"title":"8. Atomic 原子类","slug":"_8-atomic-原子类","link":"#_8-atomic-原子类","children":[]},{"level":3,"title":"常见面试题","slug":"常见面试题","link":"#常见面试题","children":[]}],"git":{"createdTime":1732275083000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":5.18,"words":1553},"filePathRelative":"Java八股/Java/Java并发/Java并发面试题中.md","localizedDate":"2024年12月6日","excerpt":"\\n<hr>\\n<h3>1. <strong>JMM (Java 内存模型)</strong></h3>\\n<h4>1.1 JMM 的作用</h4>\\n<p>JMM 是 Java 虚拟机定义的一套内存模型规范，用于屏蔽不同硬件和操作系统的内存访问差异，保证 Java 并发程序的可见性、原子性和有序性。</p>\\n<h4>1.2 关键概念</h4>\\n<ul>\\n<li><strong>主内存</strong>：所有线程共享的内存，所有变量都存储在主内存中。</li>\\n<li><strong>工作内存</strong>：每个线程有独立的工作内存，用于存储主内存中变量的副本。</li>\\n</ul>\\n<h4>1.3 JMM 的三个核心特性</h4>","autoDesc":true}')}}]);