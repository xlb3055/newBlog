"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[5073],{66262:(e,o)=>{o.A=(e,o)=>{const a=e.__vccOpts||e;for(const[e,t]of o)a[e]=t;return a}},19112:(e,o,a)=>{a.r(o),a.d(o,{comp:()=>l,data:()=>c});var t=a(20641);const n=[(0,t.Fv)('<h1 id="java集合面试题下" tabindex="-1"><a class="header-anchor" href="#java集合面试题下"><span>Java集合面试题下</span></a></h1><h3 id="_1-hashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-和-hashtable-的区别"><span><strong>1. <code>HashMap</code> 和 <code>Hashtable</code> 的区别：</strong></span></a></h3><ol><li><p><strong>线程安全性</strong>：</p><ul><li><strong><code>Hashtable</code></strong> 是线程安全的，它的所有方法都被 <code>synchronized</code> 修饰。由于对整个数据结构加锁，性能会有一定的影响，尤其在多线程环境下竞争较激烈时，可能导致较低的效率。</li><li><strong><code>HashMap</code></strong> 是非线程安全的，但性能较高。为了保证线程安全，可以使用 <code>ConcurrentHashMap</code> 代替。</li></ul></li><li><p><strong>对 <code>null</code> 值的支持</strong>：</p><ul><li><strong><code>Hashtable</code></strong> 不允许 <code>null</code> 键和值。若尝试插入 <code>null</code>，会抛出 <code>NullPointerException</code>。</li><li><strong><code>HashMap</code></strong> 允许一个 <code>null</code> 键和多个 <code>null</code> 值。</li></ul></li><li><p><strong>初始化容量和扩容规则</strong>：</p><ul><li><strong><code>Hashtable</code></strong> 默认初始容量为 11，负载因子为 0.75，扩容时将容量变为原来的 2n + 1。</li><li><strong><code>HashMap</code></strong> 默认初始容量为 16，负载因子为 0.75，扩容时将容量翻倍。<code>HashMap</code> 使用 2 的幂次方来扩展容量，这是为了提高性能，避免哈希冲突。</li></ul></li><li><p><strong>继承体系</strong>：</p><ul><li><strong><code>Hashtable</code></strong> 继承自 <code>Dictionary</code> 类，<code>Dictionary</code> 是 JDK 1.0 引入的，已被弃用。</li><li><strong><code>HashMap</code></strong> 继承自 <code>AbstractMap</code>，并实现了 <code>Map</code> 接口。</li></ul></li><li><p><strong>迭代器</strong>：</p><ul><li><strong><code>Hashtable</code></strong> 使用 <code>Enumeration</code> 进行迭代，而 <code>Enumeration</code> 并不支持 fail-fast 机制，即修改集合时不会抛出异常。</li><li><strong><code>HashMap</code></strong> 使用 <code>Iterator</code>，它是 fail-fast 的，如果在迭代过程中修改集合，将抛出 <code>ConcurrentModificationException</code>。</li></ul></li><li><p><strong>底层实现</strong>：</p><ul><li><strong><code>Hashtable</code></strong> 底层使用的是数组加链表来存储数据，但没有进行链表转红黑树的优化。</li><li><strong><code>HashMap</code></strong> 在 JDK 1.8 以后对哈希冲突的处理做了优化，当链表长度超过阈值时（默认为 8），会将链表转换为红黑树以提高查询性能。</li></ul></li></ol><h3 id="_2-hashmap-和-hashset-的区别" tabindex="-1"><a class="header-anchor" href="#_2-hashmap-和-hashset-的区别"><span><strong>2. <code>HashMap</code> 和 <code>HashSet</code> 的区别：</strong></span></a></h3><ol><li><p><strong>数据结构</strong>：</p><ul><li><strong><code>HashSet</code></strong> 是一个基于 <code>HashMap</code> 实现的 Set 接口，底层是使用 <code>HashMap</code> 来存储数据。它不允许重复的元素，因此底层会利用 <code>HashMap</code> 来判断元素是否已存在。</li><li><strong><code>HashMap</code></strong> 是一个基于键值对的映射，存储数据时会关联一个 <code>key</code> 和一个 <code>value</code>。</li></ul></li><li><p><strong>重复元素</strong>：</p><ul><li><strong><code>HashSet</code></strong> 不允许存储重复的元素。如果插入一个已经存在的元素，它会忽略该元素。</li><li><strong><code>HashMap</code></strong> 允许 <code>key</code> 的重复，但不允许 <code>key</code> 和 <code>value</code> 配对的重复（即相同的 <code>key</code> 不会存在多个相同的 <code>value</code>）。</li></ul></li><li><p><strong>接口和功能</strong>：</p><ul><li><strong><code>HashSet</code></strong> 只实现了 <code>Set</code> 接口，提供元素的无序存储，不保证插入顺序。</li><li><strong><code>HashMap</code></strong> 实现了 <code>Map</code> 接口，提供键值对存储，支持对键的查找和访问。</li></ul></li></ol><h3 id="_3-hashmap-和-treemap-的区别" tabindex="-1"><a class="header-anchor" href="#_3-hashmap-和-treemap-的区别"><span><strong>3. <code>HashMap</code> 和 <code>TreeMap</code> 的区别：</strong></span></a></h3><ol><li><p><strong>排序</strong>：</p><ul><li><strong><code>TreeMap</code></strong> 是有序的，它根据键的自然顺序或构造时提供的比较器对元素进行排序。</li><li><strong><code>HashMap</code></strong> 是无序的，它的元素没有特定的顺序。</li></ul></li><li><p><strong>性能</strong>：</p><ul><li><strong><code>TreeMap</code></strong> 的查找、插入和删除操作的时间复杂度为 O(log n)，这是因为它底层使用红黑树实现。</li><li><strong><code>HashMap</code></strong> 的查找、插入和删除操作的时间复杂度为 O(1)，但在极端情况下（如大量哈希冲突）可能会退化为 O(n)。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li>如果需要按照键的排序存储数据，可以使用 <strong><code>TreeMap</code></strong>。</li><li>如果不关心排序，只需要快速存储和查找数据，可以使用 <strong><code>HashMap</code></strong>。</li></ul></li></ol><h3 id="_4-hashset-如何检查重复元素" tabindex="-1"><a class="header-anchor" href="#_4-hashset-如何检查重复元素"><span><strong>4. <code>HashSet</code> 如何检查重复元素：</strong></span></a></h3><ul><li><strong><code>HashSet</code></strong> 通过调用其底层 <code>HashMap</code> 的 <code>containsKey</code> 方法来检查元素是否已存在。如果已经存在，则不插入新元素。底层通过 <code>hashCode()</code> 和 <code>equals()</code> 方法来比较元素。</li></ul><h3 id="_5-hashmap-的底层实现" tabindex="-1"><a class="header-anchor" href="#_5-hashmap-的底层实现"><span><strong>5. <code>HashMap</code> 的底层实现</strong>：</span></a></h3><ul><li><strong><code>HashMap</code></strong> 底层使用数组和链表（或红黑树）来实现存储。每个数组元素是一个链表（或树的根节点），哈希冲突发生时，元素将以链表形式存储。链表过长时（超过阈值），会转换为红黑树来提高查找效率。</li></ul><h3 id="_6-hashmap-线程不安全的原因" tabindex="-1"><a class="header-anchor" href="#_6-hashmap-线程不安全的原因"><span><strong>6. <code>HashMap</code> 线程不安全的原因</strong>：</span></a></h3><ul><li><code>HashMap</code> 不是线程安全的，因为它没有同步机制来保证并发访问时的正确性。当多个线程同时对 <code>HashMap</code> 进行读写操作时，可能会出现数据不一致或死循环等问题。因此，在多线程环境中，应使用 <code>ConcurrentHashMap</code> 或手动同步访问 <code>HashMap</code>。</li></ul>',13)],s={},l=(0,a(66262).A)(s,[["render",function(e,o){return(0,t.uX)(),(0,t.CE)("div",null,n)}]]),c=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/Java/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8B.html","title":"Java集合面试题下","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-14T00:00:00.000Z","category":["后端"],"tag":["Java","集合","后端开发技巧"],"description":"Java集合面试题下 1. HashMap 和 Hashtable 的区别： 线程安全性： Hashtable 是线程安全的，它的所有方法都被 synchronized 修饰。由于对整个数据结构加锁，性能会有一定的影响，尤其在多线程环境下竞争较激烈时，可能导致较低的效率。 HashMap 是非线程安全的，但性能较高。为了保证线程安全，可以使用 Conc...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/Java/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8B.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"Java集合面试题下"}],["meta",{"property":"og:description","content":"Java集合面试题下 1. HashMap 和 Hashtable 的区别： 线程安全性： Hashtable 是线程安全的，它的所有方法都被 synchronized 修饰。由于对整个数据结构加锁，性能会有一定的影响，尤其在多线程环境下竞争较激烈时，可能导致较低的效率。 HashMap 是非线程安全的，但性能较高。为了保证线程安全，可以使用 Conc..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"集合"}],["meta",{"property":"article:tag","content":"后端开发技巧"}],["meta",{"property":"article:published_time","content":"2024-11-14T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java集合面试题下\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-14T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":3,"title":"1. HashMap 和 Hashtable 的区别：","slug":"_1-hashmap-和-hashtable-的区别","link":"#_1-hashmap-和-hashtable-的区别","children":[]},{"level":3,"title":"2. HashMap 和 HashSet 的区别：","slug":"_2-hashmap-和-hashset-的区别","link":"#_2-hashmap-和-hashset-的区别","children":[]},{"level":3,"title":"3. HashMap 和 TreeMap 的区别：","slug":"_3-hashmap-和-treemap-的区别","link":"#_3-hashmap-和-treemap-的区别","children":[]},{"level":3,"title":"4. HashSet 如何检查重复元素：","slug":"_4-hashset-如何检查重复元素","link":"#_4-hashset-如何检查重复元素","children":[]},{"level":3,"title":"5. HashMap 的底层实现：","slug":"_5-hashmap-的底层实现","link":"#_5-hashmap-的底层实现","children":[]},{"level":3,"title":"6. HashMap 线程不安全的原因：","slug":"_6-hashmap-线程不安全的原因","link":"#_6-hashmap-线程不安全的原因","children":[]}],"git":{"createdTime":1732275083000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":3.57,"words":1070},"filePathRelative":"Java八股/Java/Java集合/Java集合面试题下.md","localizedDate":"2024年11月14日","excerpt":"\\n<h3><strong>1. <code>HashMap</code> 和 <code>Hashtable</code> 的区别：</strong></h3>\\n<ol>\\n<li>\\n<p><strong>线程安全性</strong>：</p>\\n<ul>\\n<li><strong><code>Hashtable</code></strong> 是线程安全的，它的所有方法都被 <code>synchronized</code> 修饰。由于对整个数据结构加锁，性能会有一定的影响，尤其在多线程环境下竞争较激烈时，可能导致较低的效率。</li>\\n<li><strong><code>HashMap</code></strong> 是非线程安全的，但性能较高。为了保证线程安全，可以使用 <code>ConcurrentHashMap</code> 代替。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>对 <code>null</code> 值的支持</strong>：</p>\\n<ul>\\n<li><strong><code>Hashtable</code></strong> 不允许 <code>null</code> 键和值。若尝试插入 <code>null</code>，会抛出 <code>NullPointerException</code>。</li>\\n<li><strong><code>HashMap</code></strong> 允许一个 <code>null</code> 键和多个 <code>null</code> 值。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>初始化容量和扩容规则</strong>：</p>\\n<ul>\\n<li><strong><code>Hashtable</code></strong> 默认初始容量为 11，负载因子为 0.75，扩容时将容量变为原来的 2n + 1。</li>\\n<li><strong><code>HashMap</code></strong> 默认初始容量为 16，负载因子为 0.75，扩容时将容量翻倍。<code>HashMap</code> 使用 2 的幂次方来扩展容量，这是为了提高性能，避免哈希冲突。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>继承体系</strong>：</p>\\n<ul>\\n<li><strong><code>Hashtable</code></strong> 继承自 <code>Dictionary</code> 类，<code>Dictionary</code> 是 JDK 1.0 引入的，已被弃用。</li>\\n<li><strong><code>HashMap</code></strong> 继承自 <code>AbstractMap</code>，并实现了 <code>Map</code> 接口。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>迭代器</strong>：</p>\\n<ul>\\n<li><strong><code>Hashtable</code></strong> 使用 <code>Enumeration</code> 进行迭代，而 <code>Enumeration</code> 并不支持 fail-fast 机制，即修改集合时不会抛出异常。</li>\\n<li><strong><code>HashMap</code></strong> 使用 <code>Iterator</code>，它是 fail-fast 的，如果在迭代过程中修改集合，将抛出 <code>ConcurrentModificationException</code>。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>底层实现</strong>：</p>\\n<ul>\\n<li><strong><code>Hashtable</code></strong> 底层使用的是数组加链表来存储数据，但没有进行链表转红黑树的优化。</li>\\n<li><strong><code>HashMap</code></strong> 在 JDK 1.8 以后对哈希冲突的处理做了优化，当链表长度超过阈值时（默认为 8），会将链表转换为红黑树以提高查询性能。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);