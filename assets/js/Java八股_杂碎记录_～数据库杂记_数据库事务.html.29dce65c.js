"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[8400],{66262:(e,t)=>{t.A=(e,t)=>{const i=e.__vccOpts||e;for(const[e,a]of t)i[e]=a;return i}},691:(e,t,i)=>{i.r(t),i.d(t,{comp:()=>o,data:()=>r});var a=i(20641);const n=[(0,a.Fv)('<h1 id="数据库事务" tabindex="-1"><a class="header-anchor" href="#数据库事务"><span>数据库事务</span></a></h1><h2 id="数据库事务的特性" tabindex="-1"><a class="header-anchor" href="#数据库事务的特性"><span>数据库事务的特性</span></a></h2><ol><li>原子性：一个事务包含的行为要么全部成功，要么全部不成功，如果在执行中间发生错误，则会进行事务回滚，回滚到事务开始之前的状态</li><li>一致性：事务执行完毕后不会对数据库的完整性造成破坏</li><li>事务的隔离：由于数据库的事务支持多线程，事务隔离是为了防止多个线程的事务造成数据不一致 持久性：事务完成后，对数据的修改是永久的，哪怕系统故障也不会消失</li></ol><h2 id="数据库事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#数据库事务的隔离级别"><span>数据库事务的隔离级别</span></a></h2><ol><li>未提交读：可以读到其他线程修改但没提交的数据，如果那个线程产生错误从而导致回滚，那么这次读取的数据就是脏数据</li><li>提交读：事务在读取数据的过程中，有其他线程事务修改了数据，造成前后数据不一致</li><li>重复读：一开始读取数据为空，但是尝试修改这条不存在的数据却成功了，此时再读取该数据又可以读取到了</li><li>串行读：是最严格的隔离级别。严格按照先后次序执行，但会造成效率大大下降</li></ol>',5)],l={},o=(0,i(66262).A)(l,[["render",function(e,t){return(0,a.uX)(),(0,a.CE)("div",null,n)}]]),r=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%9D%82%E7%A2%8E%E8%AE%B0%E5%BD%95/%EF%BD%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%82%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.html","title":"数据库事务","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-08-11T00:00:00.000Z","category":["后端"],"tag":["数据库","后端开发技巧"],"description":"数据库事务 数据库事务的特性 原子性：一个事务包含的行为要么全部成功，要么全部不成功，如果在执行中间发生错误，则会进行事务回滚，回滚到事务开始之前的状态 一致性：事务执行完毕后不会对数据库的完整性造成破坏 事务的隔离：由于数据库的事务支持多线程，事务隔离是为了防止多个线程的事务造成数据不一致 持久性：事务完成后，对数据的修改是永久的，哪怕系统故障也不会...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%9D%82%E7%A2%8E%E8%AE%B0%E5%BD%95/%EF%BD%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9D%82%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"数据库事务"}],["meta",{"property":"og:description","content":"数据库事务 数据库事务的特性 原子性：一个事务包含的行为要么全部成功，要么全部不成功，如果在执行中间发生错误，则会进行事务回滚，回滚到事务开始之前的状态 一致性：事务执行完毕后不会对数据库的完整性造成破坏 事务的隔离：由于数据库的事务支持多线程，事务隔离是为了防止多个线程的事务造成数据不一致 持久性：事务完成后，对数据的修改是永久的，哪怕系统故障也不会..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:tag","content":"后端开发技巧"}],["meta",{"property":"article:published_time","content":"2024-08-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据库事务\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"数据库事务的特性","slug":"数据库事务的特性","link":"#数据库事务的特性","children":[]},{"level":2,"title":"数据库事务的隔离级别","slug":"数据库事务的隔离级别","link":"#数据库事务的隔离级别","children":[]}],"git":{"createdTime":1732275083000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":1.21,"words":364},"filePathRelative":"Java八股/杂碎记录/～数据库杂记/数据库事务.md","localizedDate":"2024年8月11日","excerpt":"\\n<h2>数据库事务的特性</h2>\\n<ol>\\n<li>原子性：一个事务包含的行为要么全部成功，要么全部不成功，如果在执行中间发生错误，则会进行事务回滚，回滚到事务开始之前的状态</li>\\n<li>一致性：事务执行完毕后不会对数据库的完整性造成破坏</li>\\n<li>事务的隔离：由于数据库的事务支持多线程，事务隔离是为了防止多个线程的事务造成数据不一致\\n持久性：事务完成后，对数据的修改是永久的，哪怕系统故障也不会消失</li>\\n</ol>\\n<h2>数据库事务的隔离级别</h2>\\n<ol>\\n<li>未提交读：可以读到其他线程修改但没提交的数据，如果那个线程产生错误从而导致回滚，那么这次读取的数据就是脏数据</li>\\n<li>提交读：事务在读取数据的过程中，有其他线程事务修改了数据，造成前后数据不一致</li>\\n<li>重复读：一开始读取数据为空，但是尝试修改这条不存在的数据却成功了，此时再读取该数据又可以读取到了</li>\\n<li>串行读：是最严格的隔离级别。严格按照先后次序执行，但会造成效率大大下降</li>\\n</ol>","autoDesc":true}')}}]);