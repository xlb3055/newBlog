"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[5862],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},4699:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>h,data:()=>e});var n=a(641);const t=[(0,n.Fv)('<h1 id="_3种常用的缓存读写策略" tabindex="-1"><a class="header-anchor" href="#_3种常用的缓存读写策略"><span>3种常用的缓存读写策略</span></a></h1><p>在现代分布式系统中，缓存作为一种重要的性能优化手段，广泛应用于提升应用程序的响应速度和减轻数据库压力。缓存策略是缓存设计中至关重要的一部分，合理的缓存策略可以使得数据访问更高效、系统负载更均衡。本文将介绍三种常见的缓存读写策略：<strong>Cache Aside Pattern</strong>（旁路缓存模式）、<strong>Read/Write Through Pattern</strong>（读写穿透）、以及 <strong>Write Behind Pattern</strong>（异步缓存写入）。</p><hr><h3 id="_1-cache-aside-pattern-旁路缓存模式" tabindex="-1"><a class="header-anchor" href="#_1-cache-aside-pattern-旁路缓存模式"><span>1. Cache Aside Pattern（旁路缓存模式）</span></a></h3><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h4><p>旁路缓存模式（又称为 Lazy Load 缓存模式）是一种最常见的缓存策略。在该模式下，应用程序首先访问缓存，如果缓存中不存在数据（即缓存未命中），则应用程序从数据库中读取数据并将其写入缓存中，之后的请求都可以直接从缓存中读取。</p><h4 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h4><ol><li><strong>缓存访问</strong>：应用程序首先从缓存读取数据。</li><li><strong>缓存未命中</strong>：如果缓存中没有数据，应用程序会向数据库请求数据。</li><li><strong>数据库访问</strong>：应用程序从数据库中读取数据。</li><li><strong>更新缓存</strong>：应用程序将从数据库中读取到的数据放入缓存，之后其他请求可以直接从缓存中读取数据。</li></ol><h4 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点"><span>优缺点</span></a></h4><ul><li><p><strong>优点</strong>：</p><ul><li><strong>延迟加载</strong>：只有在缓存未命中的情况下，才会从数据库加载数据，避免了每次都访问数据库。</li><li><strong>缓存失效控制</strong>：数据更新时可以手动更新缓存，避免数据与缓存不一致的情况。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>首次请求延迟</strong>：当缓存未命中时，必须访问数据库，因此首次请求会比较慢。</li><li><strong>缓存不一致</strong>：当数据库中的数据发生变化时，需要额外的机制来更新缓存，否则会出现缓存与数据库不一致的问题。</li></ul></li></ul><h4 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h4><p>适用于数据访问量较大、读请求远远多于写请求的场景。尤其在一些不要求实时数据更新的场景中，旁路缓存模式非常有效。</p><h4 id="代码示例" tabindex="-1"><a class="header-anchor" href="#代码示例"><span>代码示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> CacheAsidePattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cache</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 缓存</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Database</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 数据库</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Data</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 尝试从缓存获取数据</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Data</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">            // 如果缓存没有，查询数据库</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">query</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">            // 将查询到的数据放入缓存</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-read-write-through-pattern-读写穿透" tabindex="-1"><a class="header-anchor" href="#_2-read-write-through-pattern-读写穿透"><span>2. Read/Write Through Pattern（读写穿透）</span></a></h3><h4 id="原理-1" tabindex="-1"><a class="header-anchor" href="#原理-1"><span>原理</span></a></h4><p>读写穿透模式（Read Through/Write Through）是指数据在访问缓存时，不直接访问数据库，而是通过缓存来自动进行读写操作。缓存不仅仅用于读取数据，还会在数据被写入时自动更新缓存。</p><ul><li><strong>读穿透</strong>：每次访问数据时，首先从缓存中读取数据。如果缓存中没有数据，再去数据库中查询。</li><li><strong>写穿透</strong>：每次更新数据时，先更新缓存，然后再更新数据库，确保缓存和数据库的数据是一致的。</li></ul><h4 id="工作流程-1" tabindex="-1"><a class="header-anchor" href="#工作流程-1"><span>工作流程</span></a></h4><ol><li><strong>读操作</strong>：应用程序从缓存中获取数据。如果缓存中没有数据，则自动从数据库读取，并将数据放入缓存。</li><li><strong>写操作</strong>：应用程序更新数据时，首先更新缓存，然后再更新数据库，保证数据库和缓存的数据一致。</li></ol><h4 id="优缺点-1" tabindex="-1"><a class="header-anchor" href="#优缺点-1"><span>优缺点</span></a></h4><ul><li><p><strong>优点</strong>：</p><ul><li><strong>自动同步</strong>：每次数据读取和更新都自动进行缓存和数据库同步，无需额外的手动干预。</li><li><strong>提高性能</strong>：缓存直接充当数据库的代理，减少数据库的访问压力。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>写入延迟</strong>：每次写入都要先写缓存，然后再写数据库，可能导致写入延迟。</li><li><strong>缓存一致性问题</strong>：如果缓存更新失败，可能会导致缓存与数据库数据不一致。</li></ul></li></ul><h4 id="应用场景-1" tabindex="-1"><a class="header-anchor" href="#应用场景-1"><span>应用场景</span></a></h4><p>适用于频繁读写的系统，尤其是数据频繁更新并且需要实时数据一致性的场景。</p><h4 id="代码示例-1" tabindex="-1"><a class="header-anchor" href="#代码示例-1"><span>代码示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReadWriteThroughPattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cache</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 缓存</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Database</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 数据库</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 读操作</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Data</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Data</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">query</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> data;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 写操作</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updateData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Data</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data);  </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 更新缓存</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data);  </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 更新数据库</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-write-behind-pattern-异步缓存写入" tabindex="-1"><a class="header-anchor" href="#_3-write-behind-pattern-异步缓存写入"><span>3. Write Behind Pattern（异步缓存写入）</span></a></h3><h4 id="原理-2" tabindex="-1"><a class="header-anchor" href="#原理-2"><span>原理</span></a></h4><p>异步缓存写入模式（也称为 Write-Back）是指写操作首先写入缓存，然后异步地更新数据库。也就是说，写操作并不会立即同步到数据库，而是缓存中的数据将在稍后的某个时间点（如经过一定延迟后）批量更新到数据库中。</p><h4 id="工作流程-2" tabindex="-1"><a class="header-anchor" href="#工作流程-2"><span>工作流程</span></a></h4><ol><li><strong>写操作</strong>：应用程序更新数据时，首先更新缓存，而不是直接写入数据库。</li><li><strong>异步写入数据库</strong>：更新操作会被异步地记录，并在后台线程中更新到数据库，通常会有一定的延迟。</li></ol><h4 id="优缺点-2" tabindex="-1"><a class="header-anchor" href="#优缺点-2"><span>优缺点</span></a></h4><ul><li><p><strong>优点</strong>：</p><ul><li><strong>减少数据库负载</strong>：通过异步方式批量更新数据，避免频繁的数据库写入请求。</li><li><strong>提高性能</strong>：由于是异步更新，写操作的响应速度较快。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>数据一致性问题</strong>：如果在数据从缓存同步到数据库之前发生故障（如服务器宕机），可能导致缓存中的数据丢失或数据库中没有最新的数据。</li><li><strong>复杂的错误处理机制</strong>：需要设计可靠的异步任务和重试机制，确保数据最终能够正确同步到数据库。</li></ul></li></ul><h4 id="应用场景-2" tabindex="-1"><a class="header-anchor" href="#应用场景-2"><span>应用场景</span></a></h4><p>适用于写操作频繁，但对数据一致性要求不特别高的场景，例如日志记录系统、用户行为数据等。</p><h4 id="代码示例-2" tabindex="-1"><a class="header-anchor" href="#代码示例-2"><span>代码示例</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> WriteBehindPattern</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cache</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 缓存</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Database</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  // 数据库</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 写操作，先更新缓存</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updateData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Data</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        cache</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">put</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data);  </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 更新缓存</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 异步写入数据库</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> db</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">update</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(key, data)).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>这三种缓存策略各有优缺点，适用于不同的业务场景：</p><ol><li><strong>Cache Aside Pattern</strong>：适用于读请求多、写请求少的场景，通过懒加载（Lazy Loading）减少数据库访问。需要在数据变动时手动更新缓存。</li><li><strong>Read/Write Through Pattern</strong>：适用于读写均衡、需要数据一致性的场景，读写操作都会同步缓存，确保缓存与数据库的一致性。</li><li><strong>Write Behind Pattern</strong>：适用于写请求频繁、不太关心即时一致性的场景，通过异步更新数据库来提高写入性能，减少数据库负载。</li></ol>',43)],l={},h=(0,a(6262).A)(l,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,t)}]]),e=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5.html","title":"3种常用的缓存读写策略","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-27T00:00:00.000Z","category":["后端"],"tag":["Redis","数据库"],"description":"3种常用的缓存读写策略 在现代分布式系统中，缓存作为一种重要的性能优化手段，广泛应用于提升应用程序的响应速度和减轻数据库压力。缓存策略是缓存设计中至关重要的一部分，合理的缓存策略可以使得数据访问更高效、系统负载更均衡。本文将介绍三种常见的缓存读写策略：Cache Aside Pattern（旁路缓存模式）、Read/Write Through Patt...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/3%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"3种常用的缓存读写策略"}],["meta",{"property":"og:description","content":"3种常用的缓存读写策略 在现代分布式系统中，缓存作为一种重要的性能优化手段，广泛应用于提升应用程序的响应速度和减轻数据库压力。缓存策略是缓存设计中至关重要的一部分，合理的缓存策略可以使得数据访问更高效、系统负载更均衡。本文将介绍三种常见的缓存读写策略：Cache Aside Pattern（旁路缓存模式）、Read/Write Through Patt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-11-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3种常用的缓存读写策略\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":3,"title":"1. Cache Aside Pattern（旁路缓存模式）","slug":"_1-cache-aside-pattern-旁路缓存模式","link":"#_1-cache-aside-pattern-旁路缓存模式","children":[]},{"level":3,"title":"2. Read/Write Through Pattern（读写穿透）","slug":"_2-read-write-through-pattern-读写穿透","link":"#_2-read-write-through-pattern-读写穿透","children":[]},{"level":3,"title":"3. Write Behind Pattern（异步缓存写入）","slug":"_3-write-behind-pattern-异步缓存写入","link":"#_3-write-behind-pattern-异步缓存写入","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1733029796000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":5.77,"words":1732},"filePathRelative":"Java八股/数据库/Redis/重要知识点/3种常用的缓存读写策略.md","localizedDate":"2024年11月27日","excerpt":"\\n<p>在现代分布式系统中，缓存作为一种重要的性能优化手段，广泛应用于提升应用程序的响应速度和减轻数据库压力。缓存策略是缓存设计中至关重要的一部分，合理的缓存策略可以使得数据访问更高效、系统负载更均衡。本文将介绍三种常见的缓存读写策略：<strong>Cache Aside Pattern</strong>（旁路缓存模式）、<strong>Read/Write Through Pattern</strong>（读写穿透）、以及 <strong>Write Behind Pattern</strong>（异步缓存写入）。</p>\\n<hr>\\n<h3>1. Cache Aside Pattern（旁路缓存模式）</h3>","autoDesc":true}')}}]);