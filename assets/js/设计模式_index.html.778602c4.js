"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[1090],{66262:(t,l)=>{l.A=(t,l)=>{const i=t.__vccOpts||t;for(const[t,e]of l)i[t]=e;return i}},73068:(t,l,i)=>{i.r(l),i.d(l,{comp:()=>s,data:()=>o});var e=i(20641);const n=(0,e.Fv)('<h1 id="设计模式前言-在-ai-时代重新掌握设计判断力" tabindex="-1"><a class="header-anchor" href="#设计模式前言-在-ai-时代重新掌握设计判断力"><span>设计模式前言：在 AI 时代重新掌握设计判断力</span></a></h1><p>AI 的发展让编码效率大幅提升，vibe coding 让“先跑起来”变得很容易。但效率不是全部，真正困难的是判断：什么样的设计是好的、什么时候该抽象、什么时候该简单。设计模式不是让我们拘泥于模板，而是帮助我们在“自由发挥”与“工程可靠”之间做出更清晰的选择。</p><hr><h2 id="为什么现在还要学设计模式" tabindex="-1"><a class="header-anchor" href="#为什么现在还要学设计模式"><span>为什么现在还要学设计模式</span></a></h2><ul><li>AI 能生成代码，但“正确的结构”需要人来判断。</li><li>好的设计依赖上下文与权衡，不是堆功能就能解决。</li><li>设计模式提供了一套稳定的语言和思考框架，便于沟通与复用。</li><li>有了模式意识，才能更好地评估 AI 输出：哪里该改，为什么要改。</li></ul><hr><h2 id="这套教程会怎么讲" tabindex="-1"><a class="header-anchor" href="#这套教程会怎么讲"><span>这套教程会怎么讲</span></a></h2><p>每个模式都会围绕“问题 → 意图 → 结构 → 代码 → 取舍”展开，重点不在记忆名词，而在理解“它解决什么问题、为什么要这样设计”。你会看到：</p><ul><li>真实业务场景与痛点</li><li>角色职责与协作流程</li><li>最小可运行的代码示例</li><li>优缺点、适用边界与常见误区</li></ul><hr><h2 id="如何更高效地学习" tabindex="-1"><a class="header-anchor" href="#如何更高效地学习"><span>如何更高效地学习</span></a></h2><ul><li>把设计模式当作“工具箱”，而不是“教条”。</li><li>先想问题再选模式，避免为了用模式而用模式。</li><li>用模式做判断标准：评估复杂度、可扩展性、可维护性。</li><li>与 AI 协作时，用模式来约束输入和验收输出。</li></ul><hr><h2 id="设计模式总览-从问题到选择的完整地图" tabindex="-1"><a class="header-anchor" href="#设计模式总览-从问题到选择的完整地图"><span>设计模式总览：从问题到选择的完整地图</span></a></h2><p>设计模式不是让我们“套模板”，而是提供一套判断框架：<strong>在复杂与简单之间，如何做出可维护、可扩展的设计选择</strong>。这份总览把 23 个经典模式串成一张选择地图，方便你在真实场景中快速定位答案。</p><hr><h2 id="先把问题分成-3-大类" tabindex="-1"><a class="header-anchor" href="#先把问题分成-3-大类"><span>先把问题分成 3 大类</span></a></h2><p>设计模式的核心不是记名字，而是识别问题类型：</p><ul><li><strong>创建型</strong>：关注“对象如何创建”。</li><li><strong>结构型</strong>：关注“对象如何组合”。</li><li><strong>行为型</strong>：关注“对象如何协作”。</li></ul><p>这三类覆盖了大多数工程场景。</p><hr><h2 id="快速选择路径-全模式" tabindex="-1"><a class="header-anchor" href="#快速选择路径-全模式"><span>快速选择路径（全模式）</span></a></h2>',22),r=(0,e.Fv)('<hr><h2 id="创建型模式-如何创建对象" tabindex="-1"><a class="header-anchor" href="#创建型模式-如何创建对象"><span>创建型模式（如何创建对象）</span></a></h2><ul><li><strong>单例</strong>：全局唯一实例，适合配置中心、日志器。</li><li><strong>生成器</strong>：分步骤构建复杂对象，流程复用。</li><li><strong>原型</strong>：复制已有对象，适合模板化与批量创建。</li><li><strong>工厂方法</strong>：创建单一产品，可通过子类扩展。</li><li><strong>抽象工厂</strong>：创建产品族，保证一致性。</li></ul><hr><h2 id="结构型模式-如何组合对象" tabindex="-1"><a class="header-anchor" href="#结构型模式-如何组合对象"><span>结构型模式（如何组合对象）</span></a></h2><ul><li><strong>适配器</strong>：接口不兼容时做转换。</li><li><strong>外观</strong>：对子系统提供统一入口。</li><li><strong>代理</strong>：控制访问或增强能力。</li><li><strong>装饰器</strong>：动态叠加功能，替代继承。</li><li><strong>桥接</strong>：抽象与实现分离，双维度独立扩展。</li><li><strong>组合</strong>：树形结构统一处理。</li><li><strong>享元</strong>：共享对象，降低内存。</li></ul><hr><h2 id="行为型模式-如何协作与变化" tabindex="-1"><a class="header-anchor" href="#行为型模式-如何协作与变化"><span>行为型模式（如何协作与变化）</span></a></h2><ul><li><strong>责任链</strong>：多步处理，可短路。</li><li><strong>观察者</strong>：一对多通知。</li><li><strong>中介者</strong>：集中编排对象交互。</li><li><strong>策略</strong>：算法可替换。</li><li><strong>状态</strong>：行为随状态变化。</li><li><strong>模板方法</strong>：流程固定，步骤可变。</li><li><strong>命令</strong>：请求封装，支持排队与撤销。</li><li><strong>备忘录</strong>：保存与恢复状态。</li><li><strong>迭代器</strong>：统一遍历方式。</li><li><strong>访问者</strong>：结构稳定，操作频繁新增。</li><li><strong>解释器</strong>：规则表达式解释执行。</li></ul><hr><h2 id="易混淆对比-全局视角" tabindex="-1"><a class="header-anchor" href="#易混淆对比-全局视角"><span>易混淆对比（全局视角）</span></a></h2><table><thead><tr><th>对比</th><th>关键差别</th><th>选用建议</th></tr></thead><tbody><tr><td>策略 vs 状态</td><td>策略是“可替换算法”，状态是“行为随状态变化”</td><td>强调状态流转选状态</td></tr><tr><td>观察者 vs 中介者</td><td>观察者是广播通知，中介者是集中编排</td><td>需要流程编排选中介者</td></tr><tr><td>责任链 vs 观察者</td><td>责任链逐级处理可短路，观察者并行通知</td><td>需要短路选责任链</td></tr><tr><td>代理 vs 装饰器</td><td>代理强调控制访问，装饰器强调功能增强</td><td>要控制访问选代理</td></tr><tr><td>适配器 vs 外观</td><td>适配器解决接口不兼容，外观简化使用</td><td>需要转换选适配器</td></tr><tr><td>组合 vs 访问者</td><td>组合组织树结构，访问者扩展操作</td><td>结构稳定且操作频繁新增选访问者</td></tr></tbody></table><hr><h2 id="常见组合套路" tabindex="-1"><a class="header-anchor" href="#常见组合套路"><span>常见组合套路</span></a></h2><ul><li><strong>责任链 + 策略</strong>：前置校验后路由策略。</li><li><strong>中介者 + 状态</strong>：中介者编排流程，状态控制流转阶段。</li><li><strong>命令 + 备忘录</strong>：命令执行前保存快照，实现撤销。</li><li><strong>观察者 + 模板方法</strong>：广播事件后，各通道复用统一流程。</li><li><strong>组合 + 访问者</strong>：树形结构遍历 + 多操作扩展。</li><li><strong>代理 + 缓存</strong>：缓存代理隔离真实服务压力。</li></ul><hr><h2 id="选择时的-5-条检查清单" tabindex="-1"><a class="header-anchor" href="#选择时的-5-条检查清单"><span>选择时的 5 条检查清单</span></a></h2><ul><li>变化点是什么？是创建、结构还是协作？</li><li>是“单一产品”还是“产品族”？</li><li>变化是否集中在算法、状态或流程？</li><li>是否需要复用对象或减少创建成本？</li><li>引入模式的收益是否覆盖复杂度？</li></ul><hr><h2 id="阅读建议-从常用到不常用" tabindex="-1"><a class="header-anchor" href="#阅读建议-从常用到不常用"><span>阅读建议（从常用到不常用）</span></a></h2><ol><li>单例 / 工厂方法 / 策略 / 责任链 / 观察者</li><li>状态 / 模板方法 / 命令 / 适配器 / 代理</li><li>抽象工厂 / 生成器 / 组合 / 外观 / 装饰器</li><li>桥接 / 享元 / 原型 / 访问者 / 解释器</li></ol><hr><h2 id="总览小结" tabindex="-1"><a class="header-anchor" href="#总览小结"><span>总览小结</span></a></h2><ul><li>设计模式是一套“判断力工具箱”，不是模板集合。</li><li>先识别问题类型，再选择模式。</li><li>组合模式可以一起使用，但每个模式只解决一类问题。</li><li>保持简单优先：能不引入就不引入。</li></ul><hr><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结"><span>小结</span></a></h2><p>AI 让我们更快，但设计能力决定我们能走多远。希望这套设计模式教程能成为你的判断力补给站：不盲从、不堆砌，用更稳的结构交付更可信的系统。</p>',27),a={},s=(0,i(66262).A)(a,[["render",function(t,l){const i=(0,e.g2)("Mermaid");return(0,e.uX)(),(0,e.CE)("div",null,[n,(0,e.bF)(i,{id:"mermaid-125",code:"eJxllEtP20AQx+/9FPkARZBAeFxatdCeOfS24lBVqnqoVKmq1KvzgpDgGMiDkEBMEoekVHkgaEjsPL7Mzu76W3Riew2G3LK7v5n/zPzHX7//+P3l2+efv0Kfdl6F8PeOsKsRzBP2Wc9ulFm5Ty2FjtNv90JLS29C78ME+mNxW4d0FSwTDJVdxr27bbxzT2vZPTeWy0QIt/KsluRWEo7TQUbePWdWZR5Vo9OLILNKRP2Ijtw8DrQddm52UIFapLOs93JX/ndDy1cR1LnPui37xlhklmW4CSWKwgo6Sx/DeSdIrxL7QhHXMYQgPWSdOrucSwhV53S/FEmsyb6glpFCzTbkY3RUAK3PDv/AbVHS+O6hBbk4K43ZXTEYI+rFcGl2pkkoSlhmumiUg8p+RJzLD2HCci3QmnSkQmoCvbGk1omtxO2U+lidR0S86rilo1ZILWjeU+CoJAYJXujIABsEjJJoY8KnNE6mN0fnsFwbe7PMJ3nolpfBGoq5DpkrMZ1KfpNQq8mP94M8diDTYUoMGjWYmJDRRcIntohopuzW4IVk2QE6ykGvxnMD0I64dQ/mNWhlFO6bYYWwegsbEsTX0fAnMG1Ijzp1G0nU5oNhNOnCukFw0YK2faDx6ohOJp5dDfVJk8IRQs2/kErIsaw65x/RlkYFDeimQR9wvSse+j6GbbxvUsuy8zMvpQdiPBTXHyNOzSy1hrZS4XrLB9cIjgT6ulBSQVCuEzUNap6CcRPYqN1wFAN3qZV9Aa4R3jtDNy7MWp0zteEj64R3S7wou+m9j3q7aVc0nhkuRhmcwQZxj4MUzuBfjHeyUDWhV3kdcpcTcyLto5vEXbbAengBNojoP7DbOAxi6JJllju1y/oyOzXsguIH2CJwMqWWEUQ3PcfT+aVj1mqNWRVXpP8tWMGBHcC8DNNnebcC62LHVMj5tomEiZhjU5uPjpXzX5FfxM6dUy+d7rO8ih86u3HCxzFWGuAG+HEi3la9GA4aU7STkD4X9Y6YzWCioRTRbtoHGXbYxkH4IdBRzrEj5T+DYtQi"}),r])}]]),o=JSON.parse('{"path":"/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","title":"设计模式前言：在 AI 时代重新掌握设计判断力","lang":"zh-CN","frontmatter":{"icon":"circle-info","date":"2026-01-16T00:00:00.000Z","category":["后端"],"tag":["设计模式","前言","方法论"],"description":"设计模式前言：在 AI 时代重新掌握设计判断力 AI 的发展让编码效率大幅提升，vibe coding 让“先跑起来”变得很容易。但效率不是全部，真正困难的是判断：什么样的设计是好的、什么时候该抽象、什么时候该简单。设计模式不是让我们拘泥于模板，而是帮助我们在“自由发挥”与“工程可靠”之间做出更清晰的选择。 为什么现在还要学设计模式 AI 能生成代码，...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"设计模式前言：在 AI 时代重新掌握设计判断力"}],["meta",{"property":"og:description","content":"设计模式前言：在 AI 时代重新掌握设计判断力 AI 的发展让编码效率大幅提升，vibe coding 让“先跑起来”变得很容易。但效率不是全部，真正困难的是判断：什么样的设计是好的、什么时候该抽象、什么时候该简单。设计模式不是让我们拘泥于模板，而是帮助我们在“自由发挥”与“工程可靠”之间做出更清晰的选择。 为什么现在还要学设计模式 AI 能生成代码，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-06T03:44:51.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"设计模式"}],["meta",{"property":"article:tag","content":"前言"}],["meta",{"property":"article:tag","content":"方法论"}],["meta",{"property":"article:published_time","content":"2026-01-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-06T03:44:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"设计模式前言：在 AI 时代重新掌握设计判断力\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-16T00:00:00.000Z\\",\\"dateModified\\":\\"2026-02-06T03:44:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"为什么现在还要学设计模式","slug":"为什么现在还要学设计模式","link":"#为什么现在还要学设计模式","children":[]},{"level":2,"title":"这套教程会怎么讲","slug":"这套教程会怎么讲","link":"#这套教程会怎么讲","children":[]},{"level":2,"title":"如何更高效地学习","slug":"如何更高效地学习","link":"#如何更高效地学习","children":[]},{"level":2,"title":"设计模式总览：从问题到选择的完整地图","slug":"设计模式总览-从问题到选择的完整地图","link":"#设计模式总览-从问题到选择的完整地图","children":[]},{"level":2,"title":"先把问题分成 3 大类","slug":"先把问题分成-3-大类","link":"#先把问题分成-3-大类","children":[]},{"level":2,"title":"快速选择路径（全模式）","slug":"快速选择路径-全模式","link":"#快速选择路径-全模式","children":[]},{"level":2,"title":"创建型模式（如何创建对象）","slug":"创建型模式-如何创建对象","link":"#创建型模式-如何创建对象","children":[]},{"level":2,"title":"结构型模式（如何组合对象）","slug":"结构型模式-如何组合对象","link":"#结构型模式-如何组合对象","children":[]},{"level":2,"title":"行为型模式（如何协作与变化）","slug":"行为型模式-如何协作与变化","link":"#行为型模式-如何协作与变化","children":[]},{"level":2,"title":"易混淆对比（全局视角）","slug":"易混淆对比-全局视角","link":"#易混淆对比-全局视角","children":[]},{"level":2,"title":"常见组合套路","slug":"常见组合套路","link":"#常见组合套路","children":[]},{"level":2,"title":"选择时的 5 条检查清单","slug":"选择时的-5-条检查清单","link":"#选择时的-5-条检查清单","children":[]},{"level":2,"title":"阅读建议（从常用到不常用）","slug":"阅读建议-从常用到不常用","link":"#阅读建议-从常用到不常用","children":[]},{"level":2,"title":"总览小结","slug":"总览小结","link":"#总览小结","children":[]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1768552389000,"updatedTime":1770349491000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":3}]},"readingTime":{"minutes":6.3,"words":1891},"filePathRelative":"设计模式/README.md","localizedDate":"2026年1月16日","excerpt":"\\n<p>AI 的发展让编码效率大幅提升，vibe coding 让“先跑起来”变得很容易。但效率不是全部，真正困难的是判断：什么样的设计是好的、什么时候该抽象、什么时候该简单。设计模式不是让我们拘泥于模板，而是帮助我们在“自由发挥”与“工程可靠”之间做出更清晰的选择。</p>\\n<hr>\\n<h2>为什么现在还要学设计模式</h2>\\n<ul>\\n<li>AI 能生成代码，但“正确的结构”需要人来判断。</li>\\n<li>好的设计依赖上下文与权衡，不是堆功能就能解决。</li>\\n<li>设计模式提供了一套稳定的语言和思考框架，便于沟通与复用。</li>\\n<li>有了模式意识，才能更好地评估 AI 输出：哪里该改，为什么要改。</li>\\n</ul>","autoDesc":true}')}}]);