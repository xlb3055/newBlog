"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[3345],{6262:(s,i)=>{i.A=(s,i)=>{const e=s.__vccOpts||s;for(const[s,a]of i)e[s]=a;return e}},4120:(s,i,e)=>{e.r(i),e.d(i,{comp:()=>t,data:()=>d});var a=e(641);const n=[(0,a.Fv)('<h1 id="redis内存碎片" tabindex="-1"><a class="header-anchor" href="#redis内存碎片"><span>Redis内存碎片</span></a></h1><p>Redis 是一个内存数据存储系统，它将数据完全加载到内存中以提高性能。然而，随着时间的推移和数据的不断变动，Redis 内部可能会出现内存碎片问题，导致内存利用效率低下。本文将详细讲解 Redis 内存碎片的概念、成因、查看和清理方法。</p><hr><h3 id="_1-什么是内存碎片" tabindex="-1"><a class="header-anchor" href="#_1-什么是内存碎片"><span>1. 什么是内存碎片？</span></a></h3><p><strong>内存碎片</strong>指的是内存中出现的未被完全利用的空间。当系统或应用程序分配和释放内存时，可能会导致内存块之间出现空隙，这些空隙无法被新数据填充，进而导致内存资源的浪费。对于 Redis 来说，内存碎片是指由于数据存储方式或内存分配机制问题，导致 Redis 实际使用的内存比数据本身占用的内存更多，产生了额外的内存占用。</p><p>Redis 中的内存碎片通常表现为以下几种情况：</p><ul><li><strong>内存块之间的空隙</strong>：当 Redis 需要分配内存时，它会根据数据的大小分配一块内存区域。如果释放的内存不连续，或者无法有效合并，空闲内存就会出现碎片。</li><li><strong>数据结构的变动</strong>：当 Redis 执行删除、更新或重新分配操作时，内存分配器（如 jemalloc）可能无法有效地复用先前分配的内存，从而造成碎片。</li></ul><hr><h3 id="_2-为什么会有-redis-内存碎片" tabindex="-1"><a class="header-anchor" href="#_2-为什么会有-redis-内存碎片"><span>2. 为什么会有 Redis 内存碎片？</span></a></h3><p>内存碎片的出现通常与以下几个因素有关：</p><h4 id="_2-1-内存分配策略" tabindex="-1"><a class="header-anchor" href="#_2-1-内存分配策略"><span>2.1 内存分配策略</span></a></h4><p>Redis 使用的内存分配器（如 jemalloc 或者 tcmalloc）是为了高效地管理内存资源，避免频繁的系统调用。但这些分配器在处理内存时，可能会导致以下几种碎片现象：</p><ul><li><strong>内部碎片</strong>：这是指内存块中存在的未使用空间。由于内存分配通常会按固定的块大小来分配，可能会造成分配的内存块有部分空间未被利用。</li><li><strong>外部碎片</strong>：指的是多个小的空闲内存块散布在整个内存区域，无法有效合并成一块大内存。</li></ul><h4 id="_2-2-数据类型的特性" tabindex="-1"><a class="header-anchor" href="#_2-2-数据类型的特性"><span>2.2 数据类型的特性</span></a></h4><p>Redis 支持多种数据类型（如字符串、列表、集合、哈希等），不同的数据结构在内存中的布局和存储方式不同，有时会导致内存碎片。例如，某些数据结构（如哈希表和集合）在元素增多时可能会触发内存重新分配，而这些分配可能无法完全利用内存，从而导致碎片。</p><h4 id="_2-3-持久化和复制" tabindex="-1"><a class="header-anchor" href="#_2-3-持久化和复制"><span>2.3 持久化和复制</span></a></h4><p>Redis 的持久化机制（如 RDB 和 AOF）需要在磁盘上保存数据。在进行持久化时，Redis 必须复制内存中的数据，这可能会导致内存重新分配，进而增加内存碎片。同时，如果启用了复制功能，Redis 会在多个节点之间同步数据，这也可能导致内存碎片的增加。</p><h4 id="_2-4-数据增删改操作" tabindex="-1"><a class="header-anchor" href="#_2-4-数据增删改操作"><span>2.4 数据增删改操作</span></a></h4><p>频繁的添加、删除和修改操作会引起 Redis 内存重新分配。例如，当删除大量小对象时，可能会在内存中留下碎片，无法被后续的数据填充。</p><hr><h3 id="_3-如何查看-redis-内存碎片的信息" tabindex="-1"><a class="header-anchor" href="#_3-如何查看-redis-内存碎片的信息"><span>3. 如何查看 Redis 内存碎片的信息？</span></a></h3><p>Redis 提供了几种命令来查看内存碎片的情况：</p><h4 id="_3-1-使用-info-memory-命令" tabindex="-1"><a class="header-anchor" href="#_3-1-使用-info-memory-命令"><span>3.1 使用 <code>INFO memory</code> 命令</span></a></h4><p><code>INFO memory</code> 命令可以查看 Redis 当前的内存使用情况，其中包含有关内存碎片的信息。该命令会返回类似以下的结果：</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> INFO</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> memory</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># Memory</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory:1000000</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory_human:1.00M</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory_rss:1200000</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory_rss_human:1.20M</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory_peak:1500000</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">used_memory_peak_human:1.50M</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">total_system_memory:8000000000</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">total_system_memory_human:8.00GB</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mem_fragmentation_ratio:1.20</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">mem_fragmentation_bytes:200000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>used_memory</strong>：Redis 实际使用的内存（包括所有数据和缓冲区的内存）。</li><li><strong>used_memory_rss</strong>：Redis 在操作系统中占用的内存（可能包括未使用的内存）。</li><li><strong>mem_fragmentation_ratio</strong>：内存碎片率（<code>used_memory_rss / used_memory</code>）。值大于 1 时，表示内存碎片存在，数值越大，碎片越严重。</li><li><strong>mem_fragmentation_bytes</strong>：内存碎片的字节数（即 <code>used_memory_rss - used_memory</code>）。</li></ul><h4 id="_3-2-使用-memory-stats-命令" tabindex="-1"><a class="header-anchor" href="#_3-2-使用-memory-stats-命令"><span>3.2 使用 <code>MEMORY STATS</code> 命令</span></a></h4><p><code>MEMORY STATS</code> 命令返回 Redis 内存的详细统计信息，包括内存碎片的详细情况。例如，返回内容中会显示关于不同类型内存的分配情况，帮助分析内存碎片的来源。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> MEMORY</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> STATS</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;allocator&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;jemalloc&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;allocator.active&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) (</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">integer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) 2048</span></span>\n<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这些命令，你可以清晰地看到当前 Redis 实例的内存碎片情况，并根据碎片比例调整 Redis 配置或采取其他优化措施。</p><hr><h3 id="_4-如何清理-redis-内存碎片" tabindex="-1"><a class="header-anchor" href="#_4-如何清理-redis-内存碎片"><span>4. 如何清理 Redis 内存碎片？</span></a></h3><p>内存碎片会影响 Redis 的性能和内存使用效率。以下是几种常见的清理内存碎片的方法：</p><h4 id="_4-1-重启-redis" tabindex="-1"><a class="header-anchor" href="#_4-1-重启-redis"><span>4.1 重启 Redis</span></a></h4><p>一种简单的方式是直接重启 Redis 实例。重启 Redis 会清空所有内存数据并重新分配内存，这样可以有效清理内存碎片。但这种方法有以下缺点：</p><ul><li>需要停机。</li><li>如果没有持久化配置（如 RDB 或 AOF），可能会丢失数据。</li></ul><h4 id="_4-2-使用-memory-purge-命令" tabindex="-1"><a class="header-anchor" href="#_4-2-使用-memory-purge-命令"><span>4.2 使用 <code>MEMORY PURGE</code> 命令</span></a></h4><p><code>MEMORY PURGE</code> 命令可以尝试通过手动调用来清理 Redis 中的内存碎片。这是 Redis 4.0 引入的命令，使用时不会导致 Redis 停机。这个命令会通过清理和释放空闲内存来减少内存碎片。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> redis-cli</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> MEMORY</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> PURGE</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_4-3-调整-redis-配置" tabindex="-1"><a class="header-anchor" href="#_4-3-调整-redis-配置"><span>4.3 调整 Redis 配置</span></a></h4><ul><li><strong>选择合适的内存分配器</strong>：Redis 支持多种内存分配器（如 jemalloc 和 tcmalloc）。不同的内存分配器对内存碎片的处理方式不同，可以根据具体情况选择合适的分配器。</li><li><strong>减少频繁的数据变动</strong>：通过优化 Redis 数据库操作，减少数据的频繁增删改操作，可以减少内存碎片的产生。</li></ul><h4 id="_4-4-调整-maxmemory-policy" tabindex="-1"><a class="header-anchor" href="#_4-4-调整-maxmemory-policy"><span>4.4 调整 <code>maxmemory-policy</code></span></a></h4><p>Redis 提供了 <code>maxmemory-policy</code> 配置项，用于限制 Redis 实例使用的最大内存。当 Redis 内存达到上限时，会触发内存淘汰策略。合适的淘汰策略能够在一定程度上减少内存碎片。</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">maxmemory-policy</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> allkeys-lru</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr>',45)],l={},t=(0,e(6262).A)(l,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,n)}]]),d=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87.html","title":"Redis内存碎片","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-12-01T00:00:00.000Z","category":["后端"],"tag":["Redis","数据库"],"description":"Redis内存碎片 Redis 是一个内存数据存储系统，它将数据完全加载到内存中以提高性能。然而，随着时间的推移和数据的不断变动，Redis 内部可能会出现内存碎片问题，导致内存利用效率低下。本文将详细讲解 Redis 内存碎片的概念、成因、查看和清理方法。 1. 什么是内存碎片？ 内存碎片指的是内存中出现的未被完全利用的空间。当系统或应用程序分配和释...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"Redis内存碎片"}],["meta",{"property":"og:description","content":"Redis内存碎片 Redis 是一个内存数据存储系统，它将数据完全加载到内存中以提高性能。然而，随着时间的推移和数据的不断变动，Redis 内部可能会出现内存碎片问题，导致内存利用效率低下。本文将详细讲解 Redis 内存碎片的概念、成因、查看和清理方法。 1. 什么是内存碎片？ 内存碎片指的是内存中出现的未被完全利用的空间。当系统或应用程序分配和释..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-12-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis内存碎片\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-01T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":3,"title":"1. 什么是内存碎片？","slug":"_1-什么是内存碎片","link":"#_1-什么是内存碎片","children":[]},{"level":3,"title":"2. 为什么会有 Redis 内存碎片？","slug":"_2-为什么会有-redis-内存碎片","link":"#_2-为什么会有-redis-内存碎片","children":[]},{"level":3,"title":"3. 如何查看 Redis 内存碎片的信息？","slug":"_3-如何查看-redis-内存碎片的信息","link":"#_3-如何查看-redis-内存碎片的信息","children":[]},{"level":3,"title":"4. 如何清理 Redis 内存碎片？","slug":"_4-如何清理-redis-内存碎片","link":"#_4-如何清理-redis-内存碎片","children":[]}],"git":{"createdTime":1733145681000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":5.23,"words":1570},"filePathRelative":"Java八股/数据库/Redis/重要知识点/Redis内存碎片.md","localizedDate":"2024年12月1日","excerpt":"\\n<p>Redis 是一个内存数据存储系统，它将数据完全加载到内存中以提高性能。然而，随着时间的推移和数据的不断变动，Redis 内部可能会出现内存碎片问题，导致内存利用效率低下。本文将详细讲解 Redis 内存碎片的概念、成因、查看和清理方法。</p>\\n<hr>\\n<h3>1. 什么是内存碎片？</h3>\\n<p><strong>内存碎片</strong>指的是内存中出现的未被完全利用的空间。当系统或应用程序分配和释放内存时，可能会导致内存块之间出现空隙，这些空隙无法被新数据填充，进而导致内存资源的浪费。对于 Redis 来说，内存碎片是指由于数据存储方式或内存分配机制问题，导致 Redis 实际使用的内存比数据本身占用的内存更多，产生了额外的内存占用。</p>","autoDesc":true}')}}]);