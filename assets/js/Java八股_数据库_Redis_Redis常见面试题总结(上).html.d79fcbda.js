"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[7969],{6262:(i,s)=>{s.A=(i,s)=>{const e=i.__vccOpts||i;for(const[i,t]of s)e[i]=t;return e}},7364:(i,s,e)=>{e.r(s),e.d(s,{comp:()=>r,data:()=>a});var t=e(641);const l=[(0,t.Fv)('<h1 id="redis常见面试题总结-上" tabindex="-1"><a class="header-anchor" href="#redis常见面试题总结-上"><span>Redis常见面试题总结(上)</span></a></h1><hr><h2 id="_1-redis-基础" tabindex="-1"><a class="header-anchor" href="#_1-redis-基础"><span><strong>1. Redis 基础</strong></span></a></h2><h3 id="_1-1-什么是-redis" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是-redis"><span><strong>1.1 什么是 Redis？</strong></span></a></h3><p>Redis 是一个开源的 <strong>高性能分布式内存数据库</strong>，支持多种数据结构，用于缓存、消息队列、分布式锁、实时统计等。</p><p><strong>回答方式</strong>：Redis 是内存型数据库，它的核心特性是高性能和多数据结构支持。</p><hr><h3 id="_1-2-redis-为什么这么快" tabindex="-1"><a class="header-anchor" href="#_1-2-redis-为什么这么快"><span><strong>1.2 Redis 为什么这么快？</strong></span></a></h3><ol><li><strong>数据存储在内存</strong>： <ul><li>读写操作在内存中完成，访问速度快。</li></ul></li><li><strong>单线程模型</strong>： <ul><li>避免了多线程的上下文切换和锁竞争。</li></ul></li><li><strong>高效数据结构</strong>： <ul><li>使用优化后的跳表、哈希表等数据结构。</li></ul></li><li><strong>I/O 多路复用</strong>： <ul><li>基于 <code>epoll</code> 的非阻塞 I/O 模型，同时处理大量请求。</li></ul></li></ol><p><strong>示例</strong>：</p><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" data-title="plaintext" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>传统数据库：磁盘读取速度慢，且受 I/O 阻塞影响。</span></span>\n<span class="line"><span>Redis：所有数据在内存中，读写可以达到百万级 QPS。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-3-redis-和-memcached-的区别" tabindex="-1"><a class="header-anchor" href="#_1-3-redis-和-memcached-的区别"><span><strong>1.3 Redis 和 Memcached 的区别</strong></span></a></h3><p><strong>共同点</strong>：</p><ul><li>都是内存型数据库，主要用于缓存。</li><li>都支持高性能读写。</li></ul><p><strong>区别</strong>：</p><table><thead><tr><th>特性</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td><strong>数据类型</strong></td><td>多种（String、Hash、List、Set 等）</td><td>仅支持 String</td></tr><tr><td><strong>持久化</strong></td><td>支持（RDB 和 AOF）</td><td>不支持</td></tr><tr><td><strong>线程模型</strong></td><td>单线程为主（6.0+ 支持部分多线程）</td><td>多线程</td></tr><tr><td><strong>内存管理</strong></td><td>LRU 淘汰策略，适合复杂场景</td><td>使用 Slab 分配，适合简单缓存</td></tr><tr><td><strong>功能丰富性</strong></td><td>支持分布式锁、消息队列等高级功能</td><td>功能相对简单</td></tr></tbody></table><p><strong>回答方式</strong>：Redis 和 Memcached 都是优秀的缓存解决方案，但 Redis 更适合多样化场景。</p><hr><h3 id="_1-4-为什么要用-redis" tabindex="-1"><a class="header-anchor" href="#_1-4-为什么要用-redis"><span><strong>1.4 为什么要用 Redis？</strong></span></a></h3><ol><li><strong>性能高</strong>： <ul><li>QPS 达到 10 万级别。</li></ul></li><li><strong>功能丰富</strong>： <ul><li>支持复杂数据结构。</li></ul></li><li><strong>生态完善</strong>： <ul><li>支持分布式锁、延时任务、排行榜等高级功能。</li></ul></li><li><strong>应用场景多样</strong>： <ul><li>缓存、会话存储、实时数据分析。</li></ul></li></ol><hr><h3 id="_1-5-常见的缓存策略" tabindex="-1"><a class="header-anchor" href="#_1-5-常见的缓存策略"><span><strong>1.5 常见的缓存策略</strong></span></a></h3><ol><li><p><strong>Cache Aside（旁路缓存）</strong>：</p><ul><li><strong>读流程</strong>：先查缓存，未命中则查数据库并回写缓存。</li><li><strong>写流程</strong>：先更新数据库，再删除缓存。</li></ul><p><strong>示例</strong>：</p><div class="language-plaintext line-numbers-mode" data-highlighter="shiki" data-ext="plaintext" data-title="plaintext" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>用户请求商品详情：</span></span>\n<span class="line"><span>1. 查 Redis 缓存（命中则返回）。</span></span>\n<span class="line"><span>2. 未命中：查 MySQL 数据库，将结果写入 Redis。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>Write Through（写穿缓存）</strong>：</p><ul><li>数据写入时同时更新缓存和数据库。</li></ul></li><li><p><strong>Write Back（写回缓存）</strong>：</p><ul><li>数据先写入缓存，后台异步更新数据库。</li></ul></li></ol><hr><h2 id="_2-redis-应用" tabindex="-1"><a class="header-anchor" href="#_2-redis-应用"><span><strong>2. Redis 应用</strong></span></a></h2><h3 id="_2-1-redis-除了缓存-还能做什么" tabindex="-1"><a class="header-anchor" href="#_2-1-redis-除了缓存-还能做什么"><span><strong>2.1 Redis 除了缓存，还能做什么？</strong></span></a></h3><ol><li><strong>分布式锁</strong>：使用 <code>SETNX</code> 和 <code>EX</code>。</li><li><strong>延时任务</strong>：基于 <code>ZSET</code> 存储任务和时间戳。</li><li><strong>消息队列</strong>：用 <code>List</code> 实现生产者-消费者模型。</li><li><strong>实时统计</strong>：使用 <code>HyperLogLog</code> 或 <code>Bitmap</code> 统计活跃用户、UV。</li></ol><hr><h3 id="_2-2-如何实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_2-2-如何实现分布式锁"><span><strong>2.2 如何实现分布式锁？</strong></span></a></h3><p>使用 <code>SETNX</code> 实现分布式锁：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SETNX</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> lock_key</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> EX</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  # 尝试获取锁，设置过期时间为 10 秒</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>解锁操作</strong>：</p><ol><li>检查当前锁是否为自己持有（<code>GET</code>）。</li><li>确认后删除锁（<code>DEL</code>）。</li></ol><p><strong>面试官关注点</strong>：</p><ul><li><strong>优点</strong>：原子操作，简单高效。</li><li><strong>难点</strong>：锁过期续约，防止死锁。</li></ul><hr><h3 id="_2-3-redis-可以做消息队列么" tabindex="-1"><a class="header-anchor" href="#_2-3-redis-可以做消息队列么"><span><strong>2.3 Redis 可以做消息队列么？</strong></span></a></h3><ul><li><strong>使用 List 实现</strong>： <ul><li><strong>生产者</strong>：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">LPUSH</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> queue_key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;message&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>消费者</strong>：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RPOP</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> queue_key</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li></ul><p><strong>优点</strong>：易实现、高性能。</p><p><strong>缺点</strong>：无法保证严格的消息顺序（解决方法：用 Stream）。</p><hr><h3 id="_2-4-如何基于-redis-实现延时任务" tabindex="-1"><a class="header-anchor" href="#_2-4-如何基于-redis-实现延时任务"><span><strong>2.4 如何基于 Redis 实现延时任务？</strong></span></a></h3><p>使用 <strong>ZSET</strong> 存储任务和时间戳：</p><ol><li>添加任务：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZADD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> delay_tasks</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1680000000</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;task1&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li>获取到期任务：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZRANGEBYSCORE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> delay_tasks</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> CURRENT_TIMESTAMP</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><p><strong>场景</strong>：</p><ul><li>订单支付超时提醒。</li><li>定时清理无效数据。</li></ul><hr><h2 id="_3-redis-数据类型" tabindex="-1"><a class="header-anchor" href="#_3-redis-数据类型"><span><strong>3. Redis 数据类型</strong></span></a></h2><h3 id="_3-1-数据类型及场景" tabindex="-1"><a class="header-anchor" href="#_3-1-数据类型及场景"><span><strong>3.1 数据类型及场景</strong></span></a></h3><table><thead><tr><th>数据类型</th><th><strong>应用场景</strong></th></tr></thead><tbody><tr><td>String</td><td>缓存单值，计数器，分布式锁</td></tr><tr><td>Hash</td><td>存储对象数据，减少内存占用</td></tr><tr><td>List</td><td>消息队列、链表存储</td></tr><tr><td>Set</td><td>标签筛选、抽奖</td></tr><tr><td>ZSet</td><td>排行榜、延时任务</td></tr></tbody></table><hr><h3 id="_3-2-使用-redis-实现排行榜" tabindex="-1"><a class="header-anchor" href="#_3-2-使用-redis-实现排行榜"><span><strong>3.2 使用 Redis 实现排行榜</strong></span></a></h3><p>使用 <strong>ZSET</strong> 存储用户和分数：</p><ol><li><strong>添加分数</strong>：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZADD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> leaderboard</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Alice&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZADD</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> leaderboard</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 200</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;Bob&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>获取排行榜</strong>：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ZREVRANGE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> leaderboard</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 9</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> WITHSCORES</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><hr><h2 id="_4-redis-持久化机制" tabindex="-1"><a class="header-anchor" href="#_4-redis-持久化机制"><span><strong>4. Redis 持久化机制</strong></span></a></h2><h3 id="_4-1-redis-的持久化方式" tabindex="-1"><a class="header-anchor" href="#_4-1-redis-的持久化方式"><span><strong>4.1 Redis 的持久化方式</strong></span></a></h3><ol><li><p><strong>RDB（快照）</strong>：</p><ul><li>定期将内存快照保存到磁盘。</li><li><strong>优点</strong>：占用资源少。</li><li><strong>缺点</strong>：数据可能丢失。</li></ul></li><li><p><strong>AOF（日志）</strong>：</p><ul><li>记录每个写操作。</li><li><strong>优点</strong>：更可靠。</li><li><strong>缺点</strong>：磁盘 I/O 多。</li></ul></li></ol><p><strong>面试官喜欢的总结</strong>：</p><ul><li><strong>高性能场景</strong>：只用 RDB。</li><li><strong>高可靠性场景</strong>：同时开启 RDB 和 AOF。</li></ul><hr><h2 id="_5-redis-线程模型" tabindex="-1"><a class="header-anchor" href="#_5-redis-线程模型"><span><strong>5. Redis 线程模型</strong></span></a></h2><h3 id="_5-1-redis-单线程模型" tabindex="-1"><a class="header-anchor" href="#_5-1-redis-单线程模型"><span><strong>5.1 Redis 单线程模型</strong></span></a></h3><p>Redis 使用单线程处理请求，避免了锁竞争，提高并发性能。</p><p><strong>回答方式</strong>：Redis 是单线程，但依赖高效的事件循环模型（如 <code>epoll</code>）。</p><hr><h3 id="_5-2-为什么引入多线程" tabindex="-1"><a class="header-anchor" href="#_5-2-为什么引入多线程"><span><strong>5.2 为什么引入多线程？</strong></span></a></h3><p>Redis 6.0 后支持多线程，用于处理网络 I/O 和数据压缩，但核心逻辑仍是单线程。</p><hr><h2 id="_6-redis-内存管理" tabindex="-1"><a class="header-anchor" href="#_6-redis-内存管理"><span><strong>6. Redis 内存管理</strong></span></a></h2><h3 id="_6-1-redis-如何判断数据过期" tabindex="-1"><a class="header-anchor" href="#_6-1-redis-如何判断数据过期"><span><strong>6.1 Redis 如何判断数据过期？</strong></span></a></h3><ol><li><strong>被动删除</strong>：访问键时检查是否过期。</li><li><strong>定期删除</strong>：每隔一段时间随机抽取部分键检查。</li></ol><hr><h3 id="_6-2-redis-的内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#_6-2-redis-的内存淘汰策略"><span><strong>6.2 Redis 的内存淘汰策略</strong></span></a></h3><ol><li><strong>volatile-lru</strong>：淘汰设置过期时间的键中最近最少使用的。</li><li><strong>allkeys-lru</strong>：淘汰所有键中最近最少使用的。</li><li><strong>noeviction</strong>：禁止淘汰，写入失败。</li></ol><hr><h3 id="_6-3-面试官喜欢的总结" tabindex="-1"><a class="header-anchor" href="#_6-3-面试官喜欢的总结"><span><strong>6.3 面试官喜欢的总结</strong></span></a></h3><ul><li><strong>核心问题</strong>：如何管理内存，避免 OOM（内存溢出）。</li><li><strong>优化建议</strong>： <ul><li>设置合理的过期时间。</li><li>使用 LRU 淘汰策略。</li></ul></li></ul><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h2><ol><li><strong>Redis 基础</strong>：高性能的内存数据库，支持多种数据结构。</li><li><strong>Redis 应用</strong>：分布式锁、消息队列、排行榜、延时任务等。</li><li><strong>数据类型与场景</strong>：不同类型对应不同应用，善用特性。</li><li><strong>持久化与线程模型</strong>：理解 RDB、AOF 的优缺点，掌握单线程优势。</li><li><strong>内存管理</strong>：过期策略和淘汰策略是面试高频问题。</li></ol>',82)],n={},r=(0,e(6262).A)(n,[["render",function(i,s){return(0,t.uX)(),(0,t.CE)("div",null,l)}]]),a=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E4%B8%8A).html","title":"Redis常见面试题总结(上)","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-23T00:00:00.000Z","category":["后端"],"tag":["Redis","数据库"],"description":"Redis常见面试题总结(上) 1. Redis 基础 1.1 什么是 Redis？ Redis 是一个开源的 高性能分布式内存数据库，支持多种数据结构，用于缓存、消息队列、分布式锁、实时统计等。 回答方式：Redis 是内存型数据库，它的核心特性是高性能和多数据结构支持。 1.2 Redis 为什么这么快？ 数据存储在内存： 读写操作在内存中完成，访...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93(%E4%B8%8A).html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"Redis常见面试题总结(上)"}],["meta",{"property":"og:description","content":"Redis常见面试题总结(上) 1. Redis 基础 1.1 什么是 Redis？ Redis 是一个开源的 高性能分布式内存数据库，支持多种数据结构，用于缓存、消息队列、分布式锁、实时统计等。 回答方式：Redis 是内存型数据库，它的核心特性是高性能和多数据结构支持。 1.2 Redis 为什么这么快？ 数据存储在内存： 读写操作在内存中完成，访..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-11-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis常见面试题总结(上)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"1. Redis 基础","slug":"_1-redis-基础","link":"#_1-redis-基础","children":[{"level":3,"title":"1.1 什么是 Redis？","slug":"_1-1-什么是-redis","link":"#_1-1-什么是-redis","children":[]},{"level":3,"title":"1.2 Redis 为什么这么快？","slug":"_1-2-redis-为什么这么快","link":"#_1-2-redis-为什么这么快","children":[]},{"level":3,"title":"1.3 Redis 和 Memcached 的区别","slug":"_1-3-redis-和-memcached-的区别","link":"#_1-3-redis-和-memcached-的区别","children":[]},{"level":3,"title":"1.4 为什么要用 Redis？","slug":"_1-4-为什么要用-redis","link":"#_1-4-为什么要用-redis","children":[]},{"level":3,"title":"1.5 常见的缓存策略","slug":"_1-5-常见的缓存策略","link":"#_1-5-常见的缓存策略","children":[]}]},{"level":2,"title":"2. Redis 应用","slug":"_2-redis-应用","link":"#_2-redis-应用","children":[{"level":3,"title":"2.1 Redis 除了缓存，还能做什么？","slug":"_2-1-redis-除了缓存-还能做什么","link":"#_2-1-redis-除了缓存-还能做什么","children":[]},{"level":3,"title":"2.2 如何实现分布式锁？","slug":"_2-2-如何实现分布式锁","link":"#_2-2-如何实现分布式锁","children":[]},{"level":3,"title":"2.3 Redis 可以做消息队列么？","slug":"_2-3-redis-可以做消息队列么","link":"#_2-3-redis-可以做消息队列么","children":[]},{"level":3,"title":"2.4 如何基于 Redis 实现延时任务？","slug":"_2-4-如何基于-redis-实现延时任务","link":"#_2-4-如何基于-redis-实现延时任务","children":[]}]},{"level":2,"title":"3. Redis 数据类型","slug":"_3-redis-数据类型","link":"#_3-redis-数据类型","children":[{"level":3,"title":"3.1 数据类型及场景","slug":"_3-1-数据类型及场景","link":"#_3-1-数据类型及场景","children":[]},{"level":3,"title":"3.2 使用 Redis 实现排行榜","slug":"_3-2-使用-redis-实现排行榜","link":"#_3-2-使用-redis-实现排行榜","children":[]}]},{"level":2,"title":"4. Redis 持久化机制","slug":"_4-redis-持久化机制","link":"#_4-redis-持久化机制","children":[{"level":3,"title":"4.1 Redis 的持久化方式","slug":"_4-1-redis-的持久化方式","link":"#_4-1-redis-的持久化方式","children":[]}]},{"level":2,"title":"5. Redis 线程模型","slug":"_5-redis-线程模型","link":"#_5-redis-线程模型","children":[{"level":3,"title":"5.1 Redis 单线程模型","slug":"_5-1-redis-单线程模型","link":"#_5-1-redis-单线程模型","children":[]},{"level":3,"title":"5.2 为什么引入多线程？","slug":"_5-2-为什么引入多线程","link":"#_5-2-为什么引入多线程","children":[]}]},{"level":2,"title":"6. Redis 内存管理","slug":"_6-redis-内存管理","link":"#_6-redis-内存管理","children":[{"level":3,"title":"6.1 Redis 如何判断数据过期？","slug":"_6-1-redis-如何判断数据过期","link":"#_6-1-redis-如何判断数据过期","children":[]},{"level":3,"title":"6.2 Redis 的内存淘汰策略","slug":"_6-2-redis-的内存淘汰策略","link":"#_6-2-redis-的内存淘汰策略","children":[]},{"level":3,"title":"6.3 面试官喜欢的总结","slug":"_6-3-面试官喜欢的总结","link":"#_6-3-面试官喜欢的总结","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1733029796000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":4.91,"words":1472},"filePathRelative":"Java八股/数据库/Redis/Redis常见面试题总结(上).md","localizedDate":"2024年11月23日","excerpt":"\\n<hr>\\n<h2><strong>1. Redis 基础</strong></h2>\\n<h3><strong>1.1 什么是 Redis？</strong></h3>\\n<p>Redis 是一个开源的 <strong>高性能分布式内存数据库</strong>，支持多种数据结构，用于缓存、消息队列、分布式锁、实时统计等。</p>\\n<p><strong>回答方式</strong>：Redis 是内存型数据库，它的核心特性是高性能和多数据结构支持。</p>\\n<hr>\\n<h3><strong>1.2 Redis 为什么这么快？</strong></h3>\\n<ol>\\n<li><strong>数据存储在内存</strong>：\\n<ul>\\n<li>读写操作在内存中完成，访问速度快。</li>\\n</ul>\\n</li>\\n<li><strong>单线程模型</strong>：\\n<ul>\\n<li>避免了多线程的上下文切换和锁竞争。</li>\\n</ul>\\n</li>\\n<li><strong>高效数据结构</strong>：\\n<ul>\\n<li>使用优化后的跳表、哈希表等数据结构。</li>\\n</ul>\\n</li>\\n<li><strong>I/O 多路复用</strong>：\\n<ul>\\n<li>基于 <code>epoll</code> 的非阻塞 I/O 模型，同时处理大量请求。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);