"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[36],{6262:(i,s)=>{s.A=(i,s)=>{const l=i.__vccOpts||i;for(const[i,e]of s)l[i]=e;return l}},5871:(i,s,l)=>{l.r(s),l.d(s,{comp:()=>n,data:()=>h});var e=l(641);const a=[(0,e.Fv)('<h1 id="mysql查询缓存详解" tabindex="-1"><a class="header-anchor" href="#mysql查询缓存详解"><span>MySQL查询缓存详解</span></a></h1><hr><h2 id="_1-mysql-查询缓存介绍" tabindex="-1"><a class="header-anchor" href="#_1-mysql-查询缓存介绍"><span><strong>1. MySQL 查询缓存介绍</strong></span></a></h2><h3 id="_1-1-什么是查询缓存" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是查询缓存"><span><strong>1.1 什么是查询缓存？</strong></span></a></h3><p>MySQL 查询缓存（Query Cache）是将 <strong>SELECT 查询结果</strong> 存储在内存中，以便相同的查询可以直接返回缓存结果，而无需再次执行。</p><ul><li><strong>缓存内容</strong>：查询的结果集。</li><li><strong>核心作用</strong>：加速查询性能，减少数据库的计算开销。</li></ul><hr><h3 id="_1-2-查询缓存适用的场景" tabindex="-1"><a class="header-anchor" href="#_1-2-查询缓存适用的场景"><span><strong>1.2 查询缓存适用的场景</strong></span></a></h3><ul><li><strong>高频查询</strong>：相同的查询语句多次执行且数据变化较少。</li><li><strong>只读场景</strong>：例如报表系统、查询频繁更新少的业务场景。</li></ul><hr><h2 id="_2-mysql-查询缓存管理和配置" tabindex="-1"><a class="header-anchor" href="#_2-mysql-查询缓存管理和配置"><span><strong>2. MySQL 查询缓存管理和配置</strong></span></a></h2><h3 id="_2-1-查询缓存的相关参数" tabindex="-1"><a class="header-anchor" href="#_2-1-查询缓存的相关参数"><span><strong>2.1 查询缓存的相关参数</strong></span></a></h3><ol><li><p><strong>query_cache_size</strong>：</p><ul><li>设置查询缓存的总大小。</li><li>示例：<code>SET GLOBAL query_cache_size = 1048576;</code>（1MB 缓存）</li></ul></li><li><p><strong>query_cache_type</strong>：</p><ul><li><p>控制查询缓存是否启用。</p><ul><li><code>0</code>（OFF）：关闭查询缓存。</li><li><code>1</code>（ON）：默认开启查询缓存。</li><li><code>2</code>（DEMAND）：按需缓存，仅当查询语句中显式指定 <code>SQL_CACHE</code> 时缓存。</li></ul></li><li><p>示例：<code>SET GLOBAL query_cache_type = 1;</code></p></li></ul></li><li><p><strong>query_cache_limit</strong>：</p><ul><li>指定单个查询可以缓存的最大结果集大小。</li><li>示例：<code>SET GLOBAL query_cache_limit = 1048576;</code>（1MB）</li></ul></li><li><p><strong>query_cache_min_res_unit</strong>：</p><ul><li>缓存块的最小分配单位。默认为 4096 字节。</li></ul></li></ol><hr><h3 id="_2-2-查询缓存的开启与禁用" tabindex="-1"><a class="header-anchor" href="#_2-2-查询缓存的开启与禁用"><span><strong>2.2 查询缓存的开启与禁用</strong></span></a></h3><ol><li><p><strong>查看查询缓存状态</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SHOW VARIABLES </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">LIKE</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;query_cache%&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong>开启查询缓存</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> GLOBAL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> query_cache_size </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1048576</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 设置查询缓存大小</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> GLOBAL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> query_cache_type </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 开启查询缓存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>禁用查询缓存</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> GLOBAL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> query_cache_type </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 禁用查询缓存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><hr><h3 id="_2-3-显式使用或跳过查询缓存" tabindex="-1"><a class="header-anchor" href="#_2-3-显式使用或跳过查询缓存"><span><strong>2.3 显式使用或跳过查询缓存</strong></span></a></h3><ul><li><p>使用缓存：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SQL_CACHE * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p>跳过缓存：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SQL_NO_CACHE * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><hr><h2 id="_3-mysql-缓存机制" tabindex="-1"><a class="header-anchor" href="#_3-mysql-缓存机制"><span><strong>3. MySQL 缓存机制</strong></span></a></h2><h3 id="_3-1-查询缓存的工作流程" tabindex="-1"><a class="header-anchor" href="#_3-1-查询缓存的工作流程"><span><strong>3.1 查询缓存的工作流程</strong></span></a></h3><ol><li><p><strong>检查缓存</strong>：</p><ul><li>查询语句在执行前，先检查是否命中查询缓存。</li><li>如果命中，直接返回结果；否则进入下一步。</li></ul></li><li><p><strong>执行查询</strong>：</p><ul><li>如果缓存未命中，MySQL 执行查询语句并生成结果集。</li></ul></li><li><p><strong>存储缓存</strong>：</p><ul><li>查询结果集存入缓存区域，供后续相同查询使用。</li></ul></li></ol><hr><h3 id="_3-2-查询缓存规则" tabindex="-1"><a class="header-anchor" href="#_3-2-查询缓存规则"><span><strong>3.2 查询缓存规则</strong></span></a></h3><ol><li><p><strong>语句完全相同</strong>：</p><ul><li>只有当查询语句完全相同时（包括大小写、空格），才会命中缓存。</li><li>示例：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 可命中缓存</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> users </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 无法命中</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>表未更新</strong>：</p><ul><li>只要查询涉及的表发生了更新、插入或删除，相关缓存会立即失效。</li></ul></li><li><p><strong>与用户权限相关</strong>：</p><ul><li>如果查询涉及用户权限，MySQL 会为每个用户缓存单独的结果集。</li></ul></li><li><p><strong>无法缓存的情况</strong>：</p><ul><li>查询包含非确定性函数（如 <code>NOW()</code>、<code>RAND()</code>）。</li><li>查询包含用户变量或临时表。</li><li>查询包含 <code>LOCK</code> 或 <code>FOR UPDATE</code>。</li></ul></li></ol><hr><h2 id="_4-缓存机制中的内存管理" tabindex="-1"><a class="header-anchor" href="#_4-缓存机制中的内存管理"><span><strong>4. 缓存机制中的内存管理</strong></span></a></h2><ol><li><p><strong>内存分配策略</strong>：</p><ul><li>查询缓存分为多个内存块，每个块存储一个查询结果。</li><li>如果一个查询的结果集大小超过 <code>query_cache_limit</code>，则该查询不会被缓存。</li></ul></li><li><p><strong>内存清理</strong>：</p><ul><li>当缓存满时，MySQL 会清除不常使用的缓存结果（LRU 策略）。</li></ul></li><li><p><strong>缓存碎片问题</strong>：</p><ul><li>缓存碎片会导致内存利用率下降，影响性能。</li><li>通过 <code>FLUSH QUERY CACHE</code> 清理碎片并整理内存。</li></ul></li></ol><hr><h2 id="_5-mysql-查询缓存的优缺点" tabindex="-1"><a class="header-anchor" href="#_5-mysql-查询缓存的优缺点"><span><strong>5. MySQL 查询缓存的优缺点</strong></span></a></h2><h3 id="_5-1-优点" tabindex="-1"><a class="header-anchor" href="#_5-1-优点"><span><strong>5.1 优点</strong></span></a></h3><ol><li><strong>加速查询</strong>： <ul><li>对于相同的查询，直接返回缓存结果，避免重复执行。</li></ul></li><li><strong>减少 I/O</strong>： <ul><li>缓存结果存储在内存中，减少磁盘访问。</li></ul></li><li><strong>降低 CPU 负载</strong>： <ul><li>重复查询不需要再次解析、优化和执行。</li></ul></li></ol><hr><h3 id="_5-2-缺点" tabindex="-1"><a class="header-anchor" href="#_5-2-缺点"><span><strong>5.2 缺点</strong></span></a></h3><ol><li><strong>缓存失效频繁</strong>： <ul><li>表数据更新会导致相关缓存失效，不适合频繁写入场景。</li></ul></li><li><strong>缓存命中条件严格</strong>： <ul><li>查询语句必须完全相同，稍有不同就无法命中。</li></ul></li><li><strong>额外开销</strong>： <ul><li>需要维护查询缓存，带来内存和 CPU 开销。</li></ul></li><li><strong>缓存碎片问题</strong>： <ul><li>内存碎片会影响缓存的效率，需要定期清理。</li></ul></li></ol><hr><h2 id="_6-mysql-查询缓存对性能的影响" tabindex="-1"><a class="header-anchor" href="#_6-mysql-查询缓存对性能的影响"><span><strong>6. MySQL 查询缓存对性能的影响</strong></span></a></h2><h3 id="_6-1-适用场景" tabindex="-1"><a class="header-anchor" href="#_6-1-适用场景"><span><strong>6.1 适用场景</strong></span></a></h3><ul><li><strong>高频相同查询，低写入频率</strong>： <ul><li>如报表查询、查询用户统计等。</li></ul></li></ul><h3 id="_6-2-不适用场景" tabindex="-1"><a class="header-anchor" href="#_6-2-不适用场景"><span><strong>6.2 不适用场景</strong></span></a></h3><ul><li><strong>频繁更新的表</strong>： <ul><li>写操作会使缓存失效，频繁更新导致缓存无意义。</li></ul></li></ul><h3 id="_6-3-性能优化建议" tabindex="-1"><a class="header-anchor" href="#_6-3-性能优化建议"><span><strong>6.3 性能优化建议</strong></span></a></h3><ol><li><strong>按需开启缓存</strong>： <ul><li>使用 <code>query_cache_type = DEMAND</code>，仅对需要的查询启用缓存。</li></ul></li><li><strong>合理配置参数</strong>： <ul><li>根据查询特点调整 <code>query_cache_size</code> 和 <code>query_cache_limit</code>。</li></ul></li><li><strong>避免缓存碎片</strong>： <ul><li>定期使用 <code>FLUSH QUERY CACHE</code> 清理碎片。</li></ul></li></ol><hr><h2 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结"><span><strong>7. 总结</strong></span></a></h2><ol><li><p><strong>查询缓存的核心目标</strong>：</p><ul><li>提高查询性能，减少重复查询带来的开销。</li></ul></li><li><p><strong>关键点</strong>：</p><ul><li>查询语句必须完全相同才能命中缓存。</li><li>表的更新操作会使相关缓存失效。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>查询缓存已在 MySQL 8.0 中被废弃，建议根据业务场景合理使用或选择替代方案（如应用层缓存）。</li></ul></li></ol><hr>',48)],t={},n=(0,l(6262).A)(t,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,a)}]]),h=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3.html","title":"MySQL查询缓存详解","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-23T00:00:00.000Z","category":["后端"],"tag":["MySQL","数据库"],"description":"MySQL查询缓存详解 1. MySQL 查询缓存介绍 1.1 什么是查询缓存？ MySQL 查询缓存（Query Cache）是将 SELECT 查询结果 存储在内存中，以便相同的查询可以直接返回缓存结果，而无需再次执行。 缓存内容：查询的结果集。 核心作用：加速查询性能，减少数据库的计算开销。 1.2 查询缓存适用的场景 高频查询：相同的查询语句多...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/MySQL%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"MySQL查询缓存详解"}],["meta",{"property":"og:description","content":"MySQL查询缓存详解 1. MySQL 查询缓存介绍 1.1 什么是查询缓存？ MySQL 查询缓存（Query Cache）是将 SELECT 查询结果 存储在内存中，以便相同的查询可以直接返回缓存结果，而无需再次执行。 缓存内容：查询的结果集。 核心作用：加速查询性能，减少数据库的计算开销。 1.2 查询缓存适用的场景 高频查询：相同的查询语句多..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-11-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL查询缓存详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"1. MySQL 查询缓存介绍","slug":"_1-mysql-查询缓存介绍","link":"#_1-mysql-查询缓存介绍","children":[{"level":3,"title":"1.1 什么是查询缓存？","slug":"_1-1-什么是查询缓存","link":"#_1-1-什么是查询缓存","children":[]},{"level":3,"title":"1.2 查询缓存适用的场景","slug":"_1-2-查询缓存适用的场景","link":"#_1-2-查询缓存适用的场景","children":[]}]},{"level":2,"title":"2. MySQL 查询缓存管理和配置","slug":"_2-mysql-查询缓存管理和配置","link":"#_2-mysql-查询缓存管理和配置","children":[{"level":3,"title":"2.1 查询缓存的相关参数","slug":"_2-1-查询缓存的相关参数","link":"#_2-1-查询缓存的相关参数","children":[]},{"level":3,"title":"2.2 查询缓存的开启与禁用","slug":"_2-2-查询缓存的开启与禁用","link":"#_2-2-查询缓存的开启与禁用","children":[]},{"level":3,"title":"2.3 显式使用或跳过查询缓存","slug":"_2-3-显式使用或跳过查询缓存","link":"#_2-3-显式使用或跳过查询缓存","children":[]}]},{"level":2,"title":"3. MySQL 缓存机制","slug":"_3-mysql-缓存机制","link":"#_3-mysql-缓存机制","children":[{"level":3,"title":"3.1 查询缓存的工作流程","slug":"_3-1-查询缓存的工作流程","link":"#_3-1-查询缓存的工作流程","children":[]},{"level":3,"title":"3.2 查询缓存规则","slug":"_3-2-查询缓存规则","link":"#_3-2-查询缓存规则","children":[]}]},{"level":2,"title":"4. 缓存机制中的内存管理","slug":"_4-缓存机制中的内存管理","link":"#_4-缓存机制中的内存管理","children":[]},{"level":2,"title":"5. MySQL 查询缓存的优缺点","slug":"_5-mysql-查询缓存的优缺点","link":"#_5-mysql-查询缓存的优缺点","children":[{"level":3,"title":"5.1 优点","slug":"_5-1-优点","link":"#_5-1-优点","children":[]},{"level":3,"title":"5.2 缺点","slug":"_5-2-缺点","link":"#_5-2-缺点","children":[]}]},{"level":2,"title":"6. MySQL 查询缓存对性能的影响","slug":"_6-mysql-查询缓存对性能的影响","link":"#_6-mysql-查询缓存对性能的影响","children":[{"level":3,"title":"6.1 适用场景","slug":"_6-1-适用场景","link":"#_6-1-适用场景","children":[]},{"level":3,"title":"6.2 不适用场景","slug":"_6-2-不适用场景","link":"#_6-2-不适用场景","children":[]},{"level":3,"title":"6.3 性能优化建议","slug":"_6-3-性能优化建议","link":"#_6-3-性能优化建议","children":[]}]},{"level":2,"title":"7. 总结","slug":"_7-总结","link":"#_7-总结","children":[]}],"git":{"createdTime":1733029796000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":4.19,"words":1256},"filePathRelative":"Java八股/数据库/MySQL/重要知识点/MySQL查询缓存详解.md","localizedDate":"2024年11月23日","excerpt":"\\n<hr>\\n<h2><strong>1. MySQL 查询缓存介绍</strong></h2>\\n<h3><strong>1.1 什么是查询缓存？</strong></h3>\\n<p>MySQL 查询缓存（Query Cache）是将 <strong>SELECT 查询结果</strong> 存储在内存中，以便相同的查询可以直接返回缓存结果，而无需再次执行。</p>\\n<ul>\\n<li><strong>缓存内容</strong>：查询的结果集。</li>\\n<li><strong>核心作用</strong>：加速查询性能，减少数据库的计算开销。</li>\\n</ul>\\n<hr>\\n<h3><strong>1.2 查询缓存适用的场景</strong></h3>","autoDesc":true}')}}]);