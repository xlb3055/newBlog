"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[41],{66262:(i,l)=>{l.A=(i,l)=>{const t=i.__vccOpts||i;for(const[i,e]of l)t[i]=e;return t}},81677:(i,l,t)=>{t.r(l),t.d(l,{comp:()=>a,data:()=>r});var e=t(20641);const s=[(0,e.Fv)('<h1 id="mysql日期类型" tabindex="-1"><a class="header-anchor" href="#mysql日期类型"><span>MySQL日期类型</span></a></h1><hr><h2 id="_1-不要用字符串存储日期" tabindex="-1"><a class="header-anchor" href="#_1-不要用字符串存储日期"><span><strong>1. 不要用字符串存储日期</strong></span></a></h2><h3 id="_1-1-为什么不能用字符串存储日期" tabindex="-1"><a class="header-anchor" href="#_1-1-为什么不能用字符串存储日期"><span><strong>1.1 为什么不能用字符串存储日期？</strong></span></a></h3><ol><li><p><strong>数据校验问题</strong>：</p><ul><li>使用字符串存储无法保证数据格式的正确性。</li><li>示例：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders (order_date) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;2023-13-01&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 不合法的日期</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p><strong>存储效率低</strong>：</p><ul><li>日期类型比字符串类型占用更少的存储空间。 <ul><li><code>DATETIME</code>：8 字节。</li><li>字符串（<code>CHAR(19)</code>）：19 字节。</li></ul></li></ul></li><li><p><strong>查询效率低</strong>：</p><ul><li>字符串存储无法利用日期函数进行高效操作（如排序、范围查询）。</li></ul></li><li><p><strong>不易操作</strong>：</p><ul><li>日期字段可以直接使用 <code>DATE</code>、<code>TIME</code> 函数，而字符串需要先解析后操作。</li></ul></li></ol><hr><h2 id="_2-datetime-和-timestamp-的抉择" tabindex="-1"><a class="header-anchor" href="#_2-datetime-和-timestamp-的抉择"><span><strong>2. DATETIME 和 TIMESTAMP 的抉择</strong></span></a></h2><h3 id="_2-1-timestamp" tabindex="-1"><a class="header-anchor" href="#_2-1-timestamp"><span><strong>2.1 TIMESTAMP</strong></span></a></h3><ul><li><p><strong>特点</strong>：</p><ol><li><strong>包含时区信息</strong>： <ul><li>数据在存储时会根据当前时区自动转换为 UTC。</li><li>数据在查询时会根据时区转换为本地时间。</li></ul></li><li><strong>占用空间小</strong>：占用 4 字节。</li><li><strong>表示范围小</strong>： <ul><li>范围：<code>1970-01-01 00:00:01</code> 到 <code>2038-01-19 03:14:07</code>。</li><li>超过范围会报错。</li></ul></li></ol></li><li><p><strong>适用场景</strong>：</p><ul><li>需要存储与时区相关的时间（如记录用户行为日志）。</li><li>数据量大，存储空间有限。</li></ul></li></ul><hr><h3 id="_2-2-datetime" tabindex="-1"><a class="header-anchor" href="#_2-2-datetime"><span><strong>2.2 DATETIME</strong></span></a></h3><ul><li><p><strong>特点</strong>：</p><ol><li><strong>不包含时区信息</strong>： <ul><li>存储的是绝对时间，无时区转换。</li></ul></li><li><strong>占用空间大</strong>：占用 8 字节。</li><li><strong>表示范围大</strong>： <ul><li>范围：<code>1000-01-01 00:00:00</code> 到 <code>9999-12-31 23:59:59</code>。</li></ul></li><li><strong>易于理解</strong>： <ul><li>数据直接存储，不受时区影响。</li></ul></li></ol></li><li><p><strong>适用场景</strong>：</p><ul><li>不需要考虑时区的场景（如事件的绝对时间）。</li><li>需要存储超出 <code>TIMESTAMP</code> 范围的时间（如历史数据）。</li></ul></li></ul><hr><h3 id="_2-3-二者对比" tabindex="-1"><a class="header-anchor" href="#_2-3-二者对比"><span><strong>2.3 二者对比</strong></span></a></h3><table><thead><tr><th>特性</th><th>TIMESTAMP</th><th>DATETIME</th></tr></thead><tbody><tr><td><strong>时区支持</strong></td><td>自动转换</td><td>无时区转换</td></tr><tr><td><strong>存储空间</strong></td><td>4 字节</td><td>8 字节</td></tr><tr><td><strong>表示范围</strong></td><td>1970 ~ 2038</td><td>1000 ~ 9999</td></tr><tr><td><strong>查询性能</strong></td><td>较快</td><td>较慢</td></tr><tr><td><strong>适用场景</strong></td><td>时区敏感场景</td><td>时区无关或超大范围数据</td></tr></tbody></table><hr><h2 id="_3-数值时间戳是更好的选择吗" tabindex="-1"><a class="header-anchor" href="#_3-数值时间戳是更好的选择吗"><span><strong>3. 数值时间戳是更好的选择吗？</strong></span></a></h2><p>数值时间戳指使用整数类型（如 <code>BIGINT</code>）存储时间的 UNIX 时间戳（从 <code>1970-01-01 00:00:00</code> 开始的秒数或毫秒数）。</p><h3 id="_3-1-优点" tabindex="-1"><a class="header-anchor" href="#_3-1-优点"><span><strong>3.1 优点</strong></span></a></h3><ol><li><p><strong>存储效率高</strong>：</p><ul><li>UNIX 时间戳使用 4 或 8 字节存储，适合存储大批量数据。</li></ul></li><li><p><strong>无需时区转换</strong>：</p><ul><li>纯粹的绝对时间，无需考虑时区问题。</li></ul></li><li><p><strong>计算方便</strong>：</p><ul><li>可以直接进行加减运算（如加一天 <code>+86400</code>）。</li></ul></li></ol><hr><h3 id="_3-2-缺点" tabindex="-1"><a class="header-anchor" href="#_3-2-缺点"><span><strong>3.2 缺点</strong></span></a></h3><ol><li><p><strong>可读性差</strong>：</p><ul><li>UNIX 时间戳不直观，需要通过函数解析。</li><li>示例：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> FROM_UNIXTIME(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1672531200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 转换为 &#39;2023-01-01 00:00:00&#39;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><p><strong>日期范围有限</strong>：</p><ul><li>与 <code>TIMESTAMP</code> 一样，范围有限（1970 ~ 2038）。</li></ul></li><li><p><strong>缺少内置日期操作支持</strong>：</p><ul><li>无法直接使用 MySQL 的日期函数。</li></ul></li></ol><hr><h3 id="_3-3-是否选择数值时间戳" tabindex="-1"><a class="header-anchor" href="#_3-3-是否选择数值时间戳"><span><strong>3.3 是否选择数值时间戳？</strong></span></a></h3><ul><li><p><strong>适用场景</strong>：</p><ul><li>数据量非常大，对存储和查询效率有极高要求。</li><li>仅需简单的时间计算，无需复杂的日期操作。</li></ul></li><li><p><strong>不适用场景</strong>：</p><ul><li>数据需要频繁进行日期计算或操作。</li><li>数据的可读性要求较高。</li></ul></li></ul><hr><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结"><span><strong>4. 总结</strong></span></a></h2><h3 id="_4-1-使用-datetime-的场景" tabindex="-1"><a class="header-anchor" href="#_4-1-使用-datetime-的场景"><span><strong>4.1 使用 DATETIME 的场景</strong></span></a></h3><ol><li>需要存储超出 <code>2038</code> 年的时间。</li><li>时间与时区无关。</li><li>数据量适中，对存储效率要求不高。</li></ol><h3 id="_4-2-使用-timestamp-的场景" tabindex="-1"><a class="header-anchor" href="#_4-2-使用-timestamp-的场景"><span><strong>4.2 使用 TIMESTAMP 的场景</strong></span></a></h3><ol><li>数据需要考虑时区转换。</li><li>数据量大，存储空间有限。</li><li>时间范围在 <code>1970-2038</code> 之间。</li></ol><h3 id="_4-3-使用数值时间戳的场景" tabindex="-1"><a class="header-anchor" href="#_4-3-使用数值时间戳的场景"><span><strong>4.3 使用数值时间戳的场景</strong></span></a></h3><ol><li>数据量巨大，对存储和性能要求极高。</li><li>时间仅需简单的加减计算。</li></ol><hr><h3 id="推荐做法" tabindex="-1"><a class="header-anchor" href="#推荐做法"><span><strong>推荐做法</strong></span></a></h3><ol><li><p><strong>绝大多数场景：DATETIME + TIMESTAMP 搭配使用</strong></p><ul><li>使用 <code>DATETIME</code> 表示不随时区变化的时间（如事件发生的绝对时间）。</li><li>使用 <code>TIMESTAMP</code> 表示随时区变化的时间（如记录日志时间）。</li></ul></li><li><p><strong>性能优化场景：数值时间戳</strong></p><ul><li>在需要极致性能和简化存储时使用。</li></ul></li><li><p><strong>数据库设计原则</strong></p><ul><li>根据业务需求选择合适的时间类型，避免滥用字符串存储时间。</li><li>合理设置时区，确保时间的一致性。</li></ul></li></ol>',37)],n={},a=(0,t(66262).A)(n,[["render",function(i,l){return(0,e.uX)(),(0,e.CE)("div",null,s)}]]),r=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/MySQL%20%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B.html","title":"MySQL日期类型","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-23T00:00:00.000Z","category":["后端"],"tag":["MySQL","数据库"],"description":"MySQL日期类型 1. 不要用字符串存储日期 1.1 为什么不能用字符串存储日期？ 数据校验问题： 使用字符串存储无法保证数据格式的正确性。 示例： 存储效率低： 日期类型比字符串类型占用更少的存储空间。 DATETIME：8 字节。 字符串（CHAR(19)）：19 字节。 查询效率低： 字符串存储无法利用日期函数进行高效操作（如排序、范围查询）。...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/MySQL%20%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"MySQL日期类型"}],["meta",{"property":"og:description","content":"MySQL日期类型 1. 不要用字符串存储日期 1.1 为什么不能用字符串存储日期？ 数据校验问题： 使用字符串存储无法保证数据格式的正确性。 示例： 存储效率低： 日期类型比字符串类型占用更少的存储空间。 DATETIME：8 字节。 字符串（CHAR(19)）：19 字节。 查询效率低： 字符串存储无法利用日期函数进行高效操作（如排序、范围查询）。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-11-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL日期类型\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"1. 不要用字符串存储日期","slug":"_1-不要用字符串存储日期","link":"#_1-不要用字符串存储日期","children":[{"level":3,"title":"1.1 为什么不能用字符串存储日期？","slug":"_1-1-为什么不能用字符串存储日期","link":"#_1-1-为什么不能用字符串存储日期","children":[]}]},{"level":2,"title":"2. DATETIME 和 TIMESTAMP 的抉择","slug":"_2-datetime-和-timestamp-的抉择","link":"#_2-datetime-和-timestamp-的抉择","children":[{"level":3,"title":"2.1 TIMESTAMP","slug":"_2-1-timestamp","link":"#_2-1-timestamp","children":[]},{"level":3,"title":"2.2 DATETIME","slug":"_2-2-datetime","link":"#_2-2-datetime","children":[]},{"level":3,"title":"2.3 二者对比","slug":"_2-3-二者对比","link":"#_2-3-二者对比","children":[]}]},{"level":2,"title":"3. 数值时间戳是更好的选择吗？","slug":"_3-数值时间戳是更好的选择吗","link":"#_3-数值时间戳是更好的选择吗","children":[{"level":3,"title":"3.1 优点","slug":"_3-1-优点","link":"#_3-1-优点","children":[]},{"level":3,"title":"3.2 缺点","slug":"_3-2-缺点","link":"#_3-2-缺点","children":[]},{"level":3,"title":"3.3 是否选择数值时间戳？","slug":"_3-3-是否选择数值时间戳","link":"#_3-3-是否选择数值时间戳","children":[]}]},{"level":2,"title":"4. 总结","slug":"_4-总结","link":"#_4-总结","children":[{"level":3,"title":"4.1 使用 DATETIME 的场景","slug":"_4-1-使用-datetime-的场景","link":"#_4-1-使用-datetime-的场景","children":[]},{"level":3,"title":"4.2 使用 TIMESTAMP 的场景","slug":"_4-2-使用-timestamp-的场景","link":"#_4-2-使用-timestamp-的场景","children":[]},{"level":3,"title":"4.3 使用数值时间戳的场景","slug":"_4-3-使用数值时间戳的场景","link":"#_4-3-使用数值时间戳的场景","children":[]},{"level":3,"title":"推荐做法","slug":"推荐做法","link":"#推荐做法","children":[]}]}],"git":{"createdTime":1733029796000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":3.48,"words":1043},"filePathRelative":"Java八股/数据库/MySQL/重要知识点/MySQL 日期类型.md","localizedDate":"2024年11月23日","excerpt":"\\n<hr>\\n<h2><strong>1. 不要用字符串存储日期</strong></h2>\\n<h3><strong>1.1 为什么不能用字符串存储日期？</strong></h3>\\n<ol>\\n<li>\\n<p><strong>数据校验问题</strong>：</p>\\n<ul>\\n<li>使用字符串存储无法保证数据格式的正确性。</li>\\n<li>示例：<div class=\\"language-sql line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"sql\\" data-title=\\"sql\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">INSERT INTO</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> orders (order_date) </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">VALUES</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> (</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\">\'2023-13-01\'</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">); </span><span style=\\"--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic\\">-- 不合法的日期</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div></li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>存储效率低</strong>：</p>\\n<ul>\\n<li>日期类型比字符串类型占用更少的存储空间。\\n<ul>\\n<li><code>DATETIME</code>：8 字节。</li>\\n<li>字符串（<code>CHAR(19)</code>）：19 字节。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>查询效率低</strong>：</p>\\n<ul>\\n<li>字符串存储无法利用日期函数进行高效操作（如排序、范围查询）。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>不易操作</strong>：</p>\\n<ul>\\n<li>日期字段可以直接使用 <code>DATE</code>、<code>TIME</code> 函数，而字符串需要先解析后操作。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);