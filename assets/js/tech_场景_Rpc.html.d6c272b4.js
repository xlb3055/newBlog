"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[2812],{66262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}},80310:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>n,data:()=>h});var e=a(20641);const l=[(0,e.Fv)('<h1 id="如果让我们设计一个-rpc-框架-我们会怎么做" tabindex="-1"><a class="header-anchor" href="#如果让我们设计一个-rpc-框架-我们会怎么做"><span>如果让我们设计一个 RPC 框架，我们会怎么做？</span></a></h1><hr><h2 id="前言-什么是-rpc-为啥要它" tabindex="-1"><a class="header-anchor" href="#前言-什么是-rpc-为啥要它"><span>前言：什么是 RPC？为啥要它？</span></a></h2><p>先打个比方：</p><p>我们去餐厅点菜，只负责“点”，不关心厨师怎么做、厨房在哪。我们说：“要一份麻辣烫”，然后等着吃。</p><p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 就像这样：</p><ul><li>我们是客户端</li><li>餐厅是服务器</li><li>厨房逻辑封装好了</li><li>我们用“本地方式”发出“远程请求”，结果返回到我们手里</li></ul><p>一句话理解：RPC 让我们像调用本地函数一样，去调用另一台服务器上的服务。</p><hr><h2 id="面试官要我们设计一个-rpc-框架-他想看什么" tabindex="-1"><a class="header-anchor" href="#面试官要我们设计一个-rpc-框架-他想看什么"><span>面试官要我们设计一个 RPC 框架，他想看什么？</span></a></h2><p>面试官并不指望我们造一个「阿里 Dubbo」，而是考我们：</p><ul><li>懂不懂调用链流程？</li><li>知不知道服务注册、调用、返回里有什么坑？</li><li>能不能把复杂的系统拆成模块说清楚？</li></ul><hr><h2 id="一个简单-rpc-框架-需要有哪些模块" tabindex="-1"><a class="header-anchor" href="#一个简单-rpc-框架-需要有哪些模块"><span>一个简单 RPC 框架，需要有哪些模块？</span></a></h2><p>我们来对标快递流程：</p><table><thead><tr><th>模块</th><th>对应快递场景</th><th>功能说明</th></tr></thead><tbody><tr><td>服务注册中心</td><td>菜鸟驿站</td><td>记录服务在哪里（ip+端口）</td></tr><tr><td>客户端代理</td><td>快递代寄点</td><td>我们不走到厨房也能点菜</td></tr><tr><td>网络传输层</td><td>快递小哥</td><td>把调用打包送到服务端</td></tr><tr><td>编解码（序列化）</td><td>快递打包箱 + 拆箱</td><td>对象转字节流，传输后还原</td></tr><tr><td>负载均衡模块</td><td>多个厨师，选谁做菜？</td><td>服务实例很多时怎么选</td></tr><tr><td>服务端处理器</td><td>厨房</td><td>真正执行函数逻辑</td></tr></tbody></table><hr><h2 id="分步骤详细实现讲解" tabindex="-1"><a class="header-anchor" href="#分步骤详细实现讲解"><span>分步骤详细实现讲解</span></a></h2><h3 id="第-1-步-接口定义-说清楚我们要做什么" tabindex="-1"><a class="header-anchor" href="#第-1-步-接口定义-说清楚我们要做什么"><span>第 1 步：接口定义（说清楚我们要做什么）</span></a></h3><p>双方必须约定接口，不然我们喊“来份麻辣烫”，后厨不知道配料表。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> UserService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    User</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> getUserById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Long</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> id</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="第-2-步-服务注册中心" tabindex="-1"><a class="header-anchor" href="#第-2-步-服务注册中心"><span>第 2 步：服务注册中心</span></a></h3><ul><li>假设我们用 Nacos/Zookeeper 来注册服务</li><li>服务启动时上报自身地址：<code>192.168.1.10:8001</code></li><li>客户端拉取服务列表做调用</li></ul><p>注册中心就是<strong>服务的通讯录</strong>。</p><hr><h3 id="第-3-步-代理层-让本地调用看起来像远程调用" tabindex="-1"><a class="header-anchor" href="#第-3-步-代理层-让本地调用看起来像远程调用"><span>第 3 步：代理层（让本地调用看起来像远程调用）</span></a></h3><p>JDK 动态代理机制：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">UserService</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> userService </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> RpcClient</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getProxy</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">UserService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">userService</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getUserById</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1L</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // 看起来像本地，其实底层发起远程请求</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们点“getUserById”，其实内部：</p><ul><li>构造一个 RPC 请求对象</li><li>序列化成字节流</li><li>网络发送给服务端</li><li>等服务端返回结果</li></ul><hr><h3 id="第-4-步-序列化传输" tabindex="-1"><a class="header-anchor" href="#第-4-步-序列化传输"><span>第 4 步：序列化传输</span></a></h3><p>Java 对象在 JVM 里不能直接过网线，要序列化。</p><p>我们推荐：</p><ul><li>Protobuf（二进制高性能）</li><li>JSON（人类友好但慢）</li><li>Kryo（比 Java 序列化快）</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">[] data </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> serializer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">serialize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(request);</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Request</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> req </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> serializer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">deserialize</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(data, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Request</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="第-5-步-通信层-发送数据" tabindex="-1"><a class="header-anchor" href="#第-5-步-通信层-发送数据"><span>第 5 步：通信层（发送数据）</span></a></h3><p>我们需要：</p><ul><li>客户端建立连接（Netty 或 Socket）</li><li>服务端监听端口接收请求</li></ul><p>客户端代码（伪代码）：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Socket</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> socket </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Socket</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(serverIp</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> port)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">socket</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getOutputStream</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(data);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端代码监听接收、解码、执行方法并返回。</p><hr><h3 id="第-6-步-协议设计-发什么内容" tabindex="-1"><a class="header-anchor" href="#第-6-步-协议设计-发什么内容"><span>第 6 步：协议设计（发什么内容？）</span></a></h3><p>一个 RPC 协议包，建议这样设计：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>+------------+----------+-------------+--------+</span></span>\n<span class="line"><span>| 魔数 4字节 | 类型 1字节 | 请求ID 8字节 | 数据体 |</span></span>\n<span class="line"><span>+------------+----------+-------------+--------+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样方便调试、扩展和解析。</p><hr><h3 id="第-7-步-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#第-7-步-负载均衡策略"><span>第 7 步：负载均衡策略</span></a></h3><p>假设注册中心有多个实例：</p><ul><li><code>192.168.1.10:8001</code></li><li><code>192.168.1.11:8001</code></li><li><code>192.168.1.12:8001</code></li></ul><p>怎么选？</p><ul><li>随机：Random</li><li>轮询：RoundRobin</li><li>一致性哈希：ConsistentHash</li></ul><p>写个简单轮询类：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RoundRobinLoadBalancer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> AtomicInteger</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> index </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> AtomicInteger</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> String</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">List</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt; </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">servers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> servers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getAndIncrement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">%</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> servers</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="一次调用全过程回顾" tabindex="-1"><a class="header-anchor" href="#一次调用全过程回顾"><span>一次调用全过程回顾</span></a></h2><ol><li>用户调用代理对象 <code>userService.getUserById(1)</code></li><li>代理将请求封装成 Request 对象</li><li>使用 Protobuf 序列化请求</li><li>Netty 客户端将数据发送</li><li>服务端接收到数据后解码</li><li>找到目标方法并执行</li><li>将结果序列化并返回给客户端</li><li>客户端反序列化成 User 对象返回</li></ol><hr><h2 id="工程里的关键补充点" tabindex="-1"><a class="header-anchor" href="#工程里的关键补充点"><span>工程里的关键补充点</span></a></h2><h3 id="超时与重试策略" tabindex="-1"><a class="header-anchor" href="#超时与重试策略"><span>超时与重试策略</span></a></h3><p>RPC 最怕的不是失败，而是“卡住”。我们通常会明确：</p><ul><li>客户端设置超时上限，避免线程被拖死</li><li>只对幂等接口重试，非幂等接口采用业务去重</li><li>超时与重试要配合熔断，避免雪崩</li></ul><h3 id="连接与线程模型" tabindex="-1"><a class="header-anchor" href="#连接与线程模型"><span>连接与线程模型</span></a></h3><ul><li>客户端使用连接池与复用，避免频繁建连</li><li>服务端区分 IO 线程与业务线程，避免 IO 被重活阻塞</li></ul><h3 id="版本兼容与灰度" tabindex="-1"><a class="header-anchor" href="#版本兼容与灰度"><span>版本兼容与灰度</span></a></h3><ul><li>协议里带版本号</li><li>字段尽量向后兼容（新增字段可选，不要直接删除）</li><li>灰度发布时保证旧客户端还能正常解析</li></ul><h3 id="服务治理与可观测性" tabindex="-1"><a class="header-anchor" href="#服务治理与可观测性"><span>服务治理与可观测性</span></a></h3><ul><li>调用链追踪（traceId）贯穿全链路</li><li>核心指标：QPS、RT、错误率、超时率</li><li>降级策略要可配置，避免“全挂”</li></ul><h3 id="安全与边界" tabindex="-1"><a class="header-anchor" href="#安全与边界"><span>安全与边界</span></a></h3><ul><li>内网 RPC 也要鉴权，避免横向滥用</li><li>只暴露必要接口，避免通用执行能力</li></ul><hr>',74)],t={},n=(0,a(66262).A)(t,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,l)}]]),h=JSON.parse('{"path":"/tech/%E5%9C%BA%E6%99%AF/Rpc.html","title":"如果让我们设计一个 RPC 框架，我们会怎么做？","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-08T00:00:00.000Z","category":["后端"],"tag":["Java","面试","场景"],"description":"如果让我们设计一个 RPC 框架，我们会怎么做？ 前言：什么是 RPC？为啥要它？ 先打个比方： 我们去餐厅点菜，只负责“点”，不关心厨师怎么做、厨房在哪。我们说：“要一份麻辣烫”，然后等着吃。 RPC（Remote Procedure Call，远程过程调用） 就像这样： 我们是客户端 餐厅是服务器 厨房逻辑封装好了 我们用“本地方式”发出“远程请求...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/tech/%E5%9C%BA%E6%99%AF/Rpc.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"如果让我们设计一个 RPC 框架，我们会怎么做？"}],["meta",{"property":"og:description","content":"如果让我们设计一个 RPC 框架，我们会怎么做？ 前言：什么是 RPC？为啥要它？ 先打个比方： 我们去餐厅点菜，只负责“点”，不关心厨师怎么做、厨房在哪。我们说：“要一份麻辣烫”，然后等着吃。 RPC（Remote Procedure Call，远程过程调用） 就像这样： 我们是客户端 餐厅是服务器 厨房逻辑封装好了 我们用“本地方式”发出“远程请求..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-21T09:06:17.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"场景"}],["meta",{"property":"article:published_time","content":"2025-07-08T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-21T09:06:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如果让我们设计一个 RPC 框架，我们会怎么做？\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-08T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-21T09:06:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"前言：什么是 RPC？为啥要它？","slug":"前言-什么是-rpc-为啥要它","link":"#前言-什么是-rpc-为啥要它","children":[]},{"level":2,"title":"面试官要我们设计一个 RPC 框架，他想看什么？","slug":"面试官要我们设计一个-rpc-框架-他想看什么","link":"#面试官要我们设计一个-rpc-框架-他想看什么","children":[]},{"level":2,"title":"一个简单 RPC 框架，需要有哪些模块？","slug":"一个简单-rpc-框架-需要有哪些模块","link":"#一个简单-rpc-框架-需要有哪些模块","children":[]},{"level":2,"title":"分步骤详细实现讲解","slug":"分步骤详细实现讲解","link":"#分步骤详细实现讲解","children":[{"level":3,"title":"第 1 步：接口定义（说清楚我们要做什么）","slug":"第-1-步-接口定义-说清楚我们要做什么","link":"#第-1-步-接口定义-说清楚我们要做什么","children":[]},{"level":3,"title":"第 2 步：服务注册中心","slug":"第-2-步-服务注册中心","link":"#第-2-步-服务注册中心","children":[]},{"level":3,"title":"第 3 步：代理层（让本地调用看起来像远程调用）","slug":"第-3-步-代理层-让本地调用看起来像远程调用","link":"#第-3-步-代理层-让本地调用看起来像远程调用","children":[]},{"level":3,"title":"第 4 步：序列化传输","slug":"第-4-步-序列化传输","link":"#第-4-步-序列化传输","children":[]},{"level":3,"title":"第 5 步：通信层（发送数据）","slug":"第-5-步-通信层-发送数据","link":"#第-5-步-通信层-发送数据","children":[]},{"level":3,"title":"第 6 步：协议设计（发什么内容？）","slug":"第-6-步-协议设计-发什么内容","link":"#第-6-步-协议设计-发什么内容","children":[]},{"level":3,"title":"第 7 步：负载均衡策略","slug":"第-7-步-负载均衡策略","link":"#第-7-步-负载均衡策略","children":[]}]},{"level":2,"title":"一次调用全过程回顾","slug":"一次调用全过程回顾","link":"#一次调用全过程回顾","children":[]},{"level":2,"title":"工程里的关键补充点","slug":"工程里的关键补充点","link":"#工程里的关键补充点","children":[{"level":3,"title":"超时与重试策略","slug":"超时与重试策略","link":"#超时与重试策略","children":[]},{"level":3,"title":"连接与线程模型","slug":"连接与线程模型","link":"#连接与线程模型","children":[]},{"level":3,"title":"版本兼容与灰度","slug":"版本兼容与灰度","link":"#版本兼容与灰度","children":[]},{"level":3,"title":"服务治理与可观测性","slug":"服务治理与可观测性","link":"#服务治理与可观测性","children":[]},{"level":3,"title":"安全与边界","slug":"安全与边界","link":"#安全与边界","children":[]}]}],"git":{"createdTime":1752053793000,"updatedTime":1768986377000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":3}]},"readingTime":{"minutes":4.1,"words":1229},"filePathRelative":"tech/场景/Rpc.md","localizedDate":"2025年7月8日","excerpt":"\\n<hr>\\n<h2>前言：什么是 RPC？为啥要它？</h2>\\n<p>先打个比方：</p>\\n<p>我们去餐厅点菜，只负责“点”，不关心厨师怎么做、厨房在哪。我们说：“要一份麻辣烫”，然后等着吃。</p>\\n<p><strong>RPC（Remote Procedure Call，远程过程调用）</strong> 就像这样：</p>\\n<ul>\\n<li>我们是客户端</li>\\n<li>餐厅是服务器</li>\\n<li>厨房逻辑封装好了</li>\\n<li>我们用“本地方式”发出“远程请求”，结果返回到我们手里</li>\\n</ul>\\n<p>一句话理解：RPC 让我们像调用本地函数一样，去调用另一台服务器上的服务。</p>","autoDesc":true}')}}]);