"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[4261],{66262:(e,a)=>{a.A=(e,a)=>{const l=e.__vccOpts||e;for(const[e,i]of a)l[e]=i;return l}},61881:(e,a,l)=>{l.r(a),l.d(a,{comp:()=>s,data:()=>r});var i=l(20641);const t=[(0,i.Fv)('<h1 id="从零开始讲清如何设计一个消息队列系统-mq-通俗易懂、细节到位" tabindex="-1"><a class="header-anchor" href="#从零开始讲清如何设计一个消息队列系统-mq-通俗易懂、细节到位"><span>从零开始讲清如何设计一个消息队列系统（MQ）：通俗易懂、细节到位</span></a></h1><hr><h2 id="什么是消息队列-一句话说清楚" tabindex="-1"><a class="header-anchor" href="#什么是消息队列-一句话说清楚"><span>什么是消息队列？一句话说清楚</span></a></h2><blockquote><p>消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。</p></blockquote><p>它负责把“消息”从发送方（生产者）<strong>传递</strong>到接收方（消费者）—— 而且还能：</p><ul><li>保证不会丢件（消息不丢失）</li><li>顺序到达（支持顺序消费）</li><li>如果收件人晚点来也没关系（异步解耦）</li></ul><h3 id="举个例子" tabindex="-1"><a class="header-anchor" href="#举个例子"><span>举个例子：</span></a></h3><p>淘宝订单支付成功后，会发生很多事：</p><ul><li>给我们发短信</li><li>给仓库发发货请求</li><li>给商家发账单</li></ul><p>但我们点完“支付”并不需要等这些操作都做完才能返回页面，这就靠了消息队列：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>支付系统 -&gt; 发一条“支付成功”的消息 -&gt; 各方系统慢慢接收处理</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h2 id="面试题-我们来设计一个-mq-系统-该怎么说" tabindex="-1"><a class="header-anchor" href="#面试题-我们来设计一个-mq-系统-该怎么说"><span>面试题：我们来设计一个 MQ 系统，该怎么说？</span></a></h2><h3 id="一定要从这4个维度入手" tabindex="-1"><a class="header-anchor" href="#一定要从这4个维度入手"><span>一定要从这4个维度入手：</span></a></h3><table><thead><tr><th>设计模块</th><th>职责</th><th>我们要考虑的点</th></tr></thead><tbody><tr><td>Producer</td><td>生产消息</td><td>发送是否成功？是否重复？</td></tr><tr><td>Broker</td><td>消息中转站</td><td>怎么存？能不能丢？顺序？</td></tr><tr><td>Consumer</td><td>消费者</td><td>怎么消费？是否重复？</td></tr><tr><td>Registry</td><td>注册中心</td><td>谁在哪？怎么发现彼此？</td></tr></tbody></table><hr><h2 id="系统流程全图" tabindex="-1"><a class="header-anchor" href="#系统流程全图"><span>系统流程全图</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>[Producer] -&gt; [Broker] -&gt; [Consumer]</span></span>\n<span class="line"><span>                   ^</span></span>\n<span class="line"><span>              [Registry]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="我们逐个拆开讲" tabindex="-1"><a class="header-anchor" href="#我们逐个拆开讲"><span>我们逐个拆开讲：</span></a></h2><hr><h2 id="producer-怎么把消息送出去" tabindex="-1"><a class="header-anchor" href="#producer-怎么把消息送出去"><span>Producer：怎么把消息送出去？</span></a></h2><blockquote><p>它是消息的生产者，像做菜的一方。</p></blockquote><h3 id="要实现的功能" tabindex="-1"><a class="header-anchor" href="#要实现的功能"><span>要实现的功能：</span></a></h3><ul><li>能把一条消息发送到 Broker</li><li>要知道消息有没有成功送达（ack）</li><li>要支持“重发但不重复”</li></ul><h3 id="设计要点" tabindex="-1"><a class="header-anchor" href="#设计要点"><span>设计要点：</span></a></h3><ul><li>使用 TCP（Netty）建立连接</li><li>发完后等待 broker 返回 ACK</li><li>如果超时，自动重试（保证“最终送达”）</li></ul><hr><h2 id="broker-消息的中转站-核心" tabindex="-1"><a class="header-anchor" href="#broker-消息的中转站-核心"><span>Broker：消息的中转站（核心）</span></a></h2><blockquote><p>消息队列的“心脏”，设计重点全在这！</p></blockquote><h3 id="它要做-5-件事" tabindex="-1"><a class="header-anchor" href="#它要做-5-件事"><span>它要做 5 件事：</span></a></h3><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>接收消息</td><td>接收来自 Producer 的消息</td></tr><tr><td>缓存消息</td><td>先写入内存队列，快速暂存</td></tr><tr><td>持久化存储</td><td>写入磁盘，确保断电不丢</td></tr><tr><td>分发消息</td><td>把消息发送给消费者</td></tr><tr><td>管理消费进度</td><td>记录哪个消息被谁读了</td></tr></tbody></table><hr><h2 id="消息存储设计-broker-里" tabindex="-1"><a class="header-anchor" href="#消息存储设计-broker-里"><span>消息存储设计（Broker 里）</span></a></h2><p>可以模仿 Kafka 的设计：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/store/</span></span>\n<span class="line"><span>  ├── topicA/</span></span>\n<span class="line"><span>  │     ├── log-0001.data</span></span>\n<span class="line"><span>  │     └── log-0002.data</span></span>\n<span class="line"><span>  └── topicB/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>所有消息顺序写入 <code>.data</code> 文件（类似日志）</li><li>每个 Topic 分区存储</li><li>内存队列做缓存（ConcurrentLinkedQueue）</li><li>定期 flush 到磁盘</li></ul><h3 id="为什么写磁盘也很快" tabindex="-1"><a class="header-anchor" href="#为什么写磁盘也很快"><span>为什么写磁盘也很快？</span></a></h3><blockquote><p>因为是<strong>顺序写</strong>，不像数据库那样随机插入！</p></blockquote><hr><h2 id="consumer-谁来读消息-怎么控制" tabindex="-1"><a class="header-anchor" href="#consumer-谁来读消息-怎么控制"><span>Consumer：谁来读消息？怎么控制？</span></a></h2><blockquote><p>消息的“收件人”</p></blockquote><h3 id="消费有两种方式" tabindex="-1"><a class="header-anchor" href="#消费有两种方式"><span>消费有两种方式：</span></a></h3><ul><li><strong>主动拉（pull）</strong>：消费者定时去拉</li><li><strong>被动推（push）</strong>：Broker 推给我们</li></ul><h3 id="消费状态要记录" tabindex="-1"><a class="header-anchor" href="#消费状态要记录"><span>消费状态要记录：</span></a></h3><ul><li>每个 Consumer Group 有一个 offset</li><li>每个 topic/partition 有唯一消费进度</li></ul><hr><h2 id="registry-大家在哪-怎么通信" tabindex="-1"><a class="header-anchor" href="#registry-大家在哪-怎么通信"><span>Registry：大家在哪？怎么通信？</span></a></h2><p>一个 MQ 系统不能硬编码 IP，需要<strong>服务发现机制</strong>：</p><table><thead><tr><th>服务</th><th>作用</th></tr></thead><tbody><tr><td>注册中心</td><td>每个 Producer / Broker / Consumer 启动时注册</td></tr><tr><td>心跳机制</td><td>保持“在线状态”</td></tr><tr><td>服务发现</td><td>Producer 可以拉到 Broker 列表</td></tr><tr><td>可选组件</td><td>Nacos / Zookeeper / Eureka / etcd</td></tr></tbody></table><hr><h2 id="协议设计-怎么打包发消息" tabindex="-1"><a class="header-anchor" href="#协议设计-怎么打包发消息"><span>协议设计（怎么打包发消息？）</span></a></h2><p>我们自定义一个简单协议结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>| 魔数 | 版本 | 消息类型 | 数据长度 | 数据体 |</span></span>\n<span class="line"><span>  4B    1B      1B         4B       N 字节</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>类型：1=发送消息，2=拉取消息，3=ACK，4=心跳</li><li>数据体一般是 JSON 或 Protobuf 编码</li></ul><hr><h2 id="我们必须考虑的系统问题" tabindex="-1"><a class="header-anchor" href="#我们必须考虑的系统问题"><span>我们必须考虑的系统问题：</span></a></h2><h3 id="消息不能丢" tabindex="-1"><a class="header-anchor" href="#消息不能丢"><span>消息不能丢</span></a></h3><ul><li>内存队列 + 日志文件双重写入</li><li>写成功后才 ack 给 producer</li></ul><h3 id="消息不能重复消费" tabindex="-1"><a class="header-anchor" href="#消息不能重复消费"><span>消息不能重复消费</span></a></h3><ul><li>使用唯一消息 ID 去重</li><li>offset 要持久化（存 Redis 或本地）</li></ul><h3 id="支持顺序" tabindex="-1"><a class="header-anchor" href="#支持顺序"><span>支持顺序</span></a></h3><ul><li>同一个 Topic 分多个 Partition</li><li>每个 Partition 保证消息有序</li></ul><h3 id="多线程并发消费" tabindex="-1"><a class="header-anchor" href="#多线程并发消费"><span>多线程并发消费</span></a></h3><ul><li>每个 Partition 一个消费线程，互不干扰</li></ul><hr><h2 id="面试中这么答更有说服力" tabindex="-1"><a class="header-anchor" href="#面试中这么答更有说服力"><span>面试中这么答更有说服力</span></a></h2><blockquote><p>我们会把 MQ 拆成 Producer、Broker、Consumer、Registry 四个模块。Broker 是核心，负责缓存、存储、转发、ack、offset 管理等。网络通信基于 Netty，自定义协议传输。每条消息写入时写入内存队列和磁盘日志，保证高性能和可靠性。消费端拉取时使用 offset 管理，防止重复消费，同时支持按 Partition 顺序消费。服务发现通过注册中心实现系统扩展性和高可用。</p></blockquote><hr><h2 id="最小项目结构-我们可以手撸个-demo" tabindex="-1"><a class="header-anchor" href="#最小项目结构-我们可以手撸个-demo"><span>最小项目结构（我们可以手撸个 demo）</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>my-mq/</span></span>\n<span class="line"><span>├── net/           ← Netty 网络通信</span></span>\n<span class="line"><span>├── store/         ← 消息落盘</span></span>\n<span class="line"><span>├── queue/         ← 内存队列</span></span>\n<span class="line"><span>├── broker/        ← 消息转发逻辑</span></span>\n<span class="line"><span>├── consumer/      ← 消费者客户端</span></span>\n<span class="line"><span>├── producer/      ← 生产者客户端</span></span>\n<span class="line"><span>└── registry/      ← 注册中心模拟</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><table><thead><tr><th>目标</th><th>设计要点</th></tr></thead><tbody><tr><td>不丢消息</td><td>写日志 + Ack 确认机制</td></tr><tr><td>不重复消费</td><td>offset + 去重 ID</td></tr><tr><td>支持高并发写入</td><td>内存队列 + 异步写磁盘</td></tr><tr><td>高可用</td><td>多 Broker + 注册中心发现</td></tr></tbody></table><hr><h2 id="工程里的关键补充点" tabindex="-1"><a class="header-anchor" href="#工程里的关键补充点"><span>工程里的关键补充点</span></a></h2><h3 id="可靠性与一致性" tabindex="-1"><a class="header-anchor" href="#可靠性与一致性"><span>可靠性与一致性</span></a></h3><ul><li>至少一次与至多一次要选清楚，默认至少一次，业务需要去重</li><li>ACK 要与落盘绑定，避免“已确认但未落盘”的丢失</li><li>消息体要有唯一 ID，方便追踪与幂等</li></ul><h3 id="消费性能与背压" tabindex="-1"><a class="header-anchor" href="#消费性能与背压"><span>消费性能与背压</span></a></h3><ul><li>推模式要做消费速率保护，避免 Broker 压垮 Consumer</li><li>拉模式要控制拉取批次与频率，避免空转消耗</li><li>消费线程池要有队列长度保护</li></ul><h3 id="存储与堆积" tabindex="-1"><a class="header-anchor" href="#存储与堆积"><span>存储与堆积</span></a></h3><ul><li>分区数量规划要跟吞吐与并发消费能力匹配</li><li>冷热分层存储，避免单机磁盘打满</li><li>堆积时先限流再扩容，避免链路雪崩</li></ul><h3 id="监控与告警" tabindex="-1"><a class="header-anchor" href="#监控与告警"><span>监控与告警</span></a></h3><ul><li>监控延迟、堆积量、失败率、重试次数</li><li>关键 Topic 要有阈值告警与自动降级方案</li></ul><h3 id="版本与兼容" tabindex="-1"><a class="header-anchor" href="#版本与兼容"><span>版本与兼容</span></a></h3><ul><li>协议与消息体字段保持向后兼容</li><li>消费端升级要支持多版本并行</li></ul>',86)],n={},s=(0,l(66262).A)(n,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,t)}]]),r=JSON.parse('{"path":"/tech/%E5%9C%BA%E6%99%AF/mq.html","title":"从零开始讲清如何设计一个消息队列系统（MQ）：通俗易懂、细节到位","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-07-11T00:00:00.000Z","category":["后端"],"tag":["Java","面试","场景"],"description":"从零开始讲清如何设计一个消息队列系统（MQ）：通俗易懂、细节到位 什么是消息队列？一句话说清楚 消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。 它负责把“消息”从发送方（生产者）传递到接收方（消费者）—— 而且还能： 保证不会丢件（消息不丢失） 顺序到达（支持顺序消费） 如果收件人晚点来也没关系（异步解耦） 举个例子： 淘...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/tech/%E5%9C%BA%E6%99%AF/mq.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"从零开始讲清如何设计一个消息队列系统（MQ）：通俗易懂、细节到位"}],["meta",{"property":"og:description","content":"从零开始讲清如何设计一个消息队列系统（MQ）：通俗易懂、细节到位 什么是消息队列？一句话说清楚 消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。 它负责把“消息”从发送方（生产者）传递到接收方（消费者）—— 而且还能： 保证不会丢件（消息不丢失） 顺序到达（支持顺序消费） 如果收件人晚点来也没关系（异步解耦） 举个例子： 淘..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-21T09:06:17.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"场景"}],["meta",{"property":"article:published_time","content":"2025-07-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-21T09:06:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"从零开始讲清如何设计一个消息队列系统（MQ）：通俗易懂、细节到位\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-07-11T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-21T09:06:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"什么是消息队列？一句话说清楚","slug":"什么是消息队列-一句话说清楚","link":"#什么是消息队列-一句话说清楚","children":[{"level":3,"title":"举个例子：","slug":"举个例子","link":"#举个例子","children":[]}]},{"level":2,"title":"面试题：我们来设计一个 MQ 系统，该怎么说？","slug":"面试题-我们来设计一个-mq-系统-该怎么说","link":"#面试题-我们来设计一个-mq-系统-该怎么说","children":[{"level":3,"title":"一定要从这4个维度入手：","slug":"一定要从这4个维度入手","link":"#一定要从这4个维度入手","children":[]}]},{"level":2,"title":"系统流程全图","slug":"系统流程全图","link":"#系统流程全图","children":[]},{"level":2,"title":"我们逐个拆开讲：","slug":"我们逐个拆开讲","link":"#我们逐个拆开讲","children":[]},{"level":2,"title":"Producer：怎么把消息送出去？","slug":"producer-怎么把消息送出去","link":"#producer-怎么把消息送出去","children":[{"level":3,"title":"要实现的功能：","slug":"要实现的功能","link":"#要实现的功能","children":[]},{"level":3,"title":"设计要点：","slug":"设计要点","link":"#设计要点","children":[]}]},{"level":2,"title":"Broker：消息的中转站（核心）","slug":"broker-消息的中转站-核心","link":"#broker-消息的中转站-核心","children":[{"level":3,"title":"它要做 5 件事：","slug":"它要做-5-件事","link":"#它要做-5-件事","children":[]}]},{"level":2,"title":"消息存储设计（Broker 里）","slug":"消息存储设计-broker-里","link":"#消息存储设计-broker-里","children":[{"level":3,"title":"为什么写磁盘也很快？","slug":"为什么写磁盘也很快","link":"#为什么写磁盘也很快","children":[]}]},{"level":2,"title":"Consumer：谁来读消息？怎么控制？","slug":"consumer-谁来读消息-怎么控制","link":"#consumer-谁来读消息-怎么控制","children":[{"level":3,"title":"消费有两种方式：","slug":"消费有两种方式","link":"#消费有两种方式","children":[]},{"level":3,"title":"消费状态要记录：","slug":"消费状态要记录","link":"#消费状态要记录","children":[]}]},{"level":2,"title":"Registry：大家在哪？怎么通信？","slug":"registry-大家在哪-怎么通信","link":"#registry-大家在哪-怎么通信","children":[]},{"level":2,"title":"协议设计（怎么打包发消息？）","slug":"协议设计-怎么打包发消息","link":"#协议设计-怎么打包发消息","children":[]},{"level":2,"title":"我们必须考虑的系统问题：","slug":"我们必须考虑的系统问题","link":"#我们必须考虑的系统问题","children":[{"level":3,"title":"消息不能丢","slug":"消息不能丢","link":"#消息不能丢","children":[]},{"level":3,"title":"消息不能重复消费","slug":"消息不能重复消费","link":"#消息不能重复消费","children":[]},{"level":3,"title":"支持顺序","slug":"支持顺序","link":"#支持顺序","children":[]},{"level":3,"title":"多线程并发消费","slug":"多线程并发消费","link":"#多线程并发消费","children":[]}]},{"level":2,"title":"面试中这么答更有说服力","slug":"面试中这么答更有说服力","link":"#面试中这么答更有说服力","children":[]},{"level":2,"title":"最小项目结构（我们可以手撸个 demo）","slug":"最小项目结构-我们可以手撸个-demo","link":"#最小项目结构-我们可以手撸个-demo","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"工程里的关键补充点","slug":"工程里的关键补充点","link":"#工程里的关键补充点","children":[{"level":3,"title":"可靠性与一致性","slug":"可靠性与一致性","link":"#可靠性与一致性","children":[]},{"level":3,"title":"消费性能与背压","slug":"消费性能与背压","link":"#消费性能与背压","children":[]},{"level":3,"title":"存储与堆积","slug":"存储与堆积","link":"#存储与堆积","children":[]},{"level":3,"title":"监控与告警","slug":"监控与告警","link":"#监控与告警","children":[]},{"level":3,"title":"版本与兼容","slug":"版本与兼容","link":"#版本与兼容","children":[]}]}],"git":{"createdTime":1752325831000,"updatedTime":1768986377000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":3}]},"readingTime":{"minutes":4.88,"words":1464},"filePathRelative":"tech/场景/mq.md","localizedDate":"2025年7月11日","excerpt":"\\n<hr>\\n<h2>什么是消息队列？一句话说清楚</h2>\\n<blockquote>\\n<p>消息队列（Message Queue）是一个系统中用来传话的“快递中转站”。</p>\\n</blockquote>\\n<p>它负责把“消息”从发送方（生产者）<strong>传递</strong>到接收方（消费者）——\\n而且还能：</p>\\n<ul>\\n<li>保证不会丢件（消息不丢失）</li>\\n<li>顺序到达（支持顺序消费）</li>\\n<li>如果收件人晚点来也没关系（异步解耦）</li>\\n</ul>\\n<h3>举个例子：</h3>\\n<p>淘宝订单支付成功后，会发生很多事：</p>\\n<ul>\\n<li>给我们发短信</li>\\n<li>给仓库发发货请求</li>\\n<li>给商家发账单</li>\\n</ul>","autoDesc":true}')}}]);