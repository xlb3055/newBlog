"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[8948],{66262:(e,n)=>{n.A=(e,n)=>{const i=e.__vccOpts||e;for(const[e,l]of n)i[e]=l;return i}},41169:(e,n,i)=>{i.r(n),i.d(n,{comp:()=>s,data:()=>r});var l=i(20641);const a=[(0,l.Fv)('<hr><h1 id="低成本llm实践" tabindex="-1"><a class="header-anchor" href="#低成本llm实践"><span>低成本LLM实践</span></a></h1><h2 id="一种可验证、可扩展、极致省成本的-llm-工程实践" tabindex="-1"><a class="header-anchor" href="#一种可验证、可扩展、极致省成本的-llm-工程实践"><span>一种可验证、可扩展、极致省成本的 LLM 工程实践</span></a></h2><hr><h2 id="一、问题定义-problem-statement" tabindex="-1"><a class="header-anchor" href="#一、问题定义-problem-statement"><span>一、问题定义（Problem Statement）</span></a></h2><p>在真实业务中，我们面对的不是“模型够不够强”，而是：</p><ul><li>模型调用成本是否可控</li><li>是否可以规模化</li><li>是否具备稳定性和可复现性</li></ul><p>我们定义一个<strong>工程目标</strong>：</p><blockquote><p><strong>在不显著牺牲效果的前提下，将单次任务成本降低 10×–50×</strong></p></blockquote><hr><h2 id="二、核心假设-非常关键-决定方法是否成立" tabindex="-1"><a class="header-anchor" href="#二、核心假设-非常关键-决定方法是否成立"><span>二、核心假设（非常关键，决定方法是否成立）</span></a></h2><p>这套方法成立，依赖于以下 <strong>三个可被验证的假设</strong>：</p><h3 id="假设-1" tabindex="-1"><a class="header-anchor" href="#假设-1"><span>假设 1：</span></a></h3><blockquote><p><strong>多数真实任务是“结构性任务”，而不是创造性任务</strong></p></blockquote><p>例如：</p><ul><li>代码重构</li><li>数据清洗</li><li>流程生成</li><li>Agent 执行</li><li>Prompt 组合</li></ul><p>这些任务 <strong>80% 的价值来自流程正确，而不是灵感</strong>。</p><hr><h3 id="假设-2" tabindex="-1"><a class="header-anchor" href="#假设-2"><span>假设 2：</span></a></h3><blockquote><p><strong>强模型的优势主要体现在“首次构建认知结构”</strong></p></blockquote><p>一旦结构存在：</p><ul><li>子任务拆分</li><li>判断条件</li><li>执行顺序</li><li>失败处理</li></ul><p>弱模型即可稳定执行。</p><hr><h3 id="假设-3-关键" tabindex="-1"><a class="header-anchor" href="#假设-3-关键"><span>假设 3（关键）：</span></a></h3><blockquote><p><strong>弱模型的“执行能力”远强于它的“自主规划能力”</strong></p></blockquote><p>这是大量工程实践中反复验证的事实，尤其在：</p><ul><li>Qwen-32B</li><li>LLaMA-13B / 7B</li><li>DeepSeek-Base</li></ul><hr><h2 id="三、方法论总览-严格工程视角" tabindex="-1"><a class="header-anchor" href="#三、方法论总览-严格工程视角"><span>三、方法论总览（严格工程视角）</span></a></h2><p>我们将整个系统抽象为 <strong>Teacher → Compiler → Student</strong> 三层：</p><figure><img src="https://www.marktechpost.com/wp-content/uploads/2025/10/Screenshot-2025-10-18-at-11.16.01-PM-1.png" alt="Image" tabindex="0" loading="lazy"><figcaption>Image</figcaption></figure><h3 id="_1-teacher-model-高智能、低频" tabindex="-1"><a class="header-anchor" href="#_1-teacher-model-高智能、低频"><span>1. Teacher Model（高智能、低频）</span></a></h3><ul><li>GPT-4 / GPT-4.1 / Codex</li><li>职责：<strong>构建正确的解题结构</strong></li></ul><hr><h3 id="_2-knowledge-compiler-知识编译层" tabindex="-1"><a class="header-anchor" href="#_2-knowledge-compiler-知识编译层"><span>2. Knowledge Compiler（知识编译层）</span></a></h3><p>不是“复制文本”，而是：</p><blockquote><p><strong>把思考转译为可执行结构</strong></p></blockquote><hr><h3 id="_3-student-model-低成本、高频" tabindex="-1"><a class="header-anchor" href="#_3-student-model-低成本、高频"><span>3. Student Model（低成本、高频）</span></a></h3><ul><li>Qwen-32B / Qwen-14B</li><li>职责：<strong>忠实、高效、稳定地执行</strong></li></ul><hr><h2 id="四、为什么-直接蒸馏结果-是错误的" tabindex="-1"><a class="header-anchor" href="#四、为什么-直接蒸馏结果-是错误的"><span>四、为什么“直接蒸馏结果”是错误的？</span></a></h2><p>很多人第一反应是：</p><blockquote><p>“让 GPT-4 生成答案，然后让 Qwen 学这个答案”</p></blockquote><p>这是无效蒸馏。</p><p>原因在于：</p><ul><li>结果不可泛化</li><li>缺乏决策上下文</li><li>不包含失败路径</li><li>不具备可组合性</li></ul><hr><h2 id="五、正确的蒸馏对象-五类-可复用智能资产" tabindex="-1"><a class="header-anchor" href="#五、正确的蒸馏对象-五类-可复用智能资产"><span>五、正确的蒸馏对象：五类“可复用智能资产”</span></a></h2><h3 id="_1-任务分解图-task-decomposition-graph" tabindex="-1"><a class="header-anchor" href="#_1-任务分解图-task-decomposition-graph"><span>1. 任务分解图（Task Decomposition Graph）</span></a></h3><p>来自强模型的价值不是答案，而是：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>任务</span></span>\n<span class="line"><span> ├─ 子任务 A</span></span>\n<span class="line"><span> │   ├─ 校验条件</span></span>\n<span class="line"><span> │   └─ 执行策略</span></span>\n<span class="line"><span> └─ 子任务 B</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是可复用的认知骨架。</p><hr><h3 id="_2-决策树-decision-tree" tabindex="-1"><a class="header-anchor" href="#_2-决策树-decision-tree"><span>2. 决策树（Decision Tree）</span></a></h3><p>例如：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>if 信息完整:</span></span>\n<span class="line"><span>    执行完整流程</span></span>\n<span class="line"><span>elif 信息部分缺失:</span></span>\n<span class="line"><span>    请求补充</span></span>\n<span class="line"><span>else:</span></span>\n<span class="line"><span>    回退到简化方案</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是弱模型<strong>最擅长的结构</strong>。</p><hr><h3 id="_3-操作原语-action-primitives" tabindex="-1"><a class="header-anchor" href="#_3-操作原语-action-primitives"><span>3. 操作原语（Action Primitives）</span></a></h3><p>强模型会自然使用这些原语：</p><ul><li>搜索</li><li>对比</li><li>验证</li><li>重试</li><li>简化</li></ul><p>你需要<strong>显式提取并命名它们</strong>。</p><hr><h3 id="_4-输出契约-output-contract" tabindex="-1"><a class="header-anchor" href="#_4-输出契约-output-contract"><span>4. 输出契约（Output Contract）</span></a></h3><p>从工程角度：</p><blockquote><p><strong>输出格式 = 系统接口</strong></p></blockquote><p>格式越稳定，弱模型越可靠。</p><hr><h3 id="_5-失败处理-failure-modes" tabindex="-1"><a class="header-anchor" href="#_5-失败处理-failure-modes"><span>5. 失败处理（Failure Modes）</span></a></h3><p>这是强模型最容易被忽略、但最值钱的部分：</p><ul><li>何时放弃</li><li>何时提问</li><li>何时降低标准</li></ul><hr><h2 id="六、理论论据补充-让文章-站得住" tabindex="-1"><a class="header-anchor" href="#六、理论论据补充-让文章-站得住"><span>六、理论论据补充（让文章“站得住”）</span></a></h2><h3 id="论据-1-来自知识蒸馏-knowledge-distillation" tabindex="-1"><a class="header-anchor" href="#论据-1-来自知识蒸馏-knowledge-distillation"><span>论据 1：来自知识蒸馏（Knowledge Distillation）</span></a></h3><p>在传统深度学习中：</p><blockquote><p>Teacher 不只教 label，而是教 <strong>logits / 中间表征</strong></p></blockquote><p>你的方法，本质是：</p><blockquote><p><strong>蒸馏“思维结构”，而不是输出 token</strong></p></blockquote><hr><h3 id="论据-2-来自认知科学-cognitive-load-theory" tabindex="-1"><a class="header-anchor" href="#论据-2-来自认知科学-cognitive-load-theory"><span>论据 2：来自认知科学（Cognitive Load Theory）</span></a></h3><p>人类学习中：</p><ul><li>初学者 ≠ 自主规划</li><li>更依赖明确步骤与模板</li></ul><p><strong>弱模型本质上是“初学者智能”。</strong></p><hr><h3 id="论据-3-来自软件工程-separation-of-concerns" tabindex="-1"><a class="header-anchor" href="#论据-3-来自软件工程-separation-of-concerns"><span>论据 3：来自软件工程（Separation of Concerns）</span></a></h3><ul><li>架构设计 ≠ 业务执行</li><li>一次设计，多次复用</li></ul><p>你只是把这一原则 <strong>迁移到了 LLM 系统</strong></p><hr><h2 id="七、工程化-prompt-规范-严谨版" tabindex="-1"><a class="header-anchor" href="#七、工程化-prompt-规范-严谨版"><span>七、工程化 Prompt 规范（严谨版）</span></a></h2><h3 id="强模型-prompt-设计阶段" tabindex="-1"><a class="header-anchor" href="#强模型-prompt-设计阶段"><span>强模型 Prompt（设计阶段）</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>你是系统架构设计者，请输出：</span></span>\n<span class="line"><span>1. 任务拆分</span></span>\n<span class="line"><span>2. 决策条件</span></span>\n<span class="line"><span>3. 执行步骤</span></span>\n<span class="line"><span>4. 失败兜底</span></span>\n<span class="line"><span>禁止省略中间逻辑</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="弱模型-prompt-执行阶段" tabindex="-1"><a class="header-anchor" href="#弱模型-prompt-执行阶段"><span>弱模型 Prompt（执行阶段）</span></a></h3><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>你是执行引擎：</span></span>\n<span class="line"><span>- 不允许新增步骤</span></span>\n<span class="line"><span>- 不允许重新规划</span></span>\n<span class="line"><span>- 只允许按顺序执行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这是控制变量的关键。</strong></p><hr><h2 id="八、为什么这套方法在实践中稳定" tabindex="-1"><a class="header-anchor" href="#八、为什么这套方法在实践中稳定"><span>八、为什么这套方法在实践中稳定？</span></a></h2><p>从系统角度总结：</p><table><thead><tr><th>不稳定来源</th><th>你的方案如何规避</th></tr></thead><tbody><tr><td>自由推理漂移</td><td>固定结构</td></tr><tr><td>Prompt 过拟合</td><td>抽象为模板</td></tr><tr><td>模型能力差异</td><td>职责隔离</td></tr><tr><td>成本失控</td><td>强模型低频</td></tr></tbody></table><hr><h2 id="九、可量化的评估方式-严谨性加分点" tabindex="-1"><a class="header-anchor" href="#九、可量化的评估方式-严谨性加分点"><span>九、可量化的评估方式（严谨性加分点）</span></a></h2><p>你可以用以下指标评估是否成功：</p><ul><li>输出一致性（variance）</li><li>错误率下降</li><li>单任务 token 成本</li><li>失败重试次数</li><li>人工介入频率</li></ul><p><strong>这是工程方案，不是玄学。</strong></p><hr><h2 id="十、最终总结" tabindex="-1"><a class="header-anchor" href="#十、最终总结"><span>十、最终总结</span></a></h2><blockquote><p><strong>最昂贵的不是模型调用，而是重复思考。</strong></p><p>把强模型当成“架构师”， 把弱模型当成“执行引擎”， 才是 LLM 系统规模化的正确打开方式。</p></blockquote><hr>',110)],t={},s=(0,i(66262).A)(t,[["render",function(e,n){return(0,l.uX)(),(0,l.CE)("div",null,a)}]]),r=JSON.parse('{"path":"/%E5%A5%B6%E5%A5%B6%E5%85%AB%E8%82%A1/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E4%BD%8E%E6%88%90%E6%9C%ACLLM.html","title":"低成本LLM实践","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-01-13T00:00:00.000Z","category":["后端"],"tag":["大模型"],"description":"低成本LLM实践 一种可验证、可扩展、极致省成本的 LLM 工程实践 一、问题定义（Problem Statement） 在真实业务中，我们面对的不是“模型够不够强”，而是： 模型调用成本是否可控 是否可以规模化 是否具备稳定性和可复现性 我们定义一个工程目标： 在不显著牺牲效果的前提下，将单次任务成本降低 10×–50× 二、核心假设（非常关键，决定...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/%E5%A5%B6%E5%A5%B6%E5%85%AB%E8%82%A1/%E5%A4%A7%E6%A8%A1%E5%9E%8B/%E4%BD%8E%E6%88%90%E6%9C%ACLLM.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"低成本LLM实践"}],["meta",{"property":"og:description","content":"低成本LLM实践 一种可验证、可扩展、极致省成本的 LLM 工程实践 一、问题定义（Problem Statement） 在真实业务中，我们面对的不是“模型够不够强”，而是： 模型调用成本是否可控 是否可以规模化 是否具备稳定性和可复现性 我们定义一个工程目标： 在不显著牺牲效果的前提下，将单次任务成本降低 10×–50× 二、核心假设（非常关键，决定..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.marktechpost.com/wp-content/uploads/2025/10/Screenshot-2025-10-18-at-11.16.01-PM-1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-21T09:06:17.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"大模型"}],["meta",{"property":"article:published_time","content":"2025-01-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-21T09:06:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"低成本LLM实践\\",\\"image\\":[\\"https://www.marktechpost.com/wp-content/uploads/2025/10/Screenshot-2025-10-18-at-11.16.01-PM-1.png\\"],\\"datePublished\\":\\"2025-01-13T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-21T09:06:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"一种可验证、可扩展、极致省成本的 LLM 工程实践","slug":"一种可验证、可扩展、极致省成本的-llm-工程实践","link":"#一种可验证、可扩展、极致省成本的-llm-工程实践","children":[]},{"level":2,"title":"一、问题定义（Problem Statement）","slug":"一、问题定义-problem-statement","link":"#一、问题定义-problem-statement","children":[]},{"level":2,"title":"二、核心假设（非常关键，决定方法是否成立）","slug":"二、核心假设-非常关键-决定方法是否成立","link":"#二、核心假设-非常关键-决定方法是否成立","children":[{"level":3,"title":"假设 1：","slug":"假设-1","link":"#假设-1","children":[]},{"level":3,"title":"假设 2：","slug":"假设-2","link":"#假设-2","children":[]},{"level":3,"title":"假设 3（关键）：","slug":"假设-3-关键","link":"#假设-3-关键","children":[]}]},{"level":2,"title":"三、方法论总览（严格工程视角）","slug":"三、方法论总览-严格工程视角","link":"#三、方法论总览-严格工程视角","children":[{"level":3,"title":"1. Teacher Model（高智能、低频）","slug":"_1-teacher-model-高智能、低频","link":"#_1-teacher-model-高智能、低频","children":[]},{"level":3,"title":"2. Knowledge Compiler（知识编译层）","slug":"_2-knowledge-compiler-知识编译层","link":"#_2-knowledge-compiler-知识编译层","children":[]},{"level":3,"title":"3. Student Model（低成本、高频）","slug":"_3-student-model-低成本、高频","link":"#_3-student-model-低成本、高频","children":[]}]},{"level":2,"title":"四、为什么“直接蒸馏结果”是错误的？","slug":"四、为什么-直接蒸馏结果-是错误的","link":"#四、为什么-直接蒸馏结果-是错误的","children":[]},{"level":2,"title":"五、正确的蒸馏对象：五类“可复用智能资产”","slug":"五、正确的蒸馏对象-五类-可复用智能资产","link":"#五、正确的蒸馏对象-五类-可复用智能资产","children":[{"level":3,"title":"1. 任务分解图（Task Decomposition Graph）","slug":"_1-任务分解图-task-decomposition-graph","link":"#_1-任务分解图-task-decomposition-graph","children":[]},{"level":3,"title":"2. 决策树（Decision Tree）","slug":"_2-决策树-decision-tree","link":"#_2-决策树-decision-tree","children":[]},{"level":3,"title":"3. 操作原语（Action Primitives）","slug":"_3-操作原语-action-primitives","link":"#_3-操作原语-action-primitives","children":[]},{"level":3,"title":"4. 输出契约（Output Contract）","slug":"_4-输出契约-output-contract","link":"#_4-输出契约-output-contract","children":[]},{"level":3,"title":"5. 失败处理（Failure Modes）","slug":"_5-失败处理-failure-modes","link":"#_5-失败处理-failure-modes","children":[]}]},{"level":2,"title":"六、理论论据补充（让文章“站得住”）","slug":"六、理论论据补充-让文章-站得住","link":"#六、理论论据补充-让文章-站得住","children":[{"level":3,"title":"论据 1：来自知识蒸馏（Knowledge Distillation）","slug":"论据-1-来自知识蒸馏-knowledge-distillation","link":"#论据-1-来自知识蒸馏-knowledge-distillation","children":[]},{"level":3,"title":"论据 2：来自认知科学（Cognitive Load Theory）","slug":"论据-2-来自认知科学-cognitive-load-theory","link":"#论据-2-来自认知科学-cognitive-load-theory","children":[]},{"level":3,"title":"论据 3：来自软件工程（Separation of Concerns）","slug":"论据-3-来自软件工程-separation-of-concerns","link":"#论据-3-来自软件工程-separation-of-concerns","children":[]}]},{"level":2,"title":"七、工程化 Prompt 规范（严谨版）","slug":"七、工程化-prompt-规范-严谨版","link":"#七、工程化-prompt-规范-严谨版","children":[{"level":3,"title":"强模型 Prompt（设计阶段）","slug":"强模型-prompt-设计阶段","link":"#强模型-prompt-设计阶段","children":[]},{"level":3,"title":"弱模型 Prompt（执行阶段）","slug":"弱模型-prompt-执行阶段","link":"#弱模型-prompt-执行阶段","children":[]}]},{"level":2,"title":"八、为什么这套方法在实践中稳定？","slug":"八、为什么这套方法在实践中稳定","link":"#八、为什么这套方法在实践中稳定","children":[]},{"level":2,"title":"九、可量化的评估方式（严谨性加分点）","slug":"九、可量化的评估方式-严谨性加分点","link":"#九、可量化的评估方式-严谨性加分点","children":[]},{"level":2,"title":"十、最终总结","slug":"十、最终总结","link":"#十、最终总结","children":[]}],"git":{"createdTime":1768361611000,"updatedTime":1768986377000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":3}]},"readingTime":{"minutes":4.03,"words":1208},"filePathRelative":"奶奶八股/大模型/低成本LLM.md","localizedDate":"2025年1月13日","excerpt":"<hr>\\n<h1>低成本LLM实践</h1>\\n<h2>一种可验证、可扩展、极致省成本的 LLM 工程实践</h2>\\n<hr>\\n<h2>一、问题定义（Problem Statement）</h2>\\n<p>在真实业务中，我们面对的不是“模型够不够强”，而是：</p>\\n<ul>\\n<li>模型调用成本是否可控</li>\\n<li>是否可以规模化</li>\\n<li>是否具备稳定性和可复现性</li>\\n</ul>\\n<p>我们定义一个<strong>工程目标</strong>：</p>\\n<blockquote>\\n<p><strong>在不显著牺牲效果的前提下，将单次任务成本降低 10×–50×</strong></p>\\n</blockquote>","autoDesc":true}')}}]);