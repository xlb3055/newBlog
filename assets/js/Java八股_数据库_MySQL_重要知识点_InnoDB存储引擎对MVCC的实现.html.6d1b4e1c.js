"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[2316],{66262:(i,s)=>{s.A=(i,s)=>{const l=i.__vccOpts||i;for(const[i,a]of s)l[i]=a;return l}},81426:(i,s,l)=>{l.r(s),l.d(s,{comp:()=>e,data:()=>h});var a=l(20641);const n=[(0,a.Fv)('<h1 id="innodb对mvcc的实现" tabindex="-1"><a class="header-anchor" href="#innodb对mvcc的实现"><span>InnoDB对MVCC的实现</span></a></h1><hr><h2 id="_1-什么是-mvcc-多版本并发控制" tabindex="-1"><a class="header-anchor" href="#_1-什么是-mvcc-多版本并发控制"><span><strong>1. 什么是 MVCC（多版本并发控制）？</strong></span></a></h2><p>MVCC（Multi-Version Concurrency Control）是一种并发控制机制，旨在通过保存数据的多个版本，在不加锁的情况下实现高效的事务隔离，从而提升数据库的并发性能。</p><h3 id="_1-1-mvcc-的核心目标" tabindex="-1"><a class="header-anchor" href="#_1-1-mvcc-的核心目标"><span><strong>1.1 MVCC 的核心目标</strong></span></a></h3><ol><li>提高并发性能，避免事务间的锁等待。</li><li>实现一致性非锁定读，提升读操作效率。</li></ol><hr><h2 id="_2-一致性非锁定读和锁定读" tabindex="-1"><a class="header-anchor" href="#_2-一致性非锁定读和锁定读"><span><strong>2. 一致性非锁定读和锁定读</strong></span></a></h2><h3 id="_2-1-一致性非锁定读" tabindex="-1"><a class="header-anchor" href="#_2-1-一致性非锁定读"><span><strong>2.1 一致性非锁定读</strong></span></a></h3><ul><li><strong>定义</strong>：事务读取数据时，通过 MVCC 提供的 <strong>历史版本</strong> 获取快照数据，而不阻塞其他事务。</li><li><strong>特性</strong>： <ul><li>读取的始终是事务开始时的数据版本（由 <strong>ReadView</strong> 确定）。</li><li>避免了加锁，提高并发性能。</li></ul></li><li><strong>适用场景</strong>： <ul><li>隔离级别为 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 的普通 SELECT 查询。</li></ul></li></ul><p><strong>示例：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>行为</strong>：读取符合当前事务可见性规则的数据版本，而不加锁。</li></ul><hr><h3 id="_2-2-锁定读" tabindex="-1"><a class="header-anchor" href="#_2-2-锁定读"><span><strong>2.2 锁定读</strong></span></a></h3><ul><li><strong>定义</strong>：事务读取数据时加锁，阻止其他事务对数据的修改或读取，确保操作的一致性。</li><li><strong>触发方式</strong>：显式使用 <code>FOR UPDATE</code> 或 <code>LOCK IN SHARE MODE</code>。</li><li><strong>适用场景</strong>： <ul><li>防止数据被其他事务修改。</li><li>使用在更新前读取数据时。</li></ul></li></ul><p><strong>示例：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 排它锁</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LOCK </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">IN</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> SHARE MODE; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 共享锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>行为</strong>： <ul><li><code>FOR UPDATE</code>：加排他锁，阻止其他事务读或写。</li><li><code>LOCK IN SHARE MODE</code>：加共享锁，仅阻止写操作。</li></ul></li></ul><hr><h2 id="_3-innodb-对-mvcc-的实现" tabindex="-1"><a class="header-anchor" href="#_3-innodb-对-mvcc-的实现"><span><strong>3. InnoDB 对 MVCC 的实现</strong></span></a></h2><p>InnoDB 通过以下机制实现 MVCC：</p><h3 id="_3-1-隐藏字段" tabindex="-1"><a class="header-anchor" href="#_3-1-隐藏字段"><span><strong>3.1 隐藏字段</strong></span></a></h3><p>InnoDB 在每行数据后隐式添加两个字段：</p><ol><li><strong>trx_id</strong>：标记最后一次修改该行的事务 ID。</li><li><strong>roll_pointer</strong>：指向 <code>undo log</code>，用于回溯数据的历史版本。</li></ol><p><strong>示例：</strong></p><table><thead><tr><th>数据行</th><th>trx_id</th><th>roll_pointer</th></tr></thead><tbody><tr><td>row1</td><td>100</td><td>指向上一版本</td></tr></tbody></table><hr><h3 id="_3-2-readview-快照读" tabindex="-1"><a class="header-anchor" href="#_3-2-readview-快照读"><span><strong>3.2 ReadView（快照读）</strong></span></a></h3><ul><li><strong>定义</strong>：在事务读取数据时，生成的当前事务可见版本的视图。</li><li><strong>作用</strong>： <ol><li>确定哪些事务的修改对当前事务可见。</li><li>保证读取数据的一致性。</li></ol></li></ul><hr><h3 id="_3-3-undo-log" tabindex="-1"><a class="header-anchor" href="#_3-3-undo-log"><span><strong>3.3 undo log</strong></span></a></h3><ul><li><strong>定义</strong>：记录数据的历史版本。</li><li><strong>作用</strong>： <ol><li>用于事务回滚。</li><li>用于 MVCC 提供历史版本支持。</li></ol></li><li><strong>流程</strong>： <ul><li>每次更新数据时，将旧数据存入 <code>undo log</code>。</li><li>读取旧版本时，通过 <code>roll_pointer</code> 回溯到 <code>undo log</code>。</li></ul></li></ul><hr><h3 id="_3-4-数据可见性算法" tabindex="-1"><a class="header-anchor" href="#_3-4-数据可见性算法"><span><strong>3.4 数据可见性算法</strong></span></a></h3><p>事务读取数据时，判断数据版本是否可见的规则：</p><ol><li><strong>当前数据版本的 <code>trx_id</code></strong>： <ul><li>如果小于当前事务的 <code>trx_id</code>，则可见（修改发生在当前事务之前）。</li></ul></li><li><strong>事务状态</strong>： <ul><li>如果版本是由已提交的事务生成，则可见。</li><li>如果版本是由当前事务生成，则可见。</li></ul></li><li><strong>不在 ReadView 的活跃事务列表中</strong>： <ul><li>如果 <code>trx_id</code> 属于未提交的事务，则不可见。</li></ul></li></ol><hr><h2 id="_4-rc-和-rr-隔离级别下的-mvcc-差异" tabindex="-1"><a class="header-anchor" href="#_4-rc-和-rr-隔离级别下的-mvcc-差异"><span><strong>4. RC 和 RR 隔离级别下的 MVCC 差异</strong></span></a></h2><h3 id="_4-1-read-committed-rc-下的-mvcc" tabindex="-1"><a class="header-anchor" href="#_4-1-read-committed-rc-下的-mvcc"><span><strong>4.1 READ COMMITTED (RC) 下的 MVCC</strong></span></a></h3><ul><li>每次读取都会生成一个新的 <strong>ReadView</strong>。</li><li><strong>行为</strong>：可以看到其他事务已经提交的最新数据。</li></ul><p><strong>示例：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SESSION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TRANSACTION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ISOLATION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> LEVEL</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> READ</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> COMMITTED</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 第一次读取数据版本</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 其他事务修改并提交</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 第二次读取最新数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>结果：两次读取可能返回不同的结果。</li></ul><hr><h3 id="_4-2-repeatable-read-rr-下的-mvcc" tabindex="-1"><a class="header-anchor" href="#_4-2-repeatable-read-rr-下的-mvcc"><span><strong>4.2 REPEATABLE READ (RR) 下的 MVCC</strong></span></a></h3><ul><li>在事务开始时生成 <strong>一次性 ReadView</strong>。</li><li><strong>行为</strong>：事务期间读取的始终是事务开始时的快照数据。</li></ul><p><strong>示例：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> SESSION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> TRANSACTION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ISOLATION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> LEVEL</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> REPEATABLE</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> READ</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 第一次读取快照数据</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 其他事务修改并提交</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 仍然读取快照数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>结果：两次读取的结果一致，避免了不可重复读问题。</li></ul><hr><h2 id="_5-mvcc-解决不可重复读问题" tabindex="-1"><a class="header-anchor" href="#_5-mvcc-解决不可重复读问题"><span><strong>5. MVCC 解决不可重复读问题</strong></span></a></h2><p>MVCC 的核心在于通过 <strong>ReadView</strong> 机制，确保同一事务内的多次读取始终使用相同的快照数据。这是 <strong>REPEATABLE READ</strong> 隔离级别的核心机制。</p><ul><li>事务 A：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 第一次读取快照数据</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 第二次读取快照数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>事务 B：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> status</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;completed&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">COMMIT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>在事务 A 中，事务 B 的修改是不可见的，因此解决了不可重复读问题。</p><hr><h2 id="_6-mvcc-next-key-lock-防止幻读" tabindex="-1"><a class="header-anchor" href="#_6-mvcc-next-key-lock-防止幻读"><span><strong>6. MVCC + Next-Key Lock 防止幻读</strong></span></a></h2><h3 id="_6-1-什么是-next-key-lock" tabindex="-1"><a class="header-anchor" href="#_6-1-什么是-next-key-lock"><span><strong>6.1 什么是 Next-Key Lock？</strong></span></a></h3><ul><li><strong>定义</strong>：行锁（Record Lock）与间隙锁（Gap Lock）的组合。</li><li><strong>作用</strong>： <ul><li>锁定查询范围内的行和间隙，防止插入新数据导致幻读。</li></ul></li></ul><p><strong>示例：</strong></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>锁定的范围： <ul><li>已存在的行。</li><li>ID 大于 10 的间隙。</li></ul></li></ul><hr><h3 id="_6-2-如何防止幻读" tabindex="-1"><a class="header-anchor" href="#_6-2-如何防止幻读"><span><strong>6.2 如何防止幻读？</strong></span></a></h3><p>在 <code>REPEATABLE READ</code> 隔离级别下，InnoDB 使用 <strong>MVCC + Next-Key Lock</strong>：</p><ol><li><strong>MVCC</strong> 确保读取的快照一致性。</li><li><strong>Next-Key Lock</strong> 防止在查询范围内插入新数据。</li></ol><p><strong>示例：</strong></p><ul><li>事务 A：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">START TRANSACTION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> COUNT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">WHERE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> user_id </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FOR</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li><li>事务 B：<div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INSERT INTO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> orders (order_id, user_id) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">VALUES</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">101</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- 阻塞，无法插入</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><p>通过 Next-Key Lock，事务 A 锁住了满足条件的范围，事务 B 无法插入新记录，从而避免幻读。</p><hr><h2 id="_7-总结" tabindex="-1"><a class="header-anchor" href="#_7-总结"><span><strong>7. 总结</strong></span></a></h2><ol><li><strong>一致性非锁定读</strong>：通过 MVCC 提供快照数据，避免加锁，提升并发性能。</li><li><strong>锁定读</strong>：通过行锁或间隙锁，保证操作一致性。</li><li><strong>InnoDB 的 MVCC</strong>： <ul><li>通过 <code>trx_id</code> 和 <code>undo log</code> 记录数据历史版本。</li><li>使用 <code>ReadView</code> 确定事务的可见性。</li></ul></li><li><strong>RC 和 RR 的区别</strong>： <ul><li>RC：每次读取生成新的 <code>ReadView</code>。</li><li>RR：整个事务共享同一个 <code>ReadView</code>。</li></ul></li><li><strong>MVCC + Next-Key Lock 防止幻读</strong>：结合快照一致性和间隙锁，保证查询范围内的一致性。</li></ol><hr>',73)],t={},e=(0,l(66262).A)(t,[["render",function(i,s){return(0,a.uX)(),(0,a.CE)("div",null,n)}]]),h=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0.html","title":"InnoDB对MVCC的实现","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-23T00:00:00.000Z","category":["后端"],"tag":["MySQL","数据库"],"description":"InnoDB对MVCC的实现 1. 什么是 MVCC（多版本并发控制）？ MVCC（Multi-Version Concurrency Control）是一种并发控制机制，旨在通过保存数据的多个版本，在不加锁的情况下实现高效的事务隔离，从而提升数据库的并发性能。 1.1 MVCC 的核心目标 提高并发性能，避免事务间的锁等待。 实现一致性非锁定读，提升...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"InnoDB对MVCC的实现"}],["meta",{"property":"og:description","content":"InnoDB对MVCC的实现 1. 什么是 MVCC（多版本并发控制）？ MVCC（Multi-Version Concurrency Control）是一种并发控制机制，旨在通过保存数据的多个版本，在不加锁的情况下实现高效的事务隔离，从而提升数据库的并发性能。 1.1 MVCC 的核心目标 提高并发性能，避免事务间的锁等待。 实现一致性非锁定读，提升..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-11-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"InnoDB对MVCC的实现\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"1. 什么是 MVCC（多版本并发控制）？","slug":"_1-什么是-mvcc-多版本并发控制","link":"#_1-什么是-mvcc-多版本并发控制","children":[{"level":3,"title":"1.1 MVCC 的核心目标","slug":"_1-1-mvcc-的核心目标","link":"#_1-1-mvcc-的核心目标","children":[]}]},{"level":2,"title":"2. 一致性非锁定读和锁定读","slug":"_2-一致性非锁定读和锁定读","link":"#_2-一致性非锁定读和锁定读","children":[{"level":3,"title":"2.1 一致性非锁定读","slug":"_2-1-一致性非锁定读","link":"#_2-1-一致性非锁定读","children":[]},{"level":3,"title":"2.2 锁定读","slug":"_2-2-锁定读","link":"#_2-2-锁定读","children":[]}]},{"level":2,"title":"3. InnoDB 对 MVCC 的实现","slug":"_3-innodb-对-mvcc-的实现","link":"#_3-innodb-对-mvcc-的实现","children":[{"level":3,"title":"3.1 隐藏字段","slug":"_3-1-隐藏字段","link":"#_3-1-隐藏字段","children":[]},{"level":3,"title":"3.2 ReadView（快照读）","slug":"_3-2-readview-快照读","link":"#_3-2-readview-快照读","children":[]},{"level":3,"title":"3.3 undo log","slug":"_3-3-undo-log","link":"#_3-3-undo-log","children":[]},{"level":3,"title":"3.4 数据可见性算法","slug":"_3-4-数据可见性算法","link":"#_3-4-数据可见性算法","children":[]}]},{"level":2,"title":"4. RC 和 RR 隔离级别下的 MVCC 差异","slug":"_4-rc-和-rr-隔离级别下的-mvcc-差异","link":"#_4-rc-和-rr-隔离级别下的-mvcc-差异","children":[{"level":3,"title":"4.1 READ COMMITTED (RC) 下的 MVCC","slug":"_4-1-read-committed-rc-下的-mvcc","link":"#_4-1-read-committed-rc-下的-mvcc","children":[]},{"level":3,"title":"4.2 REPEATABLE READ (RR) 下的 MVCC","slug":"_4-2-repeatable-read-rr-下的-mvcc","link":"#_4-2-repeatable-read-rr-下的-mvcc","children":[]}]},{"level":2,"title":"5. MVCC 解决不可重复读问题","slug":"_5-mvcc-解决不可重复读问题","link":"#_5-mvcc-解决不可重复读问题","children":[]},{"level":2,"title":"6. MVCC + Next-Key Lock 防止幻读","slug":"_6-mvcc-next-key-lock-防止幻读","link":"#_6-mvcc-next-key-lock-防止幻读","children":[{"level":3,"title":"6.1 什么是 Next-Key Lock？","slug":"_6-1-什么是-next-key-lock","link":"#_6-1-什么是-next-key-lock","children":[]},{"level":3,"title":"6.2 如何防止幻读？","slug":"_6-2-如何防止幻读","link":"#_6-2-如何防止幻读","children":[]}]},{"level":2,"title":"7. 总结","slug":"_7-总结","link":"#_7-总结","children":[]}],"git":{"createdTime":1732350028000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":4.83,"words":1449},"filePathRelative":"Java八股/数据库/MySQL/重要知识点/InnoDB存储引擎对MVCC的实现.md","localizedDate":"2024年11月23日","excerpt":"\\n<hr>\\n<h2><strong>1. 什么是 MVCC（多版本并发控制）？</strong></h2>\\n<p>MVCC（Multi-Version Concurrency Control）是一种并发控制机制，旨在通过保存数据的多个版本，在不加锁的情况下实现高效的事务隔离，从而提升数据库的并发性能。</p>\\n<h3><strong>1.1 MVCC 的核心目标</strong></h3>\\n<ol>\\n<li>提高并发性能，避免事务间的锁等待。</li>\\n<li>实现一致性非锁定读，提升读操作效率。</li>\\n</ol>\\n<hr>\\n<h2><strong>2. 一致性非锁定读和锁定读</strong></h2>","autoDesc":true}')}}]);