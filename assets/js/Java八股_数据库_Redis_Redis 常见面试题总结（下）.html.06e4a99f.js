"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[1102],{6262:(i,s)=>{s.A=(i,s)=>{const e=i.__vccOpts||i;for(const[i,l]of s)e[i]=l;return e}},8036:(i,s,e)=>{e.r(s),e.d(s,{comp:()=>t,data:()=>r});var l=e(641);const n=[(0,l.Fv)('<h1 id="redis常见面试题总结-下" tabindex="-1"><a class="header-anchor" href="#redis常见面试题总结-下"><span>Redis常见面试题总结(下)</span></a></h1><hr><h2 id="_1-redis-事务" tabindex="-1"><a class="header-anchor" href="#_1-redis-事务"><span><strong>1. Redis 事务</strong></span></a></h2><h3 id="_1-1-什么是-redis-事务" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是-redis-事务"><span><strong>1.1 什么是 Redis 事务？</strong></span></a></h3><p>Redis 事务是一组命令的集合，可以一次性按顺序执行。</p><ul><li><strong>事务特点</strong>： <ul><li>批量操作按顺序执行。</li><li>不支持部分回滚：即使某个命令失败，其他命令仍然会执行。</li></ul></li></ul><hr><h3 id="_1-2-如何使用-redis-事务" tabindex="-1"><a class="header-anchor" href="#_1-2-如何使用-redis-事务"><span><strong>1.2 如何使用 Redis 事务？</strong></span></a></h3><ol><li><strong>开启事务</strong>：<code>MULTI</code></li><li><strong>执行命令</strong>：事务中的命令会被加入队列，暂不执行。</li><li><strong>提交事务</strong>：<code>EXEC</code>，批量执行命令。</li><li><strong>放弃事务</strong>：<code>DISCARD</code>，清空队列。</li></ol><p><strong>示例</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MULTI</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value1&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value2&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">INCR</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key3</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">EXEC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-3-redis-事务支持原子性吗" tabindex="-1"><a class="header-anchor" href="#_1-3-redis-事务支持原子性吗"><span><strong>1.3 Redis 事务支持原子性吗？</strong></span></a></h3><ul><li><strong>单个命令是原子的</strong>：Redis 保证单个命令的原子性。</li><li><strong>事务整体不是原子的</strong>：如果某条命令失败，其他命令仍然会执行。</li></ul><p><strong>优化建议</strong>：可以使用 Lua 脚本来实现原子操作。</p><hr><h3 id="_1-4-redis-事务支持持久性吗" tabindex="-1"><a class="header-anchor" href="#_1-4-redis-事务支持持久性吗"><span><strong>1.4 Redis 事务支持持久性吗？</strong></span></a></h3><ul><li>Redis 事务的执行依赖于内存，不具备持久性。</li><li>需要结合 RDB 或 AOF 持久化机制，才能保证数据安全。</li></ul><hr><h3 id="_1-5-如何解决-redis-事务的缺陷" tabindex="-1"><a class="header-anchor" href="#_1-5-如何解决-redis-事务的缺陷"><span><strong>1.5 如何解决 Redis 事务的缺陷？</strong></span></a></h3><ol><li><p><strong>使用 Lua 脚本</strong>：</p><ul><li>Lua 脚本在 Redis 中是原子的，可以替代事务处理。</li><li>示例：<div class="language-lua line-numbers-mode" data-highlighter="shiki" data-ext="lua" data-title="lua" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">-- Lua 脚本，检查 key 是否存在后设置值</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">if</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;EXISTS&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">]) == </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> then</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> redis</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">call</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;SET&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">KEYS</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">], </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ARGV</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">else</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> nil</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong>合理设计业务逻辑</strong>：</p><ul><li>减少事务中命令的复杂度，避免失败。</li></ul></li></ol><hr><h2 id="_2-redis-性能优化-重要" tabindex="-1"><a class="header-anchor" href="#_2-redis-性能优化-重要"><span><strong>2. Redis 性能优化（重要）</strong></span></a></h2><h3 id="_2-1-使用批量操作减少网络传输" tabindex="-1"><a class="header-anchor" href="#_2-1-使用批量操作减少网络传输"><span><strong>2.1 使用批量操作减少网络传输</strong></span></a></h3><ul><li>Redis 性能的瓶颈之一是网络传输。</li><li>使用批量操作（如 <code>MSET</code>、<code>MGET</code>）代替多次单条命令。</li></ul><p><strong>示例</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">--</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 多条命令</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value1&quot;</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value2&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">--</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 批量操作</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MSET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key1</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value1&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key2</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value2&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-2-大量-key-集中过期问题" tabindex="-1"><a class="header-anchor" href="#_2-2-大量-key-集中过期问题"><span><strong>2.2 大量 Key 集中过期问题</strong></span></a></h3><p><strong>问题</strong>：大量 Key 同时过期会导致 Redis 卡顿。</p><p><strong>解决方案</strong>：</p><ol><li><strong>过期时间随机化</strong>： <ul><li>设置 Key 时，过期时间加入随机值：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;value&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> EX</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 300</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> RAND</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul></li><li><strong>分批删除</strong>： <ul><li>通过业务层分散过期时间。</li></ul></li></ol><hr><h3 id="_2-3-redis-bigkey-大-key" tabindex="-1"><a class="header-anchor" href="#_2-3-redis-bigkey-大-key"><span><strong>2.3 Redis bigkey（大 Key）</strong></span></a></h3><p><strong>问题</strong>：大 Key（单个 Key 存储过多数据）会导致操作时间过长。</p><p><strong>解决方案</strong>：</p><ol><li><strong>避免大 Key</strong>：拆分大 Key 为多个小 Key。</li><li><strong>操作前先检查 Key 大小</strong>：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">DEBUG</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> OBJECT</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> key_name</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>逐步删除大 Key</strong>： <ul><li>如果需要删除大 Key，可以使用 <code>SCAN</code> 或分批操作。</li></ul></li></ol><hr><h3 id="_2-4-redis-hotkey-热-key" tabindex="-1"><a class="header-anchor" href="#_2-4-redis-hotkey-热-key"><span><strong>2.4 Redis hotkey（热 Key）</strong></span></a></h3><p><strong>问题</strong>：某些 Key 被频繁访问，导致 Redis 性能下降。</p><p><strong>解决方案</strong>：</p><ol><li><strong>分散热 Key</strong>： <ul><li>为热 Key 添加随机前缀。</li></ul></li><li><strong>使用本地缓存</strong>： <ul><li>对热 Key 使用本地缓存（如 Guava Cache）。</li></ul></li></ol><hr><h3 id="_2-5-慢查询命令" tabindex="-1"><a class="header-anchor" href="#_2-5-慢查询命令"><span><strong>2.5 慢查询命令</strong></span></a></h3><p><strong>查看慢查询</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CONFIG</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> SET</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> slowlog-log-slower-than</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10000</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 设置慢查询阈值（10</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 毫秒）</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">SLOWLOG</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> GET</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 查看最近</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 条慢查询</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优化建议</strong>：</p><ul><li>使用索引或分片，减少慢查询。</li></ul><hr><h3 id="_2-6-redis-内存碎片" tabindex="-1"><a class="header-anchor" href="#_2-6-redis-内存碎片"><span><strong>2.6 Redis 内存碎片</strong></span></a></h3><p><strong>问题</strong>：频繁的内存分配和回收会产生碎片。</p><p><strong>解决方案</strong>：</p><ol><li><strong>定期优化内存</strong>：<div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MEMORY</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> PURGE</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><strong>合理配置内存管理参数</strong>： <ul><li><code>jemalloc</code> 是 Redis 默认的内存分配器，可以高效管理内存。</li></ul></li></ol><hr><h2 id="_3-redis-生产问题-重要" tabindex="-1"><a class="header-anchor" href="#_3-redis-生产问题-重要"><span><strong>3. Redis 生产问题（重要）</strong></span></a></h2><h3 id="_3-1-缓存穿透" tabindex="-1"><a class="header-anchor" href="#_3-1-缓存穿透"><span><strong>3.1 缓存穿透</strong></span></a></h3><p><strong>问题</strong>：请求大量不存在的 Key，直接打到数据库，导致压力过大。</p><p><strong>解决方案</strong>：</p><ol><li><strong>缓存空值</strong>： <ul><li>将不存在的 Key 缓存为特殊值。</li></ul></li><li><strong>布隆过滤器</strong>： <ul><li>提前过滤掉不存在的 Key。</li></ul></li></ol><hr><h3 id="_3-2-缓存击穿" tabindex="-1"><a class="header-anchor" href="#_3-2-缓存击穿"><span><strong>3.2 缓存击穿</strong></span></a></h3><p><strong>问题</strong>：热点 Key 过期时，瞬间大量请求打到数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>设置热点 Key 永不过期</strong>： <ul><li>使用定时任务更新缓存。</li></ul></li><li><strong>加分布式锁</strong>： <ul><li>只允许一个请求更新缓存，其余请求等待。</li></ul></li></ol><hr><h3 id="_3-3-缓存雪崩" tabindex="-1"><a class="header-anchor" href="#_3-3-缓存雪崩"><span><strong>3.3 缓存雪崩</strong></span></a></h3><p><strong>问题</strong>：大量缓存同时过期，导致请求直接打到数据库。</p><p><strong>解决方案</strong>：</p><ol><li><strong>过期时间随机化</strong>： <ul><li>避免大量 Key 同时过期。</li></ul></li><li><strong>双缓存机制</strong>： <ul><li>使用两个缓存，互为备份。</li></ul></li></ol><hr><h3 id="_3-4-如何保证缓存与数据库的一致性" tabindex="-1"><a class="header-anchor" href="#_3-4-如何保证缓存与数据库的一致性"><span><strong>3.4 如何保证缓存与数据库的一致性？</strong></span></a></h3><p><strong>问题</strong>：更新数据库后，缓存未及时更新。</p><p><strong>解决方案</strong>：</p><ol><li><strong>先更新数据库，再删除缓存</strong>： <ul><li>缓存中的旧数据可被删除，保证一致性。</li></ul></li><li><strong>消息队列同步更新</strong>： <ul><li>使用 MQ 保证数据一致性。</li></ul></li></ol><hr><h3 id="_3-5-哪些情况可能会导致-redis-阻塞" tabindex="-1"><a class="header-anchor" href="#_3-5-哪些情况可能会导致-redis-阻塞"><span><strong>3.5 哪些情况可能会导致 Redis 阻塞？</strong></span></a></h3><ol><li><strong>大 Key 操作</strong>：如 <code>DEL</code> 或 <code>LRANGE</code> 大 Key。</li><li><strong>慢查询</strong>：复杂命令如 <code>SORT</code> 或 <code>ZUNIONSTORE</code>。</li><li><strong>内存不足</strong>：Redis 频繁触发内存回收。</li></ol><p><strong>解决方案</strong>：</p><ul><li>避免大 Key，优化慢查询，合理设置内存。</li></ul><hr><h2 id="_4-redis-集群" tabindex="-1"><a class="header-anchor" href="#_4-redis-集群"><span><strong>4. Redis 集群</strong></span></a></h2><h3 id="_4-1-redis-集群模式" tabindex="-1"><a class="header-anchor" href="#_4-1-redis-集群模式"><span><strong>4.1 Redis 集群模式</strong></span></a></h3><p>Redis 提供两种集群模式：</p><ol><li><strong>主从模式</strong>： <ul><li>一个主节点多个从节点，主节点负责写，从节点负责读。</li></ul></li><li><strong>分片集群</strong>： <ul><li>将数据分片存储在多个节点，适合大规模数据场景。</li></ul></li></ol><p><strong>示例</strong>：</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 查看节点状态</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CLUSTER</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> NODES</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"># 添加从节点</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CLUSTER</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> REPLICATE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">master-node-i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">d&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_4-2-redis-使用规范" tabindex="-1"><a class="header-anchor" href="#_4-2-redis-使用规范"><span><strong>4.2 Redis 使用规范</strong></span></a></h3><ol><li><strong>使用合适的淘汰策略</strong>： <ul><li>如 <code>allkeys-lru</code> 或 <code>volatile-lru</code>。</li></ul></li><li><strong>避免频繁大操作</strong>： <ul><li>拆分大 Key，分批操作。</li></ul></li><li><strong>设置过期时间</strong>： <ul><li>避免数据长期占用内存。</li></ul></li><li><strong>监控和报警</strong>： <ul><li>监控慢查询、内存使用等关键指标。</li></ul></li></ol><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h2><ol><li><strong>Redis 事务</strong>：事务不具备完全的原子性，但可以用 Lua 脚本解决。</li><li><strong>性能优化</strong>：通过批量操作、分散过期时间、热 Key 处理等提高性能。</li><li><strong>生产问题解决</strong>： <ul><li>缓存穿透：使用布隆过滤器。</li><li>缓存击穿：加分布式锁。</li><li>缓存雪崩：随机化过期时间。</li></ul></li><li><strong>集群使用</strong>：主从模式适合读写分离，分片模式适合大规模数据场景。</li><li><strong>内存管理</strong>：避免大 Key 和热 Key，监控内存碎片。</li></ol>',92)],a={},t=(0,e(6262).A)(a,[["render",function(i,s){return(0,l.uX)(),(0,l.CE)("div",null,n)}]]),r=JSON.parse('{"path":"/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89.html","title":"Redis常见面试题总结(下)","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-11-23T00:00:00.000Z","category":["后端"],"tag":["Redis","数据库"],"description":"Redis常见面试题总结(下) 1. Redis 事务 1.1 什么是 Redis 事务？ Redis 事务是一组命令的集合，可以一次性按顺序执行。 事务特点： 批量操作按顺序执行。 不支持部分回滚：即使某个命令失败，其他命令仍然会执行。 1.2 如何使用 Redis 事务？ 开启事务：MULTI 执行命令：事务中的命令会被加入队列，暂不执行。 提交事...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/Java%E5%85%AB%E8%82%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/Redis%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"Redis常见面试题总结(下)"}],["meta",{"property":"og:description","content":"Redis常见面试题总结(下) 1. Redis 事务 1.1 什么是 Redis 事务？ Redis 事务是一组命令的集合，可以一次性按顺序执行。 事务特点： 批量操作按顺序执行。 不支持部分回滚：即使某个命令失败，其他命令仍然会执行。 1.2 如何使用 Redis 事务？ 开启事务：MULTI 执行命令：事务中的命令会被加入队列，暂不执行。 提交事..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T06:24:41.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2024-11-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T06:24:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis常见面试题总结(下)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-06T06:24:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"1. Redis 事务","slug":"_1-redis-事务","link":"#_1-redis-事务","children":[{"level":3,"title":"1.1 什么是 Redis 事务？","slug":"_1-1-什么是-redis-事务","link":"#_1-1-什么是-redis-事务","children":[]},{"level":3,"title":"1.2 如何使用 Redis 事务？","slug":"_1-2-如何使用-redis-事务","link":"#_1-2-如何使用-redis-事务","children":[]},{"level":3,"title":"1.3 Redis 事务支持原子性吗？","slug":"_1-3-redis-事务支持原子性吗","link":"#_1-3-redis-事务支持原子性吗","children":[]},{"level":3,"title":"1.4 Redis 事务支持持久性吗？","slug":"_1-4-redis-事务支持持久性吗","link":"#_1-4-redis-事务支持持久性吗","children":[]},{"level":3,"title":"1.5 如何解决 Redis 事务的缺陷？","slug":"_1-5-如何解决-redis-事务的缺陷","link":"#_1-5-如何解决-redis-事务的缺陷","children":[]}]},{"level":2,"title":"2. Redis 性能优化（重要）","slug":"_2-redis-性能优化-重要","link":"#_2-redis-性能优化-重要","children":[{"level":3,"title":"2.1 使用批量操作减少网络传输","slug":"_2-1-使用批量操作减少网络传输","link":"#_2-1-使用批量操作减少网络传输","children":[]},{"level":3,"title":"2.2 大量 Key 集中过期问题","slug":"_2-2-大量-key-集中过期问题","link":"#_2-2-大量-key-集中过期问题","children":[]},{"level":3,"title":"2.3 Redis bigkey（大 Key）","slug":"_2-3-redis-bigkey-大-key","link":"#_2-3-redis-bigkey-大-key","children":[]},{"level":3,"title":"2.4 Redis hotkey（热 Key）","slug":"_2-4-redis-hotkey-热-key","link":"#_2-4-redis-hotkey-热-key","children":[]},{"level":3,"title":"2.5 慢查询命令","slug":"_2-5-慢查询命令","link":"#_2-5-慢查询命令","children":[]},{"level":3,"title":"2.6 Redis 内存碎片","slug":"_2-6-redis-内存碎片","link":"#_2-6-redis-内存碎片","children":[]}]},{"level":2,"title":"3. Redis 生产问题（重要）","slug":"_3-redis-生产问题-重要","link":"#_3-redis-生产问题-重要","children":[{"level":3,"title":"3.1 缓存穿透","slug":"_3-1-缓存穿透","link":"#_3-1-缓存穿透","children":[]},{"level":3,"title":"3.2 缓存击穿","slug":"_3-2-缓存击穿","link":"#_3-2-缓存击穿","children":[]},{"level":3,"title":"3.3 缓存雪崩","slug":"_3-3-缓存雪崩","link":"#_3-3-缓存雪崩","children":[]},{"level":3,"title":"3.4 如何保证缓存与数据库的一致性？","slug":"_3-4-如何保证缓存与数据库的一致性","link":"#_3-4-如何保证缓存与数据库的一致性","children":[]},{"level":3,"title":"3.5 哪些情况可能会导致 Redis 阻塞？","slug":"_3-5-哪些情况可能会导致-redis-阻塞","link":"#_3-5-哪些情况可能会导致-redis-阻塞","children":[]}]},{"level":2,"title":"4. Redis 集群","slug":"_4-redis-集群","link":"#_4-redis-集群","children":[{"level":3,"title":"4.1 Redis 集群模式","slug":"_4-1-redis-集群模式","link":"#_4-1-redis-集群模式","children":[]},{"level":3,"title":"4.2 Redis 使用规范","slug":"_4-2-redis-使用规范","link":"#_4-2-redis-使用规范","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1733029796000,"updatedTime":1749191081000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":4.84,"words":1453},"filePathRelative":"Java八股/数据库/Redis/Redis 常见面试题总结（下）.md","localizedDate":"2024年11月23日","excerpt":"\\n<hr>\\n<h2><strong>1. Redis 事务</strong></h2>\\n<h3><strong>1.1 什么是 Redis 事务？</strong></h3>\\n<p>Redis 事务是一组命令的集合，可以一次性按顺序执行。</p>\\n<ul>\\n<li><strong>事务特点</strong>：\\n<ul>\\n<li>批量操作按顺序执行。</li>\\n<li>不支持部分回滚：即使某个命令失败，其他命令仍然会执行。</li>\\n</ul>\\n</li>\\n</ul>\\n<hr>\\n<h3><strong>1.2 如何使用 Redis 事务？</strong></h3>\\n<ol>\\n<li><strong>开启事务</strong>：<code>MULTI</code></li>\\n<li><strong>执行命令</strong>：事务中的命令会被加入队列，暂不执行。</li>\\n<li><strong>提交事务</strong>：<code>EXEC</code>，批量执行命令。</li>\\n<li><strong>放弃事务</strong>：<code>DISCARD</code>，清空队列。</li>\\n</ol>","autoDesc":true}')}}]);