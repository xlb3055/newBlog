"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[2216],{6262:(t,l)=>{l.A=(t,l)=>{const e=t.__vccOpts||t;for(const[t,a]of l)e[t]=a;return e}},5607:(t,l,e)=>{e.r(l),e.d(l,{comp:()=>i,data:()=>d});var a=e(641);const r=[(0,a.Fv)('<h1 id="📮-消息队列到底该用推-push-还是拉-pull-一文吃透两种模式" tabindex="-1"><a class="header-anchor" href="#📮-消息队列到底该用推-push-还是拉-pull-一文吃透两种模式"><span>📮 消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！</span></a></h1><hr><h2 id="🎯-为什么这个问题很重要" tabindex="-1"><a class="header-anchor" href="#🎯-为什么这个问题很重要"><span>🎯 为什么这个问题很重要？</span></a></h2><p>面试官问这个问题，其实是想考你两个核心能力：</p><ol><li><strong>对消息消费流程是否熟悉？</strong></li><li><strong>能否根据业务需求选择合适的方式？</strong></li></ol><p>但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。</p><p>本篇我们从 0 到 1，搞清楚以下问题：</p><ul><li>推模式 vs 拉模式到底差在哪？</li><li>各有什么优缺点？</li><li>哪些场景适合推？哪些适合拉？</li><li>Kafka、RabbitMQ 等主流 MQ 怎么选的？</li><li>实战中如何设计出一个可控的消费流程？</li></ul><hr><h2 id="🍔-类比理解-吃饭模式帮你秒懂" tabindex="-1"><a class="header-anchor" href="#🍔-类比理解-吃饭模式帮你秒懂"><span>🍔 类比理解：吃饭模式帮你秒懂！</span></a></h2><ul><li><strong>推模式（Push）</strong>：餐厅服务员把菜端到你桌子上</li><li><strong>拉模式（Pull）</strong>：你自己去自助餐取菜</li></ul><table><thead><tr><th>模式</th><th>谁主动？</th><th>控制节奏</th><th>容易超载？</th><th>实时性</th></tr></thead><tbody><tr><td>推（Push）</td><td>Broker</td><td>消费者无法控制</td><td>是</td><td>高</td></tr><tr><td>拉（Pull）</td><td>Consumer</td><td>自己控制</td><td>否</td><td>低（可调）</td></tr></tbody></table><hr><h2 id="🛠-什么是推模式-push-model" tabindex="-1"><a class="header-anchor" href="#🛠-什么是推模式-push-model"><span>🛠 什么是推模式（Push Model）？</span></a></h2><p>推模式中：</p><ul><li>Producer 把消息发给 Broker</li><li>Broker 立即主动将消息投递给 Consumer</li><li>Consumer 必须实现一个“接收回调接口”</li></ul><h3 id="✅-优点" tabindex="-1"><a class="header-anchor" href="#✅-优点"><span>✅ 优点：</span></a></h3><ul><li><strong>实时性强</strong>：消息一到即发，适合秒级通知</li><li><strong>代码简单</strong>：消费者只需要订阅一次，不需要轮询</li></ul><h3 id="❌-缺点" tabindex="-1"><a class="header-anchor" href="#❌-缺点"><span>❌ 缺点：</span></a></h3><ul><li><strong>容易压垮消费者</strong>：Broker 不知道消费能力，一股脑推送</li><li><strong>难以限流</strong>：无法很好做 backpressure（回压）</li><li><strong>网络拥堵时会有丢失风险</strong></li></ul><h3 id="📌-实际案例" tabindex="-1"><a class="header-anchor" href="#📌-实际案例"><span>📌 实际案例：</span></a></h3><ul><li>RabbitMQ 默认使用推模式，通过回调函数 <code>handleMessage()</code> 处理推过来的消息</li></ul><hr><h2 id="🧱-什么是拉模式-pull-model" tabindex="-1"><a class="header-anchor" href="#🧱-什么是拉模式-pull-model"><span>🧱 什么是拉模式（Pull Model）？</span></a></h2><p>拉模式中：</p><ul><li>Consumer 定期向 Broker 发起“拉取请求”</li><li>可以指定“拉多少条”“多久拉一次”</li></ul><h3 id="✅-优点-1" tabindex="-1"><a class="header-anchor" href="#✅-优点-1"><span>✅ 优点：</span></a></h3><ul><li><strong>可控节奏</strong>：消费者主动控制拉取频率，不会被压爆</li><li><strong>适合批量消费</strong>：每次拉 N 条统一处理，性能好</li><li><strong>更容易实现限流、失败重试</strong></li></ul><h3 id="❌-缺点-1" tabindex="-1"><a class="header-anchor" href="#❌-缺点-1"><span>❌ 缺点：</span></a></h3><ul><li><strong>可能有延迟</strong>：比如你 1s 拉一次，那最多可能延迟 1 秒才收到消息</li><li><strong>实现复杂度稍高</strong>：需要维护拉取状态、偏移量等信息</li></ul><h3 id="📌-实际案例-1" tabindex="-1"><a class="header-anchor" href="#📌-实际案例-1"><span>📌 实际案例：</span></a></h3><ul><li>Kafka、RocketMQ 都使用拉模式</li></ul><hr><h2 id="💡-哪些场景选哪种模式" tabindex="-1"><a class="header-anchor" href="#💡-哪些场景选哪种模式"><span>💡 哪些场景选哪种模式？</span></a></h2><table><thead><tr><th>场景</th><th>推荐模式</th><th>理由</th></tr></thead><tbody><tr><td>秒级通知（发短信、推送）</td><td>推</td><td>实时性强</td></tr><tr><td>流量控制 / 复杂业务逻辑处理</td><td>拉</td><td>可控、稳定、易限流</td></tr><tr><td>批量处理 / 日志分析</td><td>拉</td><td>一次拉一批，高吞吐</td></tr><tr><td>用户事件监听（RabbitMQ）</td><td>推</td><td>回调机制简单，易上手</td></tr><tr><td>容灾处理 / 死信队列</td><td>拉</td><td>可自己管理消费偏移，更灵活</td></tr></tbody></table><hr><h2 id="📦-主流-mq-的实际做法" tabindex="-1"><a class="header-anchor" href="#📦-主流-mq-的实际做法"><span>📦 主流 MQ 的实际做法</span></a></h2><table><thead><tr><th>MQ产品</th><th>消费方式</th><th>说明</th></tr></thead><tbody><tr><td>Kafka</td><td>拉</td><td><code>consumer.poll()</code> 主动拉取</td></tr><tr><td>RocketMQ</td><td>拉</td><td>客户端模拟 push，实为 poll 拉</td></tr><tr><td>RabbitMQ</td><td>推</td><td>消息直接推送到 Consumer 端回调</td></tr><tr><td>Redis Stream</td><td>拉 + 阻塞</td><td><code>XREAD BLOCK</code> 模拟监听效果</td></tr></tbody></table><hr><h2 id="🧪-实战设计-如何选型-如何限流" tabindex="-1"><a class="header-anchor" href="#🧪-实战设计-如何选型-如何限流"><span>🧪 实战设计：如何选型 + 如何限流？</span></a></h2><h3 id="❶-如果你要写一个-支付成功后发短信-模块" tabindex="-1"><a class="header-anchor" href="#❶-如果你要写一个-支付成功后发短信-模块"><span>❶ 如果你要写一个“支付成功后发短信”模块：</span></a></h3><p><strong>推模式更合适</strong>：</p><ul><li>用户点击支付，立即需要短信提醒</li><li>用推模式回调接口处理即可，简洁高效</li></ul><h3 id="❷-如果你要写一个-退款批量审核-模块" tabindex="-1"><a class="header-anchor" href="#❷-如果你要写一个-退款批量审核-模块"><span>❷ 如果你要写一个“退款批量审核”模块：</span></a></h3><p><strong>拉模式更合适</strong>：</p><ul><li>每小时审核一次退款订单</li><li>拉取 1000 条消息，批量入库</li></ul><hr><h2 id="⚠-推模式有哪些隐患-怎么优化" tabindex="-1"><a class="header-anchor" href="#⚠-推模式有哪些隐患-怎么优化"><span>⚠ 推模式有哪些隐患？怎么优化？</span></a></h2><table><thead><tr><th>问题</th><th>解决方案</th></tr></thead><tbody><tr><td>消费太慢，消息堆积</td><td>加入消费速率监控 + 死信队列</td></tr><tr><td>消息投递失败</td><td>增加 ACK &amp; 重试机制</td></tr><tr><td>消息堆积 OOM</td><td>增加临时缓冲区 + 分区处理 + 限流模块</td></tr></tbody></table><hr><h2 id="🎯-面试时怎么答才漂亮" tabindex="-1"><a class="header-anchor" href="#🎯-面试时怎么答才漂亮"><span>🎯 面试时怎么答才漂亮？</span></a></h2><blockquote><p>消息队列可以使用推（Push）或拉（Pull）两种模式。 推适合实时性强的场景，比如支付通知，但对消费者压力大。拉适合批处理和控制节奏，比如日志处理。Kafka、RocketMQ 用拉模式方便控制节奏和偏移，RabbitMQ 推模式实现简单、适合监听型消费。 如果我设计一个系统，我倾向使用“拉 + 限流 + ACK”这种更稳定的方式。</p></blockquote><hr><h2 id="🧾-总结一句话" tabindex="-1"><a class="header-anchor" href="#🧾-总结一句话"><span>🧾 总结一句话</span></a></h2><blockquote><p><strong>推模式更快，但难控；拉模式更稳，但复杂。</strong></p></blockquote><p>选择哪种模式不是绝对，要看你业务“更在意实时性”还是“更在意稳定性”。</p><hr>',57)],n={},i=(0,e(6262).A)(n,[["render",function(t,l){return(0,a.uX)(),(0,a.CE)("div",null,r)}]]),d=JSON.parse('{"path":"/tech/%E5%9C%BA%E6%99%AF/mq%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F.html","title":"📮 消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","category":["后端"],"tag":["Java","面试","场景"],"description":"📮 消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！ 🎯 为什么这个问题很重要？ 面试官问这个问题，其实是想考你两个核心能力： 对消息消费流程是否熟悉？ 能否根据业务需求选择合适的方式？ 但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。 本篇我们从 0 到 1，搞清...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/tech/%E5%9C%BA%E6%99%AF/mq%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"Bin的成长博客"}],["meta",{"property":"og:title","content":"📮 消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！"}],["meta",{"property":"og:description","content":"📮 消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！ 🎯 为什么这个问题很重要？ 面试官问这个问题，其实是想考你两个核心能力： 对消息消费流程是否熟悉？ 能否根据业务需求选择合适的方式？ 但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。 本篇我们从 0 到 1，搞清..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-12T13:10:31.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"场景"}],["meta",{"property":"article:modified_time","content":"2025-07-12T13:10:31.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"📮 消息队列到底该用推（Push）还是拉（Pull）？一文吃透两种模式！\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-12T13:10:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"🎯 为什么这个问题很重要？","slug":"🎯-为什么这个问题很重要","link":"#🎯-为什么这个问题很重要","children":[]},{"level":2,"title":"🍔 类比理解：吃饭模式帮你秒懂！","slug":"🍔-类比理解-吃饭模式帮你秒懂","link":"#🍔-类比理解-吃饭模式帮你秒懂","children":[]},{"level":2,"title":"🛠 什么是推模式（Push Model）？","slug":"🛠-什么是推模式-push-model","link":"#🛠-什么是推模式-push-model","children":[{"level":3,"title":"✅ 优点：","slug":"✅-优点","link":"#✅-优点","children":[]},{"level":3,"title":"❌ 缺点：","slug":"❌-缺点","link":"#❌-缺点","children":[]},{"level":3,"title":"📌 实际案例：","slug":"📌-实际案例","link":"#📌-实际案例","children":[]}]},{"level":2,"title":"🧱 什么是拉模式（Pull Model）？","slug":"🧱-什么是拉模式-pull-model","link":"#🧱-什么是拉模式-pull-model","children":[{"level":3,"title":"✅ 优点：","slug":"✅-优点-1","link":"#✅-优点-1","children":[]},{"level":3,"title":"❌ 缺点：","slug":"❌-缺点-1","link":"#❌-缺点-1","children":[]},{"level":3,"title":"📌 实际案例：","slug":"📌-实际案例-1","link":"#📌-实际案例-1","children":[]}]},{"level":2,"title":"💡 哪些场景选哪种模式？","slug":"💡-哪些场景选哪种模式","link":"#💡-哪些场景选哪种模式","children":[]},{"level":2,"title":"📦 主流 MQ 的实际做法","slug":"📦-主流-mq-的实际做法","link":"#📦-主流-mq-的实际做法","children":[]},{"level":2,"title":"🧪 实战设计：如何选型 + 如何限流？","slug":"🧪-实战设计-如何选型-如何限流","link":"#🧪-实战设计-如何选型-如何限流","children":[{"level":3,"title":"❶ 如果你要写一个“支付成功后发短信”模块：","slug":"❶-如果你要写一个-支付成功后发短信-模块","link":"#❶-如果你要写一个-支付成功后发短信-模块","children":[]},{"level":3,"title":"❷ 如果你要写一个“退款批量审核”模块：","slug":"❷-如果你要写一个-退款批量审核-模块","link":"#❷-如果你要写一个-退款批量审核-模块","children":[]}]},{"level":2,"title":"⚠ 推模式有哪些隐患？怎么优化？","slug":"⚠-推模式有哪些隐患-怎么优化","link":"#⚠-推模式有哪些隐患-怎么优化","children":[]},{"level":2,"title":"🎯 面试时怎么答才漂亮？","slug":"🎯-面试时怎么答才漂亮","link":"#🎯-面试时怎么答才漂亮","children":[]},{"level":2,"title":"🧾 总结一句话","slug":"🧾-总结一句话","link":"#🧾-总结一句话","children":[]}],"git":{"createdTime":1752325831000,"updatedTime":1752325831000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":1}]},"readingTime":{"minutes":3.7,"words":1109},"filePathRelative":"tech/场景/mq消费方式.md","localizedDate":"2025年7月12日","excerpt":"\\n<hr>\\n<h2>🎯 为什么这个问题很重要？</h2>\\n<p>面试官问这个问题，其实是想考你两个核心能力：</p>\\n<ol>\\n<li><strong>对消息消费流程是否熟悉？</strong></li>\\n<li><strong>能否根据业务需求选择合适的方式？</strong></li>\\n</ol>\\n<p>但很多人回答都是一句话：“Kafka 用拉，RabbitMQ 用推”，没有深入细节、没有类比解释、没有系统思考。</p>\\n<p>本篇我们从 0 到 1，搞清楚以下问题：</p>\\n<ul>\\n<li>推模式 vs 拉模式到底差在哪？</li>\\n<li>各有什么优缺点？</li>\\n<li>哪些场景适合推？哪些适合拉？</li>\\n<li>Kafka、RabbitMQ 等主流 MQ 怎么选的？</li>\\n<li>实战中如何设计出一个可控的消费流程？</li>\\n</ul>","autoDesc":true}')}}]);