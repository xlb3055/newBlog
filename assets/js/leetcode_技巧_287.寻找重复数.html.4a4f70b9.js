"use strict";(self.webpackChunkblog_road=self.webpackChunkblog_road||[]).push([[4488],{66262:(s,i)=>{i.A=(s,i)=>{const n=s.__vccOpts||s;for(const[s,a]of i)n[s]=a;return n}},69619:(s,i,n)=>{n.r(i),n.d(i,{comp:()=>t,data:()=>h});var a=n(20641);const l=[(0,a.Fv)('<h2 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述"><span>题目描述</span></a></h2><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code>，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p><p>假设 <code>nums</code> 只有一个重复的整数，返回这个重复的数。</p><p><strong>要求：</strong></p><ul><li>必须<strong>不修改</strong>数组 <code>nums</code></li><li>只能使用常量级 <code>O(1)</code> 的额外空间</li></ul><p><strong>示例 1:</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [1,3,4,2,2]</span></span>\n<span class="line"><span>输出: 2</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>输入: nums = [3,1,3,4,2]</span></span>\n<span class="line"><span>输出: 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="解题思路-快慢指针-floyd-判圈算法" tabindex="-1"><a class="header-anchor" href="#解题思路-快慢指针-floyd-判圈算法"><span>解题思路：快慢指针 (Floyd 判圈算法)</span></a></h2><p>这道题的限制条件非常苛刻：不能修改原数组，并且空间复杂度要求为 O(1)。这意味着我们不能使用排序、哈希表等常规方法。</p><p>我们可以换一个角度来思考这个问题。数组中的数字范围是 <code>[1, n]</code>，而数组的长度是 <code>n + 1</code>。我们可以将数组中的每个索引 <code>i</code> 和它对应的值 <code>nums[i]</code> 看作是一个映射关系 <code>i -&gt; nums[i]</code>。由于 <code>nums</code> 中的值也在索引范围内（虽然不完全对应），我们可以将这个数组想象成一个<strong>链表</strong>。</p><ul><li><strong>节点</strong>：数组的索引 <code>0, 1, ..., n</code></li><li><strong>指针</strong>：从索引 <code>i</code> 指向索引 <code>nums[i]</code></li></ul><p>例如，对于 <code>nums = [1, 3, 4, 2, 2]</code>：</p><ul><li><code>0 -&gt; nums[0]</code> 即 <code>0 -&gt; 1</code></li><li><code>1 -&gt; nums[1]</code> 即 <code>1 -&gt; 3</code></li><li><code>2 -&gt; nums[2]</code> 即 <code>2 -&gt; 4</code></li><li><code>3 -&gt; nums[3]</code> 即 <code>3 -&gt; 2</code></li><li><code>4 -&gt; nums[4]</code> 即 <code>4 -&gt; 2</code></li></ul><p>我们可以画出这个“链表”的结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>0 -&gt; 1 -&gt; 3 -&gt; 2 -&gt; 4</span></span>\n<span class="line"><span>             ^     |</span></span>\n<span class="line"><span>             |-----|</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现，索引 <code>3</code> 和 <code>4</code> 都指向了索引 <code>2</code>，形成了一个环的入口。这个重复的指向 <code>2</code> 正是因为 <code>nums</code> 数组中出现了重复的数字 <code>2</code>。因此，<strong>寻找重复数的问题就转化为了寻找链表环的入口问题</strong>。</p><p>寻找环的入口，最经典的算法就是 <strong>Floyd 判圈算法</strong>，也就是我们常说的“快慢指针”。</p><h3 id="算法步骤" tabindex="-1"><a class="header-anchor" href="#算法步骤"><span>算法步骤</span></a></h3><ol><li><p><strong>第一阶段：找到相遇点</strong></p><ul><li>定义两个指针，<code>slow</code> 和 <code>fast</code>，都从索引 <code>0</code> 开始。</li><li><code>slow</code> 每次走一步：<code>slow = nums[slow]</code>。</li><li><code>fast</code> 每次走两步：<code>fast = nums[nums[fast]]</code>。</li><li>由于链表中存在环，<code>fast</code> 指针最终会在环内追上 <code>slow</code> 指针。我们循环直到 <code>slow == fast</code>，这个相遇点在环内。</li></ul></li><li><p><strong>第二阶段：找到环的入口</strong></p><ul><li>将其中一个指针（例如 <code>slow</code>）重新放回起点，即 <code>slow = 0</code>。</li><li>另一个指针 <code>fast</code> 保持在相遇点不动。</li><li>现在，两个指针都每次走一步：<code>slow = nums[slow]</code>，<code>fast = nums[fast]</code>。</li><li>它们下一次相遇的点，就是环的入口，也就是我们要找的重复数。</li></ul></li></ol><h3 id="为什么第二次相遇就是环的入口" tabindex="-1"><a class="header-anchor" href="#为什么第二次相遇就是环的入口"><span>为什么第二次相遇就是环的入口？</span></a></h3><p>这是一个数学证明：</p><ul><li>设链表起点到环入口的距离为 <code>a</code>。</li><li>环的长度为 <code>b</code>。</li><li>快慢指针在环内相遇时，慢指针走了 <code>s</code> 步，快指针走了 <code>2s</code> 步。</li><li>相遇点距离环入口的距离为 <code>x</code>。</li></ul><p>那么：</p><ul><li>慢指针走过的路程：<code>s = a + x</code></li><li>快指针走过的路程：<code>2s = a + n*b + x</code> (快指针可能在环里绕了 n 圈)</li></ul><p>将 <code>s</code> 代入第二个式子： <code>2(a + x) = a + n*b + x</code><code>2a + 2x = a + n*b + x</code><code>a + x = n*b</code><code>a = n*b - x</code></p><p>这个公式 <code>a = n*b - x</code> 的含义是：</p><ul><li>从链表起点到环入口的距离 <code>a</code></li><li>等于从相遇点出发，走 <code>n*b - x</code> 的距离。</li><li><code>n*b</code> 意味着在环里绕 <code>n</code> 圈，位置不变。<code>-x</code> 意味着从相遇点往回走 <code>x</code> 步，正好就是环的入口。</li></ul><p>所以，当一个指针从起点出发，另一个指针从相遇点出发，它们最终会在环的入口相遇。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java.util.Scanner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Scanner</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> scanner</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Scanner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">in</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 读取数组长度</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> scanner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nextInt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];  </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 题目说明数组长度为 n+1</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 读取数组元素</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n; i++) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            nums[i] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> scanner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">nextInt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">        Solution</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> solution</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> result</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">findDuplicate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(nums);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(result);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        scanner</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> findDuplicate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">nums</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> slow</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fast</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 第一阶段：找到相遇点</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        do</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[slow];</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[nums[fast]];</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fast);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">        // 第二阶段：找到环的入口</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fast) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            slow </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[slow];</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            fast </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> nums[fast];</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> slow; </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// 或者 return fast，此时它们相等</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析"><span>复杂度分析</span></a></h2><ul><li><p><strong>时间复杂度：O(n)</strong></p><ul><li>第一阶段，快指针在追上慢指针之前，走的步数不会超过链表长度 <code>n</code>。</li><li>第二阶段，两个指针分别从起点和相遇点出发，相遇时走的步数也不会超过 <code>n</code>。</li><li>因此，总的时间复杂度是线性的。</li></ul></li><li><p><strong>空间复杂度：O(1)</strong></p><ul><li>我们只使用了 <code>slow</code> 和 <code>fast</code> 两个指针，是常量级的额外空间。</li></ul><p>抽象成环形链表II 快慢指针找到入口</p></li></ul>',34)],e={},t=(0,n(66262).A)(e,[["render",function(s,i){return(0,a.uX)(),(0,a.CE)("div",null,l)}]]),h=JSON.parse('{"path":"/leetcode/%E6%8A%80%E5%B7%A7/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html","title":"287.寻找重复数","lang":"zh-CN","frontmatter":{"title":"287.寻找重复数","description":"题目描述 给定一个包含 n + 1 个整数的数组 nums，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有一个重复的整数，返回这个重复的数。 要求： 必须不修改数组 nums 只能使用常量级 O(1) 的额外空间 示例 1: 示例 2: 解题思路：快慢指针 (Floyd 判圈算法) 这道题的限制...","head":[["meta",{"property":"og:url","content":"https://xlb3055.github.io/newBlog/leetcode/%E6%8A%80%E5%B7%A7/287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"Bin的技术博客"}],["meta",{"property":"og:title","content":"287.寻找重复数"}],["meta",{"property":"og:description","content":"题目描述 给定一个包含 n + 1 个整数的数组 nums，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。 假设 nums 只有一个重复的整数，返回这个重复的数。 要求： 必须不修改数组 nums 只能使用常量级 O(1) 的额外空间 示例 1: 示例 2: 解题思路：快慢指针 (Floyd 判圈算法) 这道题的限制..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-19T05:06:09.000Z"}],["meta",{"property":"article:author","content":"Bin"}],["meta",{"property":"article:modified_time","content":"2025-12-19T05:06:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"287.寻找重复数\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-12-19T05:06:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Bin\\",\\"url\\":\\"/avator_img.jpg\\"}]}"]]},"headers":[{"level":2,"title":"题目描述","slug":"题目描述","link":"#题目描述","children":[]},{"level":2,"title":"解题思路：快慢指针 (Floyd 判圈算法)","slug":"解题思路-快慢指针-floyd-判圈算法","link":"#解题思路-快慢指针-floyd-判圈算法","children":[{"level":3,"title":"算法步骤","slug":"算法步骤","link":"#算法步骤","children":[]},{"level":3,"title":"为什么第二次相遇就是环的入口？","slug":"为什么第二次相遇就是环的入口","link":"#为什么第二次相遇就是环的入口","children":[]}]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":2,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]}],"git":{"createdTime":1764309659000,"updatedTime":1766120769000,"contributors":[{"name":"bin","email":"13598151+binxlb@user.noreply.gitee.com","commits":2}]},"readingTime":{"minutes":3.97,"words":1192},"filePathRelative":"leetcode/技巧/287.寻找重复数.md","localizedDate":"2025年11月28日","excerpt":"<h2>题目描述</h2>\\n<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code>，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>\\n<p>假设 <code>nums</code> 只有一个重复的整数，返回这个重复的数。</p>\\n<p><strong>要求：</strong></p>\\n<ul>\\n<li>必须<strong>不修改</strong>数组 <code>nums</code></li>\\n<li>只能使用常量级 <code>O(1)</code> 的额外空间</li>\\n</ul>","autoDesc":true}')}}]);