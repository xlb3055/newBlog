---
icon: pen-to-square
date: 2025-12-3
category:
- 后端
tag:
- 数组
- leecode
---

# 118. 杨辉三角

## 📝 题目描述
给定一个正整数 `numRows`，生成「杨辉三角」的前 `numRows` 行。

在杨辉三角中，每个数是它左上方与右上方两个数的和：

```

```
  1
 1 1
1 2 1
```

1 3 3 1
1 4 6 4 1

```

---

## 📌 示例

### 示例 1
输入：
```

numRows = 5

```
输出：
```

[
[1],
[1,1],
[1,2,1],
[1,3,3,1],
[1,4,6,4,1]
]

```

---

### 示例 2
输入：
```

numRows = 1

```

输出：
```

[[1]]

```

---

# 🚀 最优解：动态规划（按行生成）

### 🔍 思路解析

杨辉三角的生成规则：

- 每一行的首尾都是 `1`
- 中间的元素由上一行的两个数字相加：

```

cur[j] = pre[j-1] + pre[j]

````

例如生成第 4 行（1,3,3,1）：
- 第一个数字 1
- 中间：
  - 3 = 1 + 2
  - 3 = 2 + 1
- 最后一个数字 1

每一行都依赖上一行，因此我们可以从上往下依次生成。

---

## ✅ 完整代码（Java）

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        if (numRows == 0) return ans;

        // 第一行固定为 [1]
        List<Integer> firstRow = new ArrayList<>();
        firstRow.add(1);
        ans.add(firstRow);

        for (int i = 1; i < numRows; i++) {
            List<Integer> preRow = ans.get(i - 1);
            List<Integer> curRow = new ArrayList<>();

            curRow.add(1); // 每行开头的 1

            for (int j = 1; j < i; j++) {
                int sum = preRow.get(j - 1) + preRow.get(j);
                curRow.add(sum);
            }

            curRow.add(1); // 每行结尾的 1

            ans.add(curRow);
        }

        return ans;
    }
}
````

---

# 🧠 通俗易懂解释

你可以把杨辉三角理解为：

> 每一行都是上一行相邻两个数的和。

举例生成 5 行：

1. 第 1 行：`[1]`
2. 第 2 行：`[1, 1]`
3. 第 3 行：上一行为 `[1,1]`
   中间元素 = `1 + 1 = 2`
   → `[1, 2, 1]`
4. 第 4 行：上一行为 `[1,2,1]`
   中间元素 = `1+2=3`, `2+1=3`
   → `[1, 3, 3, 1]`
5. 第 5 行：上一行为 `[1,3,3,1]`
   中间元素 = `1+3=4`, `3+3=6`, `3+1=4`
   → `[1, 4, 6, 4, 1]`

依次构造即可。

---

# ⏱ 时间复杂度

### **O(numRows²)**

第 1 行 1 个数，
第 2 行 2 个数，
…
第 n 行 n 个数。

总数约为：

```
1 + 2 + ... + n = O(n²)
```

---

# 💾 空间复杂度

### **O(numRows²)**

因为最终返回整个杨辉三角列表。

---
