---
icon: pen-to-square
date: 2025-12-03
category:
- 后端
tag:
- 数组
- leecode
---

# 70. 爬楼梯

## 📝 题目描述
你正在爬楼梯，需要走到第 `n` 阶。

每次你可以爬 **1 步** 或 **2 步**。

问：到达第 `n` 阶有多少种不同的方法？

---

## 📌 示例

### 示例 1
输入：
```

n = 2

```
输出：
```

2

```
解释：
1. 1 + 1  
2. 2

---

### 示例 2
输入：
```

n = 3

```
输出：
```

3

```
解释：
1. 1 + 1 + 1  
2. 1 + 2  
3. 2 + 1  

---

# 🚀 最优解：动态规划（Fibonacci 数列）

### 🔍 思路解析

爬到第 `n` 阶，可以有两种方式：

- 最后一步走 **1 步**：那之前在第 `n-1` 阶  
- 最后一步走 **2 步**：那之前在第 `n-2` 阶  

所以：

```

dp[i] = dp[i - 1] + dp[i - 2]

```

初始条件：

```

dp[0] = 1  （站在起点，有 1 种方式——不动）
dp[1] = 1  （只剩 1 阶，只能 1 步）

````

这就是**斐波那契数列**。

---

## ✅ 完整代码（Java）

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for(int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
````

---

# 🧠 通俗易懂解释

你可以把每个楼梯想成：

> “走到这一阶之前我可能来自上一阶，或者上两阶。”

举例：
n = 3

到第 3 阶的方式数：

* 来自第 2 阶 → dp[2]
* 来自第 1 阶 → dp[1]

所以：

```
dp[3] = dp[2] + dp[1] = 2 + 1 = 3
```

这和 Fibonacci（斐波那契）一模一样。

---

# ⏱ 时间复杂度

### **O(n)**

只遍历一次即可。

---

# 💾 空间复杂度

### **O(n)**

使用了一个长度为 n 的 dp 数组。
