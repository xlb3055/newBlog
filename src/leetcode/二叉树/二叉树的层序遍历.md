---
icon: pen-to-square
date: 2026-1-21
category:
  - 后端
tag:
  - 二叉树
  - 层序遍历
  - leetcode
---

# 102. 二叉树的层序遍历

---

## 题目
**描述：**
给你二叉树的根节点 `root`，返回其节点值的**层序遍历**（即逐层地，从左到右访问所有节点）。

**示例：**
示例 1:
```
输入: root = [3,9,20,null,null,15,7]
输出: [[3],[9,20],[15,7]]
```
示例 2:
```
输入: root = [1]
输出: [[1]]
```
示例 3:
```
输入: root = []
输出: []
```

---

## 解题思路
### 核心方法
**迭代法（广度优先搜索 BFS）**：使用队列存储每一层的节点，每次遍历当前队列中的所有节点（即当前层的节点），并将它们的子节点加入队列，从而实现逐层遍历。

### 算法步骤
1.  **初始化队列和结果列表**：将根节点加入队列，创建二维列表存储每一层的节点值。
2.  **处理空树**：如果根节点为 `null`，直接返回空列表。
3.  **逐层遍历**：
    - 记录当前队列的大小（即当前层的节点数）。
    - 遍历当前层的所有节点，将节点值加入当前层的列表，并将非空的左右子节点加入队列。
    - 将当前层的列表加入结果列表。
4.  **返回结果**：遍历完成后，返回结果列表。

---

## 代码实现

### 迭代法（Java）
```java
import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        queue.add(root);
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> level = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode temp = queue.poll();
                level.add(temp.val);
                if (temp.left != null) {
                    queue.add(temp.left);
                }
                if (temp.right != null) {
                    queue.add(temp.right);
                }
            }
            ans.add(level);
        }
        return ans;
    }
}
```

---

## 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是二叉树的节点数。每个节点会被入队和出队一次。
- **空间复杂度**：`O(m)`，`m` 是二叉树的最大宽度，最坏情况下（完全二叉树）为 `O(n)`。

---

## 总结
1.  层序遍历的核心是使用队列实现广度优先搜索，确保节点按层处理。
2.  每次处理当前层时，通过队列的大小确定当前层的节点数，从而保证逐层输出。
3.  该方法时间效率高，且避免了递归栈溢出的风险，适合处理大规模树结构。

---

