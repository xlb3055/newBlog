---
icon: pen-to-square
date: 2026-1-21
category:
  - 后端
tag:
  - 二叉树
  - 递归
  - leetcode
---

# 236. 二叉树的最近公共祖先

---

## 题目
**描述：**
给定一个二叉树，找到该树中两个指定节点的**最近公共祖先**。
最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

**示例：**
示例 1:
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```
示例 2:
```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5，因为根据定义最近公共祖先节点可以为节点本身。
```

---

## 解题思路
### 核心方法
**递归后序遍历**：
1.  **终止条件**：当前节点为 `null`，或当前节点是 `p` 或 `q`，直接返回当前节点。
2.  **递归遍历**：分别递归遍历左子树和右子树，得到左子树和右子树的返回结果 `left` 和 `right`。
3.  **判断公共祖先**：
    - 若 `left` 和 `right` 均不为 `null`，说明 `p` 和 `q` 分别在左、右子树中，当前节点即为最近公共祖先。
    - 若 `left` 为 `null`，说明 `p` 和 `q` 都在右子树中，返回 `right`。
    - 若 `right` 为 `null`，说明 `p` 和 `q` 都在左子树中，返回 `left`。

---

## 代码实现

### 递归法（Java）
```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left == null) return right;
        if (right == null) return left;
        return root;
    }
}
```

---

## 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是二叉树的节点数。每个节点会被访问一次。
- **空间复杂度**：`O(h)`，`h` 是二叉树的高度。递归栈的深度取决于树的高度，最坏情况下（链状树）为 `O(n)`。

---

## 总结
1.  该方法通过后序遍历，自底向上判断公共祖先，时间效率高，实现简洁。
2.  无需额外存储路径，仅通过递归返回值即可确定最近公共祖先，空间效率较高。
3.  适用于任意二叉树的最近公共祖先问题，包括二叉搜索树和普通二叉树。

---

