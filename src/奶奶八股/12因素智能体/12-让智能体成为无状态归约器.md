---
icon: pen-to-square
date: 2026-02-13
category:
- 后端
tag:
- 12因素智能体
- 大模型
- Factor-12
---

# 因素12：让智能体成为无状态归约器

> 来源：12-Factor Agents / Factor 12（Make your agent a stateless reducer）

## 一句话先懂

把核心逻辑做成“纯归约”：输入旧状态和新事件，输出新状态与待执行动作，便于测试、回放和扩展。

## 奶奶版理解

记账规则很简单：

- 旧余额 + 新流水 = 新余额

规则固定，就能重复算、反复查，不会乱。

## 原文精神

Factor 12 偏工程审美，但非常实用：让 agent 逻辑更函数式、可推导、可验证，而不是到处散落副作用。

## 简化模型

```ts
type State = { events: Event[] };
type Effect = { type: string; payload: unknown };

function reducer(state: State, event: Event): { state: State; effects: Effect[] } {
  const next = { ...state, events: [...state.events, event] };

  if (event.type === "human_response") {
    return {
      state: next,
      effects: [{ type: "resume_agent", payload: { threadId: event.threadId } }]
    };
  }

  return { state: next, effects: [] };
}
```

副作用执行器（调用 API、发消息）放在 reducer 外部。

## 为什么值钱

- **可重放**：重放事件可复现状态。
- **可测试**：同输入必得同输出。
- **可演进**：新增事件类型即可扩展能力。
- **可审计**：每一步状态变化有据可查。

## 常见误区

- 在 reducer 内直接发请求，破坏纯函数。
- 直接改写 state（mutable），导致不可重现。
- 事件版本管理缺失，升级后历史无法兼容。

## 我的思考

这条是“长期主义”工程实践。  
短期看它可能有点重，但当系统规模变大（多团队、多渠道、多审批）时，它会极大降低维护成本。

## 小结

- 归约器思想让 agent 从“脚本”升级为“系统”。
- 纯逻辑与副作用分离，是稳定性的关键。
- 当你要做可扩展、可审计智能体时，这条非常重要。
