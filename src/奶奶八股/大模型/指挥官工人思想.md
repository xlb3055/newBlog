---
icon: pen-to-square
date: 2025-1-05
category:
- 后端
tag:
- Skills
- 大模型
---


---

# leader-worker

## 1. 核心思想：指挥官和工人

**比喻版**：

* 想象你家有一件大事要做：比如做一桌丰盛的饭菜。
* **指挥官（Commander）** = 你奶奶坐在椅子上，总览全局，分配任务：谁切菜、谁炒菜、谁洗碗。
* **工人（Worker）** = 你的家人或你自己，执行指挥官安排的具体任务。

这个思想在 AI 世界里，就是 **一个模型负责规划和分工，其他模型或同一模型的不同实例执行具体任务**。

核心优势：

* 可以同时处理多个任务
* 更像团队合作，而不是单打独斗
* 适合复杂问题的分解和解决

---

## 2. 经典实现：Leader + Subagent

### 2.1 Claude 风格

* **Leader（指挥官）**：规划任务，分配任务给 Subagent
* **Subagent（工人）**：每个 Subagent 执行一部分任务，完成后反馈结果
* **Leader 收集反馈**，整合结果 → 输出最终答案

流程图简化版：

```
用户需求 → 指挥官(Leader) → 分配任务 → 工人(Subagent) 执行 → 返回结果 → 指挥官整合 → 用户得到答案
```

> 示例：查询一个公司的多个部门信息
> Leader：拆分成财务、市场、研发三个子任务
> Subagent：分别抓取财务、市场、研发信息
> Leader：整合三个部门信息 → 输出完整报告

---

## 3. 没有 Subagent 的实现（用 Codex / 同一模型）

如果你没有 Subagent，**同一个模型也能扮演指挥官 + 工人的角色**，关键是**让模型在不同上下文中“自我分工”**。

### 3.1 思路

1. **指挥官阶段**：模型生成分任务列表
2. **工人阶段**：模型逐个执行任务（可以在循环或递归中调用同一模型）
3. **汇总阶段**：模型整合子任务结果，输出最终答案

本质就是“在同一模型内模拟多智能体协作”。

---

### 3.2 Python + OpenAI Codex 示例

```python
# 文件路径: multi_agent_codex_demo.py
"""
模拟“指挥官 + 工人”思想的通用实现
用同一个 Codex 模型完成任务分解和执行
"""

from openai import OpenAI

client = OpenAI(api_key="YOUR_API_KEY")

def ask_model(prompt):
    """
    通用函数：向模型提问，返回文本
    """
    response = client.completions.create(
        model="code-davinci-002",
        prompt=prompt,
        max_tokens=300
    )
    return response.choices[0].text.strip()

def commander_task(user_request):
    """
    指挥官阶段：分解任务
    """
    prompt = f"""
    你是指挥官，负责把用户请求拆分成子任务。
    用户请求: {user_request}
    请输出可执行的子任务列表，每个任务一行。
    """
    tasks_text = ask_model(prompt)
    tasks = [t.strip() for t in tasks_text.split("\n") if t.strip()]
    return tasks

def worker_task(task):
    """
    工人阶段：执行具体子任务
    """
    prompt = f"""
    你是工人，负责完成以下任务:
    {task}
    请输出详细结果。
    """
    result = ask_model(prompt)
    return result

def integrate_results(results):
    """
    汇总阶段：整合所有子任务结果
    """
    summary_prompt = f"""
    你是指挥官，将以下结果整合成最终报告:
    {results}
    """
    final_result = ask_model(summary_prompt)
    return final_result

# 使用示例
if __name__ == "__main__":
    user_request = "请整理公司 ABC 各部门信息"
    
    # 指挥官分解任务
    tasks = commander_task(user_request)
    
    # 工人执行任务
    results = []
    for task in tasks:
        result = worker_task(task)
        results.append(result)
    
    # 指挥官汇总
    final_report = integrate_results("\n".join(results))
    print("=== 最终报告 ===")
    print(final_report)
```

特点：

* 同一个模型既能分任务，又能执行任务
* 通过循环和上下文模拟多个“工人”
* 不需要 Subagent，也能实现 Leader + Worker 思想

---

## 4. 扩展：多模型 / 多线程并行实现

如果想更高效，可以：

1. **使用多线程**：每个工人任务并行执行
2. **使用不同模型**：比如 GPT-4 当 Leader，Codex 当 Worker
3. **异步 API 调用**：大幅提升处理复杂任务的速度

---

## 5. 核心总结（奶奶也能懂）

| 概念          | AI 对应             | 生活类比            |
| ----------- | ----------------- | --------------- |
| 指挥官（Leader） | 规划、分配任务的模型        | 家长/领队           |
| 工人（Worker）  | 执行具体子任务的模型/循环调用模型 | 家人/小组成员         |
| 汇总          | 收集所有工人结果          | 家长检查每道菜做好了吗     |
| 优势          | 分工、并行、可处理大任务      | 一家人分工合作，比一个人忙活快 |

核心思想总结：

> “把一个大任务拆成小任务，让指挥官分配，工人执行，然后再由指挥官整合。”
> 无论是 Claude Subagent 还是单 Codex 循环调用，都能实现这个思想。

---
